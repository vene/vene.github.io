<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Vlad Niculae (~vene)</title><link>http://vene.ro/</link><description></description><atom:link href="http://vene.ro/feeds/vene.rss.xml" rel="self"></atom:link><lastBuildDate>Mon, 06 Jul 2015 00:00:00 +0200</lastBuildDate><item><title>Flask-SocketIO on OpenShift: fallback on another port</title><link>http://vene.ro/blog/flask-socketio-openshift-fallback-xhr-polling.html</link><description>&lt;h2&gt;&lt;span class="caps"&gt;TL&lt;/span&gt;; &lt;span class="caps"&gt;DR&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;I hacked the &lt;a href="https://gist.github.com/vene/c0657d854ae74a4511d2"&gt;SocketIO client
0.9.16&lt;/a&gt; to support
specifying a special port (&lt;code&gt;wsport&lt;/code&gt;) to use only for the WebSocket protocol,
while keeping all other traffic on the default port. This is required by setups
such as OpenShift which require WebSocket traffic to come over a different port
(say &lt;code&gt;8000&lt;/code&gt; rather than &lt;code&gt;80&lt;/code&gt;).&lt;/p&gt;
&lt;h2&gt;The current state of&amp;nbsp;affairs&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;ve been trying to host an interactive web app with WebSockets on
&lt;a href="https://www.openshift.com/"&gt;OpenShift&lt;/a&gt;. Since I&amp;#8217;m a poor student and this
is a research app, I wanted a reasonably powerful free hosting&amp;nbsp;option.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.openshift.com/paas-websockets/"&gt;OpenShift added WebSockets support over 2 years
ago.&lt;/a&gt; But because of some
internal limitations, the WebSocket traffic needs to go over different ports
than usual (&lt;code&gt;8000&lt;/code&gt; for unsecured and &lt;code&gt;8443&lt;/code&gt; for secured&amp;nbsp;connections).&lt;/p&gt;
&lt;p&gt;&lt;a href="http://socket.io/"&gt;SocketIO&lt;/a&gt; is a cool library that allows event-driven
bidirectional traffic in web apps.  It tries to use WebSockets if available,
and falls back to other transport protocols (such as &lt;a href="https://en.wikipedia.org/wiki/Push_technology#Long_polling"&gt;&lt;span class="caps"&gt;XHR&lt;/span&gt; Long
Polling&lt;/a&gt;)&amp;nbsp;otherwise.&lt;/p&gt;
&lt;p&gt;Oh and to make matters worse, I&amp;#8217;m using Flask for this web app, and currently
the best way to use SocketIO from Flask is with the &lt;a href="https://flask-socketio.readthedocs.org/en/latest/"&gt;Flask-SocketIO&lt;/a&gt; +
&lt;a href="http://gevent-socketio.readthedocs.org/"&gt;gevent-socketio&lt;/a&gt; combo, which is,
alas, incompatible with recent versions of SocketIO. According to the
community, the most stable release is SocketIO&amp;nbsp;0.9.16.&lt;/p&gt;
&lt;h2&gt;The problem in a&amp;nbsp;nutshell&lt;/h2&gt;
&lt;p&gt;When debugging my app locally, I&amp;#8217;d connect with something&amp;nbsp;like&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;var socket = io.connect(
    &amp;#39;http://&amp;#39; + document.domain + &amp;#39;:&amp;#39; + location.port + &amp;#39;/chat&amp;#39;
);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When deploying on OpenShift, the &lt;code&gt;location.port&lt;/code&gt; is now different from the
WebSocket port, so I used a Flask config that determines server-side where it&amp;#8217;s
running&amp;nbsp;from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;var wsport = &amp;#39;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;config&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;WEBSOCKET_PORT&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&amp;#39;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The app now runs great both when debugging locally or on OpenShift, except if
for some reason the WebSocket connection fails (either if the browser is old
or because of strict firewalls).  This happens because long polling uses normal
&lt;span class="caps"&gt;HTTP&lt;/span&gt; requests and should be done over the default port, rather than the
OpenShift-specific&amp;nbsp;one.&lt;/p&gt;
&lt;h2&gt;Making things&amp;nbsp;work&lt;/h2&gt;
&lt;p&gt;My first thought was to work around it by &lt;a href="http://stackoverflow.com/questions/8588689/node-js-socket-io-client-connect-failed-event"&gt;manually implementing the fallback
client-side&lt;/a&gt;.  This, surprisingly, failed: it turns out that
SocketIO 0.9.16 first attempts a handshake to find out what transports the
server supports. If the initial connection is on port &lt;code&gt;8000&lt;/code&gt;, then the
handshake will be attempted also on port &lt;code&gt;8000&lt;/code&gt;, so the &lt;code&gt;connect_failed&lt;/code&gt; event
won&amp;#8217;t even be triggered.  The second cleanest solution I could think of was to
add another parameter to the SocketIO options, &lt;code&gt;wsport&lt;/code&gt;, allowing the user to
specify a different port over which to do WebSocket connections, while keeping
all other traffic over the default port.  This works like a&amp;nbsp;charm!&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gist.github.com/vene/c0657d854ae74a4511d2"&gt;My updated SocketIO client is available as a
gist&lt;/a&gt;, and the client-side
connection code looks like&amp;nbsp;this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;var socket = io.connect(
    &amp;#39;http://&amp;#39; + document.domain + &amp;#39;/chat&amp;#39;,
    {
        port: location.port,
        wsport: wsport || location.port,
        &amp;quot;connect timeout&amp;quot;: 5000
    }
);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I had to reduce the connection timeout, for a better user experience.  I&amp;#8217;m way
out of my comfort zone here, so in case I missed a better solution, do let me&amp;nbsp;know!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Mon, 06 Jul 2015 00:00:00 +0200</pubDate><guid>tag:vene.ro,2015-07-06:blog/flask-socketio-openshift-fallback-xhr-polling.html</guid><category>flask-socketio</category><category>flask</category><category>socketio</category><category>openshift</category></item><item><title>Kemeny-Young Optimal Rank Aggregation in Python</title><link>http://vene.ro/blog/kemeny-young-optimal-rank-aggregation-in-python.html</link><description>&lt;style type="text/css"&gt;/*!
*
* IPython notebook
*
*/
/* &lt;span class="caps"&gt;CSS&lt;/span&gt; font colors for translated &lt;span class="caps"&gt;ANSI&lt;/span&gt; colors. */
.ansibold {
  font-weight: bold;
}
/* use dark versions for foreground, to improve visibility */
.ansiblack {
  color: black;
}
.ansired {
  color: darkred;
}
.ansigreen {
  color: darkgreen;
}
.ansiyellow {
  color: #c4a000;
}
.ansiblue {
  color: darkblue;
}
.ansipurple {
  color: darkviolet;
}
.ansicyan {
  color: steelblue;
}
.ansigray {
  color: gray;
}
/* and light for background, for the same reason */
.ansibgblack {
  background-color: black;
}
.ansibgred {
  background-color: red;
}
.ansibggreen {
  background-color: green;
}
.ansibgyellow {
  background-color: yellow;
}
.ansibgblue {
  background-color: blue;
}
.ansibgpurple {
  background-color: magenta;
}
.ansibgcyan {
  background-color: cyan;
}
.ansibggray {
  background-color: gray;
}
div.cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  border-radius: 2px;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  border-width: 1px;
  border-style: solid;
  border-color: transparent;
  width: 100%;
  padding: 5px;
  /* This acts as a spacer between cells, that is outside the border */
  margin: 0px;
  outline: none;
  border-left-width: 1px;
  padding-left: 5px;
  background: linear-gradient(to right, transparent -40px, transparent 1px, transparent 1px, transparent 100%);
}
div.cell.jupyter-soft-selected {
  border-left-color: #&lt;span class="caps"&gt;90CAF9&lt;/span&gt;;
  border-left-color: #&lt;span class="caps"&gt;E3F2FD&lt;/span&gt;;
  border-left-width: 1px;
  padding-left: 5px;
  border-right-color: #&lt;span class="caps"&gt;E3F2FD&lt;/span&gt;;
  border-right-width: 1px;
  background: #&lt;span class="caps"&gt;E3F2FD&lt;/span&gt;;
}
@media print {
  div.cell.jupyter-soft-selected {
    border-color: transparent;
  }
}
div.cell.selected {
  border-color: #ababab;
  border-left-width: 0px;
  padding-left: 6px;
  background: linear-gradient(to right, #&lt;span class="caps"&gt;42A5F5&lt;/span&gt; -40px, #&lt;span class="caps"&gt;42A5F5&lt;/span&gt; 5px, transparent 5px, transparent 100%);
}
@media print {
  div.cell.selected {
    border-color: transparent;
  }
}
div.cell.selected.jupyter-soft-selected {
  border-left-width: 0;
  padding-left: 6px;
  background: linear-gradient(to right, #&lt;span class="caps"&gt;42A5F5&lt;/span&gt; -40px, #&lt;span class="caps"&gt;42A5F5&lt;/span&gt; 7px, #&lt;span class="caps"&gt;E3F2FD&lt;/span&gt; 7px, #&lt;span class="caps"&gt;E3F2FD&lt;/span&gt; 100%);
}
.edit_mode div.cell.selected {
  border-color: #&lt;span class="caps"&gt;66BB6A&lt;/span&gt;;
  border-left-width: 0px;
  padding-left: 6px;
  background: linear-gradient(to right, #&lt;span class="caps"&gt;66BB6A&lt;/span&gt; -40px, #&lt;span class="caps"&gt;66BB6A&lt;/span&gt; 5px, transparent 5px, transparent 100%);
}
@media print {
  .edit_mode div.cell.selected {
    border-color: transparent;
  }
}
.prompt {
  /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */
  min-width: 14ex;
  /* This padding is tuned to match the padding on the CodeMirror editor. */
  padding: 0.4em;
  margin: 0px;
  font-family: monospace;
  text-align: right;
  /* This has to match that of the the CodeMirror class line-height below */
  line-height: 1.21429em;
  /* Don't highlight prompt number selection */
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  /* Use default cursor */
  cursor: default;
}
@media (max-width: 540px) {
  .prompt {
    text-align: left;
  }
}
div.inner_cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
}
@-moz-document url-prefix() {
  div.inner_cell {
    overflow-x: hidden;
  }
}
/* input_area and input_prompt must match in top border and margin for alignment */
div.input_area {
  border: 1px solid #cfcfcf;
  border-radius: 2px;
  background: #f7f7f7;
  line-height: 1.21429em;
}
/* This is needed so that empty prompt areas can collapse to zero height when there
   is no content in the output_subarea and the prompt. The main purpose of this is
   to make sure that empty JavaScript output_subareas have no height. */
div.prompt:empty {
  padding-top: 0;
  padding-bottom: 0;
}
div.unrecognized_cell {
  padding: 5px 5px 5px 0px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
div.unrecognized_cell .inner_cell {
  border-radius: 2px;
  padding: 5px;
  font-weight: bold;
  color: red;
  border: 1px solid #cfcfcf;
  background: #eaeaea;
}
div.unrecognized_cell .inner_cell a {
  color: inherit;
  text-decoration: none;
}
div.unrecognized_cell .inner_cell a:hover {
  color: inherit;
  text-decoration: none;
}
@media (max-width: 540px) {
  div.unrecognized_cell &gt; div.prompt {
    display: none;
  }
}
div.code_cell {
  /* avoid page breaking on code cells when printing */
}
@media print {
  div.code_cell {
    page-break-inside: avoid;
  }
}
/* any special styling for code cells that are currently running goes here */
div.input {
  page-break-inside: avoid;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.input {
    /* Old browsers */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-box-align: stretch;
    display: -moz-box;
    -moz-box-orient: vertical;
    -moz-box-align: stretch;
    display: box;
    box-orient: vertical;
    box-align: stretch;
    /* Modern browsers */
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
}
/* input_area and input_prompt must match in top border and margin for alignment */
div.input_prompt {
  color: #&lt;span class="caps"&gt;303F9F&lt;/span&gt;;
  border-top: 1px solid transparent;
}
div.input_area &gt; div.highlight {
  margin: 0.4em;
  border: none;
  padding: 0px;
  background-color: transparent;
}
div.input_area &gt; div.highlight &gt; pre {
  margin: 0px;
  border: none;
  padding: 0px;
  background-color: transparent;
}
/* The following gets added to the &lt;head&gt; if it is detected that the user has a
 * monospace font with inconsistent normal/bold/italic height.  See
 * notebookmain.js.  Such fonts will have keywords vertically offset with
 * respect to the rest of the text.  The user should select a better font.
 * See: https://github.com/ipython/ipython/issues/1503
 *
 * .CodeMirror span {
 *      vertical-align: bottom;
 * }
 */
.CodeMirror {
  line-height: 1.21429em;
  /* Changed from 1em to our global default */
  font-size: 14px;
  height: auto;
  /* Changed to auto to autogrow */
  background: none;
  /* Changed from white to allow our bg to show through */
}
.CodeMirror-scroll {
  /*  The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/
  /*  We have found that if it is visible, vertical scrollbars appear with font size changes.*/
  overflow-y: hidden;
  overflow-x: auto;
}
.CodeMirror-lines {
  /* In &lt;span class="caps"&gt;CM2&lt;/span&gt;, this used to be 0.4em, but in &lt;span class="caps"&gt;CM3&lt;/span&gt; it went to 4px. We need the em value because */
  /* we have set a different line-height and want this to scale with that. */
  padding: 0.4em;
}
.CodeMirror-linenumber {
  padding: 0 8px 0 4px;
}
.CodeMirror-gutters {
  border-bottom-left-radius: 2px;
  border-top-left-radius: 2px;
}
.CodeMirror pre {
  /* In &lt;span class="caps"&gt;CM3&lt;/span&gt; this went to 4px from 0 in &lt;span class="caps"&gt;CM2&lt;/span&gt;. We need the 0 value because of how we size */
  /* .CodeMirror-lines */
  padding: 0;
  border: 0;
  border-radius: 0;
}
/*

Original style from softwaremaniacs.org (c) Ivan Sagalaev &lt;Maniac@SoftwareManiacs.Org&gt;
Adapted from GitHub theme

*/
.highlight-base {
  color: #000;
}
.highlight-variable {
  color: #000;
}
.highlight-variable-2 {
  color: #1a1a1a;
}
.highlight-variable-3 {
  color: #333333;
}
.highlight-string {
  color: #&lt;span class="caps"&gt;BA2121&lt;/span&gt;;
}
.highlight-comment {
  color: #408080;
  font-style: italic;
}
.highlight-number {
  color: #080;
}
.highlight-atom {
  color: #88F;
}
.highlight-keyword {
  color: #008000;
  font-weight: bold;
}
.highlight-builtin {
  color: #008000;
}
.highlight-error {
  color: #f00;
}
.highlight-operator {
  color: #&lt;span class="caps"&gt;AA22FF&lt;/span&gt;;
  font-weight: bold;
}
.highlight-meta {
  color: #&lt;span class="caps"&gt;AA22FF&lt;/span&gt;;
}
/* previously not defined, copying from default codemirror */
.highlight-def {
  color: #00f;
}
.highlight-string-2 {
  color: #f50;
}
.highlight-qualifier {
  color: #555;
}
.highlight-bracket {
  color: #997;
}
.highlight-tag {
  color: #170;
}
.highlight-attribute {
  color: #00c;
}
.highlight-header {
  color: blue;
}
.highlight-quote {
  color: #090;
}
.highlight-link {
  color: #00c;
}
/* apply the same style to codemirror */
.cm-s-ipython span.cm-keyword {
  color: #008000;
  font-weight: bold;
}
.cm-s-ipython span.cm-atom {
  color: #88F;
}
.cm-s-ipython span.cm-number {
  color: #080;
}
.cm-s-ipython span.cm-def {
  color: #00f;
}
.cm-s-ipython span.cm-variable {
  color: #000;
}
.cm-s-ipython span.cm-operator {
  color: #&lt;span class="caps"&gt;AA22FF&lt;/span&gt;;
  font-weight: bold;
}
.cm-s-ipython span.cm-variable-2 {
  color: #1a1a1a;
}
.cm-s-ipython span.cm-variable-3 {
  color: #333333;
}
.cm-s-ipython span.cm-comment {
  color: #408080;
  font-style: italic;
}
.cm-s-ipython span.cm-string {
  color: #&lt;span class="caps"&gt;BA2121&lt;/span&gt;;
}
.cm-s-ipython span.cm-string-2 {
  color: #f50;
}
.cm-s-ipython span.cm-meta {
  color: #&lt;span class="caps"&gt;AA22FF&lt;/span&gt;;
}
.cm-s-ipython span.cm-qualifier {
  color: #555;
}
.cm-s-ipython span.cm-builtin {
  color: #008000;
}
.cm-s-ipython span.cm-bracket {
  color: #997;
}
.cm-s-ipython span.cm-tag {
  color: #170;
}
.cm-s-ipython span.cm-attribute {
  color: #00c;
}
.cm-s-ipython span.cm-header {
  color: blue;
}
.cm-s-ipython span.cm-quote {
  color: #090;
}
.cm-s-ipython span.cm-link {
  color: #00c;
}
.cm-s-ipython span.cm-error {
  color: #f00;
}
.cm-s-ipython span.cm-tab {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=);
  background-position: right;
  background-repeat: no-repeat;
}
div.output_wrapper {
  /* this position must be relative to enable descendents to be absolute within it */
  position: relative;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
  z-index: 1;
}
/* class for the output area when it should be height-limited */
div.output_scroll {
  /* ideally, this would be max-height, but &lt;span class="caps"&gt;FF&lt;/span&gt; barfs all over that */
  height: 24em;
  /* &lt;span class="caps"&gt;FF&lt;/span&gt; needs this *and the wrapper* to specify full width, or it will shrinkwrap */
  width: 100%;
  overflow: auto;
  border-radius: 2px;
  -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
  box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8);
  display: block;
}
/* output div while it is collapsed */
div.output_collapsed {
  margin: 0px;
  padding: 0px;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
div.out_prompt_overlay {
  height: 100%;
  padding: 0px 0.4em;
  position: absolute;
  border-radius: 2px;
}
div.out_prompt_overlay:hover {
  /* use inner shadow to get border that is computed the same on WebKit/&lt;span class="caps"&gt;FF&lt;/span&gt; */
  -webkit-box-shadow: inset 0 0 1px #000;
  box-shadow: inset 0 0 1px #000;
  background: rgba(240, 240, 240, 0.5);
}
div.output_prompt {
  color: #D84315;
}
/* This class is the outer container of all output sections. */
div.output_area {
  padding: 0px;
  page-break-inside: avoid;
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
div.output_area .MathJax_Display {
  text-align: left !important;
}
div.output_area 
div.output_area 
div.output_area img,
div.output_area svg {
  max-width: 100%;
  height: auto;
}
div.output_area img.unconfined,
div.output_area svg.unconfined {
  max-width: none;
}
/* This is needed to protect the pre formating from global settings such
   as that of bootstrap */
.output {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: vertical;
  -moz-box-align: stretch;
  display: box;
  box-orient: vertical;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.output_area {
    /* Old browsers */
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-box-align: stretch;
    display: -moz-box;
    -moz-box-orient: vertical;
    -moz-box-align: stretch;
    display: box;
    box-orient: vertical;
    box-align: stretch;
    /* Modern browsers */
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
}
div.output_area pre {
  margin: 0;
  padding: 0;
  border: 0;
  vertical-align: baseline;
  color: black;
  background-color: transparent;
  border-radius: 0;
}
/* This class is for the output subarea inside the output_area and after
   the prompt div. */
div.output_subarea {
  overflow-x: auto;
  padding: 0.4em;
  /* Old browsers */
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  box-flex: 1;
  /* Modern browsers */
  flex: 1;
  max-width: calc(100% - 14ex);
}
div.output_scroll div.output_subarea {
  overflow-x: visible;
}
/* The rest of the output_* classes are for special styling of the different
   output types */
/* all text output has this class: */
div.output_text {
  text-align: left;
  color: #000;
  /* This has to match that of the the CodeMirror class line-height below */
  line-height: 1.21429em;
}
/* stdout/stderr are 'text' as well as 'stream', but execute_result/error are *not* streams */
div.output_stderr {
  background: #fdd;
  /* very light red background for stderr */
}
div.output_latex {
  text-align: left;
}
/* Empty output_javascript divs should have no height */
div.output_javascript:empty {
  padding: 0;
}
.js-error {
  color: darkred;
}
/* raw_input styles */
div.raw_input_container {
  line-height: 1.21429em;
  padding-top: 5px;
}
pre.raw_input_prompt {
  /* nothing needed here. */
}
input.raw_input {
  font-family: monospace;
  font-size: inherit;
  color: inherit;
  width: auto;
  /* make sure input baseline aligns with prompt */
  vertical-align: baseline;
  /* padding + margin = 0.5em between prompt and cursor */
  padding: 0em 0.25em;
  margin: 0em 0.25em;
}
input.raw_input:focus {
  box-shadow: none;
}
p.p-space {
  margin-bottom: 10px;
}
div.output_unrecognized {
  padding: 5px;
  font-weight: bold;
  color: red;
}
div.output_unrecognized a {
  color: inherit;
  text-decoration: none;
}
div.output_unrecognized a:hover {
  color: inherit;
  text-decoration: none;
}
.rendered_html {
  color: #000;
  /* any extras will just be numbers: */
}



.rendered_html :link {
  text-decoration: underline;
}
.rendered_html :visited {
  text-decoration: underline;
}






.rendered_html h1:first-child {
  margin-top: 0.538em;
}
.rendered_html h2:first-child {
  margin-top: 0.636em;
}
.rendered_html h3:first-child {
  margin-top: 0.777em;
}
.rendered_html h4:first-child {
  margin-top: 1em;
}
.rendered_html h5:first-child {
  margin-top: 1em;
}
.rendered_html h6:first-child {
  margin-top: 1em;
}








.rendered_html * + ul {
  margin-top: 1em;
}
.rendered_html * + ol {
  margin-top: 1em;
}


.rendered_html pre,



.rendered_html tr,
.rendered_html th,

.rendered_html td,


.rendered_html * + table {
  margin-top: 1em;
}

.rendered_html * + p {
  margin-top: 1em;
}

.rendered_html * + img {
  margin-top: 1em;
}
.rendered_html img,

.rendered_html img.unconfined,

div.text_cell {
  /* Old browsers */
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-align: stretch;
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-align: stretch;
  display: box;
  box-orient: horizontal;
  box-align: stretch;
  /* Modern browsers */
  display: flex;
  flex-direction: row;
  align-items: stretch;
}
@media (max-width: 540px) {
  div.text_cell &gt; div.prompt {
    display: none;
  }
}
div.text_cell_render {
  /*font-family: "Helvetica Neue", Arial, Helvetica, Geneva, sans-serif;*/
  outline: none;
  resize: none;
  width: inherit;
  border-style: none;
  padding: 0.5em 0.5em 0.5em 0.4em;
  color: #000;
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
}
a.anchor-link:link {
  text-decoration: none;
  padding: 0px 20px;
  visibility: hidden;
}
h1:hover .anchor-link,
h2:hover .anchor-link,
h3:hover .anchor-link,
h4:hover .anchor-link,
h5:hover .anchor-link,
h6:hover .anchor-link {
  visibility: visible;
}
.text_cell.rendered .input_area {
  display: none;
}
.text_cell.rendered 
.text_cell.unrendered .text_cell_render {
  display: none;
}
.cm-header-1,
.cm-header-2,
.cm-header-3,
.cm-header-4,
.cm-header-5,
.cm-header-6 {
  font-weight: bold;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}
.cm-header-1 {
  font-size: 185.7%;
}
.cm-header-2 {
  font-size: 157.1%;
}
.cm-header-3 {
  font-size: 128.6%;
}
.cm-header-4 {
  font-size: 110%;
}
.cm-header-5 {
  font-size: 100%;
  font-style: italic;
}
.cm-header-6 {
  font-size: 100%;
  font-style: italic;
}
&lt;/style&gt;
&lt;style type="text/css"&gt;.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #&lt;span class="caps"&gt;FF0000&lt;/span&gt; } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #&lt;span class="caps"&gt;BC7A00&lt;/span&gt; } /* Comment.Preproc */
.highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #&lt;span class="caps"&gt;FF0000&lt;/span&gt; } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #&lt;span class="caps"&gt;0044DD&lt;/span&gt; } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #&lt;span class="caps"&gt;BA2121&lt;/span&gt; } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #&lt;span class="caps"&gt;0000FF&lt;/span&gt;; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #&lt;span class="caps"&gt;AA22FF&lt;/span&gt; } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #&lt;span class="caps"&gt;D2413A&lt;/span&gt;; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #&lt;span class="caps"&gt;0000FF&lt;/span&gt; } /* Name.Function */
.highlight .nl { color: #&lt;span class="caps"&gt;A0A000&lt;/span&gt; } /* Name.Label */
.highlight .nn { color: #&lt;span class="caps"&gt;0000FF&lt;/span&gt;; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #&lt;span class="caps"&gt;AA22FF&lt;/span&gt;; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mb { color: #666666 } /* Literal.Number.Bin */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #&lt;span class="caps"&gt;BA2121&lt;/span&gt; } /* Literal.String.Backtick */
.highlight .sc { color: #&lt;span class="caps"&gt;BA2121&lt;/span&gt; } /* Literal.String.Char */
.highlight .sd { color: #&lt;span class="caps"&gt;BA2121&lt;/span&gt;; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #&lt;span class="caps"&gt;BA2121&lt;/span&gt; } /* Literal.String.Double */
.highlight .se { color: #&lt;span class="caps"&gt;BB6622&lt;/span&gt;; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #&lt;span class="caps"&gt;BA2121&lt;/span&gt; } /* Literal.String.Heredoc */
.highlight .si { color: #&lt;span class="caps"&gt;BB6688&lt;/span&gt;; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #&lt;span class="caps"&gt;BB6688&lt;/span&gt; } /* Literal.String.Regex */
.highlight .s1 { color: #&lt;span class="caps"&gt;BA2121&lt;/span&gt; } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */&lt;/style&gt;
&lt;style type="text/css"&gt;
/* Temporary definitions which will become obsolete with Notebook release 5.0 */
.ansi-black-fg { color: #&lt;span class="caps"&gt;3E424D&lt;/span&gt;; }
.ansi-black-bg { background-color: #&lt;span class="caps"&gt;3E424D&lt;/span&gt;; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #&lt;span class="caps"&gt;E75C58&lt;/span&gt;; }
.ansi-red-bg { background-color: #&lt;span class="caps"&gt;E75C58&lt;/span&gt;; }
.ansi-red-intense-fg { color: #&lt;span class="caps"&gt;B22B31&lt;/span&gt;; }
.ansi-red-intense-bg { background-color: #&lt;span class="caps"&gt;B22B31&lt;/span&gt;; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #&lt;span class="caps"&gt;DDB62B&lt;/span&gt;; }
.ansi-yellow-bg { background-color: #&lt;span class="caps"&gt;DDB62B&lt;/span&gt;; }
.ansi-yellow-intense-fg { color: #&lt;span class="caps"&gt;B27D12&lt;/span&gt;; }
.ansi-yellow-intense-bg { background-color: #&lt;span class="caps"&gt;B27D12&lt;/span&gt;; }
.ansi-blue-fg { color: #&lt;span class="caps"&gt;208FFB&lt;/span&gt;; }
.ansi-blue-bg { background-color: #&lt;span class="caps"&gt;208FFB&lt;/span&gt;; }
.ansi-blue-intense-fg { color: #&lt;span class="caps"&gt;0065CA&lt;/span&gt;; }
.ansi-blue-intense-bg { background-color: #&lt;span class="caps"&gt;0065CA&lt;/span&gt;; }
.ansi-magenta-fg { color: #&lt;span class="caps"&gt;D160C4&lt;/span&gt;; }
.ansi-magenta-bg { background-color: #&lt;span class="caps"&gt;D160C4&lt;/span&gt;; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #&lt;span class="caps"&gt;60C6C8&lt;/span&gt;; }
.ansi-cyan-bg { background-color: #&lt;span class="caps"&gt;60C6C8&lt;/span&gt;; }
.ansi-cyan-intense-fg { color: #&lt;span class="caps"&gt;258F8F&lt;/span&gt;; }
.ansi-cyan-intense-bg { background-color: #&lt;span class="caps"&gt;258F8F&lt;/span&gt;; }
.ansi-white-fg { color: #&lt;span class="caps"&gt;C5C1B4&lt;/span&gt;; }
.ansi-white-bg { background-color: #&lt;span class="caps"&gt;C5C1B4&lt;/span&gt;; }
.ansi-white-intense-fg { color: #&lt;span class="caps"&gt;A1A6B2&lt;/span&gt;; }
.ansi-white-intense-bg { background-color: #&lt;span class="caps"&gt;A1A6B2&lt;/span&gt;; }

.ansi-bold { font-weight: bold; }
&lt;/style&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Rank aggregation is a problem with many important applications and naive approaches to it go wrong in subtle&amp;nbsp;ways.&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s say that your national Quidditch league is dominated by five major wizard sports newspapers. Yes, the ones with moving images and everything.  Every week after the games, each of them publishes a ranking of the star players.  For now, let&amp;#8217;s suppose that the set of players under investigation is always the same, as the problem becomes a bit more complicated&amp;nbsp;otherwise.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Athletic Wizard&lt;/strong&gt;: Alicia Spinnet, Ginny Weasley, Gwendolyn Morgan, Robin Higgy, Debbie Muntz &lt;br /&gt;
&lt;strong&gt;The Daily Prophet&lt;/strong&gt;: Alicia, Ginny, Robin, Gwendolyn, Debbie &lt;br /&gt;
&lt;strong&gt;Quidditch News&lt;/strong&gt;: Robin, Ginny, Gwendolyn, Debbie, Alicia &lt;br /&gt;
&lt;strong&gt;Seeker Weekly&lt;/strong&gt;: Gwendolyn, Ginny, Robin, Debbie, Alicia &lt;br /&gt;
&lt;strong&gt;The Quibbler&lt;/strong&gt;: Debbie, Ginny, Robin, Gwendolyn, Alicia &lt;br /&gt;&lt;/p&gt;
&lt;p&gt;As you can see, there&amp;#8217;s quite a bit of disagreement and personal taste involved. You didn&amp;#8217;t get to watch all of the games, but you&amp;#8217;d like to make a decision on who the best players were, by somehow aggregating the opinions of the popular newspapers.  An easy option would be to pretend that each newspaper &lt;em&gt;votes&lt;/em&gt; for the player that they rank #1, and ignore the rest.  As Alicia Spinnet is the only player getting &lt;em&gt;two&lt;/em&gt; nominations for best player, she should win best player,&amp;nbsp;right?&lt;/p&gt;
&lt;p&gt;Upon closer inspection, Alicia seems very controversial, loved by two but hated by five of the newspaper.  Ginny, on the other hand, didn&amp;#8217;t stand out as best player to anybody, but she was &lt;em&gt;uniformly&lt;/em&gt; considered runner-up.  There should be some way to account for this. It would be nice if we would have a method of finding an &lt;em&gt;optimal&lt;/em&gt; ranking that maximizes some sort of agreement with the opinions we are trying to&amp;nbsp;aggregate.&lt;/p&gt;
&lt;h2 id="Kendall's-Tau-distance"&gt;Kendall&amp;#8217;s Tau distance&lt;a class="anchor-link" href="#Kendall's-Tau-distance"&gt;&amp;#182;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;One of the most interesting ways to measure disagreement between rankings is the Tau statistic introduced by Kendall.  It essentially measures the number of pairwise disagreements between two rankings.  Since you can think of it as the number of flips you need to perform on a ranking to turn it into the other, it is sometimes called &lt;em&gt;bubble-sort distance&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;While the closely-related Tau correlation coefficient is implemented in Scipy as &lt;a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.kendalltau.html"&gt;&lt;code&gt;scipy.stats.kendalltau&lt;/code&gt;&lt;/a&gt;, let&amp;#8217;s code it ourselves in a simpler&amp;nbsp;way.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In&amp;nbsp;[1]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;print_function&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;combinations&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;permutations&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;kendalltau_dist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rank_a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rank_b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;tau&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;n_candidates&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rank_a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;combinations&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n_candidates&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;tau&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rank_a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;rank_a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt;
                &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rank_b&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;rank_b&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;tau&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Now we can represent a rank as a numpy vector, with missing&amp;nbsp;values.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In&amp;nbsp;[2]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# columns in order of appearance:&lt;/span&gt;
&lt;span class="n"&gt;cols&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Alicia Ginny Gwendolyn Robin Debbie&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;ranks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
                  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Two rankings that agree completely should have a distance of&amp;nbsp;0.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In&amp;nbsp;[3]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;kendalltau_dist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;


&lt;div class="output_area"&gt;&lt;div class="prompt output_prompt"&gt;Out[3]:&lt;/div&gt;


&lt;div class="output_text output_subarea output_execute_result"&gt;
&lt;pre&gt;0&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;The Athletic Wizard seems to be closer to the Daily Prophet than to Seeker&amp;nbsp;Weekly.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In&amp;nbsp;[4]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;d(athletic_wizard, prophet) = &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kendalltau_dist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;d(athletic_wizard, seeker) = &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kendalltau_dist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;


&lt;div class="output_area"&gt;&lt;div class="prompt"&gt;&lt;/div&gt;
&lt;div class="output_subarea output_stream output_stdout output_text"&gt;
&lt;pre&gt;d(athletic_wizard, prophet) = 1
d(athletic_wizard, seeker) = 5
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="Kemeny-Young-rank-aggregation"&gt;Kemeny-Young rank aggregation&lt;a class="anchor-link" href="#Kemeny-Young-rank-aggregation"&gt;&amp;#182;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Now that we have a distance metric, we can formulate a loss function to minimize in rank-space.
We are looking for a ranking $\hat\tau$ that satisfies
$$ \sum_i d(\hat\tau, \tau_i) \leq \sum_i d(\tau, \tau_i) \text{ for all } \tau&amp;nbsp;$$&lt;/p&gt;
&lt;p&gt;This aggregation method was proposed by John Kemeny [&lt;a href="#note1"&gt;1&lt;/a&gt;], and later shown by Peyton Young to be a maximum likelihood estimator of pairwise preferences under the assumption that a voter will randomly flip two candidates from the &lt;em&gt;true&lt;/em&gt; ranking is the same $p &lt; 0.5$ [&lt;a href="#note2"&gt;2&lt;/a&gt;].&lt;/p&gt;
&lt;p&gt;For rankings of small length, one way to compute this optimal aggregation is by comparing the scores of all possible rankings, in other words, a &lt;strong&gt;brute-force&lt;/strong&gt;&amp;nbsp;approach:&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In&amp;nbsp;[5]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rankaggr_brute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;min_dist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inf&lt;/span&gt;
    &lt;span class="n"&gt;best_rank&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
    &lt;span class="n"&gt;n_voters&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n_candidates&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;candidate_rank&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;permutations&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n_candidates&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
        &lt;span class="n"&gt;dist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kendalltau_dist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;candidate_rank&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;min_dist&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;min_dist&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dist&lt;/span&gt;
            &lt;span class="n"&gt;best_rank&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;candidate_rank&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;min_dist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;best_rank&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In&amp;nbsp;[6]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;dist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aggr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rankaggr_brute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;A Kemeny-Young aggregation with score &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; is: &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;dist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;, &amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cols&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aggr&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;


&lt;div class="output_area"&gt;&lt;div class="prompt"&gt;&lt;/div&gt;
&lt;div class="output_subarea output_stream output_stdout output_text"&gt;
&lt;pre&gt;A Kemeny-Young aggregation with score 15 is: Ginny, Robin, Gwendolyn, Debbie, Alicia
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="Integer-Programming-formulation"&gt;Integer Programming formulation&lt;a class="anchor-link" href="#Integer-Programming-formulation"&gt;&amp;#182;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;The brute-force approach is, as you can see, simple to understand and quick to code. However, the number of total ranks of size $n$ is $n!$, so this approach quickly becomes infeasible for real-world problems.  Unfortunately, it turns out that this problem (along with many related problems in rank-world) is &lt;span class="caps"&gt;NP&lt;/span&gt;-hard even for only four voters [&lt;a href="#note3"&gt;3&lt;/a&gt;]. There have been quite a few approaches and approximations. In many cases, such as search results aggregation, approximations are good enough.  For the cases where an exact solution is required, a formulation as a constrained integer program is given in [&lt;a href="#note4"&gt;4&lt;/a&gt;].&lt;/p&gt;
&lt;p&gt;We build a weighted directed graph $G = (V, E)$ with the candidates as vertices.  The edges are defined as such: for every pair of candidates $i, j$, let $\#\{i &gt; j\}$ denote the number of voters who rank $i$ higher than $j$.  Draw an edge $e$ between each $i, j$ with weight $w_e = |\#\{i &gt; j\} - \#\{j &gt; i\}|$ (if nonzero, of course). The orientation of the edge is from the less preferred to the more preferred&amp;nbsp;node.&lt;/p&gt;
&lt;p&gt;The formulation is based on the alternative interpretation of the Kemeny optimal aggregation as the ranking that minimizes the weights of edges it disagrees&amp;nbsp;with:&lt;/p&gt;
$$
\operatorname{minimize} \sum_{e \in E} w_e x_e &amp;#92;
\operatorname{subject to} &amp;#92;
\forall i \neq j \in V, x_{ij} + x_{ji} = 1 &amp;#92;
\forall i \neq j \neq k \neq i \in V, x_{ij} + x_{jk} + x_{ki} \geq 1
$$&lt;p&gt;In the above problem, all variables are integer, and effectively binary under the other constraints.  The interpretation is that $x_{ij} = 1$ if, in the aggregated rank, $i$ is ranked lower than&amp;nbsp;$j$.&lt;/p&gt;
&lt;p&gt;The constraints essentially impose that the variables define a total order. The first set of constraints enforce antisymmetry and totality: either $i$ is ranked lower than $j$ or the other way around. The second set of constraints enforce&amp;nbsp;transitivity.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In&amp;nbsp;[7]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_build_graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;n_voters&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n_candidates&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;
    &lt;span class="n"&gt;edge_weights&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;n_candidates&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n_candidates&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;combinations&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n_candidates&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;preference&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;h_ij&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;preference&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# prefers i to j&lt;/span&gt;
        &lt;span class="n"&gt;h_ji&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;preference&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# prefers j to i&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;h_ij&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;h_ji&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;edge_weights&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h_ij&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;h_ji&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;h_ij&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;h_ji&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;edge_weights&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;h_ji&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;h_ij&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;edge_weights&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_build_graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;


&lt;div class="output_area"&gt;&lt;div class="prompt"&gt;&lt;/div&gt;
&lt;div class="output_subarea output_stream output_stdout output_text"&gt;
&lt;pre&gt;[[ 0.  0.  0.  0.  0.]
 [ 1.  0.  3.  3.  3.]
 [ 1.  0.  0.  0.  3.]
 [ 1.  0.  1.  0.  3.]
 [ 1.  0.  0.  0.  0.]]
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;Now, let&amp;#8217;s solve the linear program with the &lt;span class="caps"&gt;LGPL&lt;/span&gt;-licensed &lt;a href="http://sourceforge.net/projects/lpsolve/"&gt;&lt;code&gt;lpsolve&lt;/code&gt;&lt;/a&gt;. It conveniently comes with a Python&amp;nbsp;interface.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In&amp;nbsp;[8]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;lp_solve&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;lp_solve&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;rankaggr_lp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Kemeny-Young optimal rank aggregation&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="n"&gt;n_voters&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n_candidates&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;
    
    &lt;span class="c1"&gt;# maximize c.T * x&lt;/span&gt;
    &lt;span class="n"&gt;edge_weights&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_build_graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;edge_weights&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ravel&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  

    &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n_candidates&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;

    &lt;span class="c1"&gt;# constraints for every pair&lt;/span&gt;
    &lt;span class="n"&gt;pairwise_constraints&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="n"&gt;n_candidates&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n_candidates&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                     &lt;span class="n"&gt;n_candidates&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pairwise_constraints&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                           &lt;span class="n"&gt;combinations&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n_candidates&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
        &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)]]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

    &lt;span class="c1"&gt;# and for every cycle of length 3&lt;/span&gt;
    &lt;span class="n"&gt;triangle_constraints&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="n"&gt;n_candidates&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n_candidates&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
                                     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n_candidates&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
                                     &lt;span class="n"&gt;n_candidates&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;triangle_constraints&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                              &lt;span class="n"&gt;permutations&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n_candidates&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
        &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)]]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

    &lt;span class="n"&gt;constraints&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vstack&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;pairwise_constraints&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;triangle_constraints&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="n"&gt;constraint_rhs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hstack&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ones&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pairwise_constraints&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
                                &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ones&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;triangle_constraints&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
    &lt;span class="n"&gt;constraint_signs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hstack&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pairwise_constraints&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;  &lt;span class="c1"&gt;# ==&lt;/span&gt;
                                  &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ones&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;triangle_constraints&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;  &lt;span class="c1"&gt;# &amp;gt;=&lt;/span&gt;

    &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;duals&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lp_solve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;constraints&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;constraint_rhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;constraint_signs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                             &lt;span class="n"&gt;xint&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;n_candidates&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reshape&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;n_candidates&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n_candidates&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;aggr_rank&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;axis&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aggr_rank&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In&amp;nbsp;[9]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aggr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rankaggr_lp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;score&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kendalltau_dist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aggr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;A Kemeny-Young aggregation with score &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; is: &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;score&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;, &amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cols&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aggr&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;


&lt;div class="output_area"&gt;&lt;div class="prompt"&gt;&lt;/div&gt;
&lt;div class="output_subarea output_stream output_stdout output_text"&gt;
&lt;pre&gt;A Kemeny-Young aggregation with score 15 is: Ginny, Robin, Gwendolyn, Debbie, Alicia
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;We get the same result as in the brute-force case.  However, it&amp;#8217;s much faster. Let&amp;#8217;s verify this, and in the process, also test that we always get the same&amp;nbsp;result.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In&amp;nbsp;[10]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pandas&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;pd&lt;/span&gt;

&lt;span class="n"&gt;timings&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DataFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;method rank_len n_ranks time&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;seed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;rank_len&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n_ranks&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;ranks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;permutation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rank_len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n_ranks&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="n"&gt;ranks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;t0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;brute_score&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;brute_aggr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rankaggr_brute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;timings&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;timings&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;brute&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                      &lt;span class="n"&gt;rank_len&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rank_len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                      &lt;span class="n"&gt;n_ranks&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n_ranks&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                      &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;t0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                                 &lt;span class="n"&gt;ignore_index&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;t0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lp_aggr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rankaggr_lp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;timings&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;timings&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;lp&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                      &lt;span class="n"&gt;rank_len&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rank_len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                      &lt;span class="n"&gt;n_ranks&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n_ranks&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                      &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;t0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                                 &lt;span class="n"&gt;ignore_index&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;brute_score&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt;
                &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kendalltau_dist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lp_aggr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;rank&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;# lp is much faster, let&amp;#39;s run it for longer rankings.&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;rank_len&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n_ranks&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;t0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lp_aggr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rankaggr_lp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ranks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;timings&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;timings&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;lp&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                      &lt;span class="n"&gt;rank_len&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rank_len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                      &lt;span class="n"&gt;n_ranks&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n_ranks&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                      &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;t0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                                 &lt;span class="n"&gt;ignore_index&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In&amp;nbsp;[11]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="k"&gt;matplotlib&lt;/span&gt; inline
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;plt&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;seaborn&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;sns&lt;/span&gt;

&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;figure&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;figsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xticks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;subplot&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n_ranks&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;brute&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;lp&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;this_rows&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;timings&lt;/span&gt;&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;timings&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;n_ranks&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;n_ranks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;
                            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timings&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
        &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;semilogy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this_rows&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rank_len&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;this_rows&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                     &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; n=&lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n_ranks&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;legend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;upper left&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;suptitle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Ranking size vs. log time to solve&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;


&lt;div class="output_area"&gt;&lt;div class="prompt"&gt;&lt;/div&gt;


&lt;div class="output_png output_subarea "&gt;
&lt;img src="data:image/png;base64,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
"&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;
&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;You can see that the brute force approach is a bit worse than exponential, while the integer programming approach is more reasonable and also is less sensitive to the number of voters being aggregated.  We therefore have a reasonably fast efficient exact solution to the rank aggregation problem on small&amp;nbsp;datasets.&lt;/p&gt;
&lt;h3 id="References"&gt;References&lt;a class="anchor-link" href="#References"&gt;&amp;#182;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;span id="note1"&gt; [1] J Kemeny. [Mathematics without numbers](http://www.jstor.org/stable/10.2307/20026529), 1959 &lt;br /&gt; &lt;/span&gt;
&lt;span id="note2"&gt; [2] &lt;span class="caps"&gt;HP&lt;/span&gt; Young. [Condorcet&amp;#8217;s theory of voting](http://www.jstor.org/stable/10.2307/1961757), 1988 &lt;br /&gt;
&lt;/span&gt;&lt;span id="note3"&gt; 
[3] &lt;span class="caps"&gt;JJ&lt;/span&gt; Bartholdi &lt;span class="caps"&gt;III&lt;/span&gt;, &lt;span class="caps"&gt;CA&lt;/span&gt; Tovey, &lt;span class="caps"&gt;MA&lt;/span&gt; Trick. [The computational difficulty of manipulating an election](http://link.springer.com/article/10.1007/&lt;span class="caps"&gt;BF00295861&lt;/span&gt;), 1989 &lt;br /&gt;
&lt;/span&gt;&lt;span id="note4"&gt; 
[4] V Conitzer, A Davenport, J Kalagnanam. [Improved bounds for computing Kemeny rankings](http://www.aaai.org/Papers/&lt;span class="caps"&gt;AAAI&lt;/span&gt;/2006/&lt;span class="caps"&gt;AAAI06&lt;/span&gt;-099.pdf),&amp;nbsp;2006
&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: 'center'," +
        "    displayIndent: '0em'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['$','$'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
        "    } " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Wed, 22 Jan 2014 18:00:00 +0100</pubDate><guid>tag:vene.ro,2014-01-22:blog/kemeny-young-optimal-rank-aggregation-in-python.html</guid><category>python</category><category>rank aggregation</category><category>kendall</category><category>tau</category><category>kemeny</category><category>kemeny-young</category><category>voting theory</category></item><item><title>Site move</title><link>http://vene.ro/blog/site-move.html</link><description>&lt;p&gt;I finally got around to moving my entire website, including the blog,
to &lt;a href="http://getpelican.com"&gt;Pelican&lt;/a&gt;.  I probably would have gotten away with it
too if it weren&amp;#8217;t for those meddling kids who hacked my friend&amp;#8217;s server and
convinced me that it&amp;#8217;s worth the effort to go&amp;nbsp;static.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;It only took 5 hours!&lt;/strong&gt; I am more and more convinced that static websites
allow for a better streamlined workflow that does wonders for&amp;nbsp;productivity.&lt;/p&gt;
&lt;p&gt;The static part of my old website was made with Jekyll before, so I kept it
almost identical, except for fixing some childish &lt;span class="caps"&gt;CSS&lt;/span&gt; bugs.  The same self-hate
that comes with reading code that you wrote yourself years ago also comes from
markup,&amp;nbsp;apparently.&lt;/p&gt;
&lt;p&gt;The blog, however, was migrated thanks to Pelican&amp;#8217;s Wordpress importer.  This
means that the images are missing, the comments are missing (though I think
they can be imported somehow) and the plugin-specific syntax such as Latex
and source code is poorly rendered.  Luckily the images are there in the
database dump, but I will need to go through the posts one by one to fix
everything.  For now, my priority was to get it up and running and keep as many
of the old links as&amp;nbsp;possible.&lt;/p&gt;
&lt;p&gt;Unfortunately &lt;a href="http://pages.github.com"&gt;GitHub Pages&lt;/a&gt; doesn&amp;#8217;t allow &lt;span class="caps"&gt;URL&lt;/span&gt;
rewriting, but I use &lt;a href="https://cloudflare.com"&gt;CloudFlare&lt;/a&gt; for &lt;span class="caps"&gt;DNS&lt;/span&gt; and their
free plan gives me the right to use three forwarding rules.  With just 3 rules
I couldn&amp;#8217;t save all of the old URLs, so I had to prioritize something.  I
decided to rescue the links pointing directly to articles, which needed two
rules, for links with and without trailing slashes, because the CloudFlare
syntax has no way of specifying optional characters.  I used the third wish
that the genie granted me to simply redirect the subdomain
&lt;code&gt;blog.vene.ro&lt;/code&gt; to the appropriate subfolder,
&lt;code&gt;vene.ro/blog&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Best part about this is that I will now be able to migrate my &lt;a href="/papers.html"&gt;personal list of
papers&lt;/a&gt; to
&lt;a href="https://github.com/vene/pelican-bibtex"&gt;pelican-bibtex&lt;/a&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Fri, 10 Jan 2014 12:00:00 +0100</pubDate><guid>tag:vene.ro,2014-01-10:blog/site-move.html</guid><category>pelican</category><category>blog</category></item><item><title>BibTeX-powered publications list for Pelican with pelican-bibtex</title><link>http://vene.ro/blog/bibtex-powered-publications-list-for-pelican-with-pelican-bibtex.html</link><description>&lt;h2&gt;Hook&lt;/h2&gt;
&lt;p&gt;Wouldn&amp;#8217;t you like to manage your academic publications list easily
within the context of your static website? Without resorting to external
services, or to software like &lt;em&gt;bibtex2html&lt;/em&gt;, which is very nice but will
then require restyling to fit your&amp;nbsp;templates?&lt;/p&gt;
&lt;p&gt;Look no more, with the help of &lt;a href="https://github.com/vene/pelican-bibtex"&gt;pelican-bibtex&lt;/a&gt; you can now manage
your papers from within&amp;nbsp;Pelican!&lt;/p&gt;
&lt;h2&gt;Backstory&lt;/h2&gt;
&lt;p&gt;At &lt;a href="http://fseoane.net"&gt;Fabian&lt;/a&gt;&amp;#8216;s advice, I started playing around with &lt;a href="http://getpelican.com"&gt;Pelican&lt;/a&gt;, a
static website/blog generator for Python. I like it better than the
other generators I used before, so I chose it the next time I had to set
up a website. I still didn&amp;#8217;t make the courage to migrate my current
website and blog to it, but I promise I&amp;nbsp;will.&lt;/p&gt;
&lt;p&gt;Pelican has a public plugins repository, but they have a license
constraint for all contributions. My plugin isn&amp;#8217;t complicated, but I had
to &amp;#8220;reverse engineer&amp;#8221; undocumented parts of the &lt;a href="http://pybtex.sourceforge.net"&gt;pybtex&lt;/a&gt; &lt;span class="caps"&gt;API&lt;/span&gt;. I think
that maybe that code that I used to render citations programatically can
be useful to others, so I don&amp;#8217;t want to release it under a restrictive
license. For this reason, I publish &lt;a href="https://github.com/vene/pelican-bibtex"&gt;pelican-bibtex&lt;/a&gt; in my personal
GitHub&amp;nbsp;account.&lt;/p&gt;
&lt;p&gt;You can see it in action in the &lt;a href="https://github.com/nlp-unibuc/nlp-unibuc-website/"&gt;source code&lt;/a&gt; for the website I am
working on at the moment, the home page of my research group. Example
output generated using pelican-bibtex can be seen &lt;a href="http://nlp-unibuc.github.io/publications.html"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Possible&amp;nbsp;extensions&lt;/h2&gt;
&lt;p&gt;I have not dug in too deeply but I believe this plugin can be extended,
with not much difficulty, to support referencing in Pelican blogs, and
render BibTeX references at the end of every post. This idea was
suggested by Avaris on #pelican, and I find it very cool. Since I don&amp;#8217;t
need this feature at the moment, it&amp;#8217;s not a priority, but it&amp;#8217;s something
that I would like to see at some&amp;nbsp;point.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Mon, 22 Apr 2013 10:45:00 +0200</pubDate><guid>tag:vene.ro,2013-04-22:blog/bibtex-powered-publications-list-for-pelican-with-pelican-bibtex.html</guid><category>bibtex</category><category>blog</category><category>citations</category><category>pelican</category><category>publications</category><category>pybtex</category><category>references</category><category>static blog</category><category>static website</category><category>Uncategorized</category></item><item><title>Really the most common english idioms?</title><link>http://vene.ro/blog/really-most-common-english-idioms.html</link><description>&lt;p&gt;A while back I ran into &lt;a href="http://voxy.com/blog/index.php/2012/02/top-10-most-common-idioms-in-english/"&gt;this blog post&lt;/a&gt; and it made me wonder. I&amp;#8217;m
not a native speaker but the idiomatic phrases that they note as common
don&amp;#8217;t strike me as such. I don&amp;#8217;t think I have ever encountered them very
often in real&amp;nbsp;dialogue.&lt;/p&gt;
&lt;p&gt;The blog post lists the 10 most common idioms in English. &lt;strong&gt;Idioms&lt;/strong&gt;,
also known less ambiguously as &lt;strong&gt;fixed expressions&lt;/strong&gt;, are units of
language that span at least two words. Their meaning, relatively to the
individual meaning of the parts of the phrase, are figurative. Despite
this, fixed expressions don&amp;#8217;t classify as creative language, or
exploitations. By definition most speakers will unequivocally be
familiar with&amp;nbsp;them.&lt;/p&gt;
&lt;p&gt;For example, they cite &lt;em&gt;piece of cake&lt;/em&gt; as the most common idiomatic
expression. This refers to using the phrase to mean that something is
easy, that it isn&amp;#8217;t challenging. An example of literal use, however,
would be when ordering &lt;em&gt;a piece of cake&lt;/em&gt; for desert in a&amp;nbsp;restaurant.&lt;/p&gt;
&lt;p&gt;Everyone knows that language is a perpetually changing thing, so to
begin with it&amp;#8217;s even slightly misleading to discuss of the commonness of
a phrase, without giving more context. The blog post doesn&amp;#8217;t justify the
ranking with any numbers anyway, so let&amp;#8217;s take them one by one and find
out how common they really&amp;nbsp;are!&lt;/p&gt;
&lt;h2&gt;Corpus&amp;nbsp;Linguistics&lt;/h2&gt;
&lt;p&gt;The approach we are taking here is known as corpus linguistics. The best
way to argue that a certain phrase is common, that something is used
with a specific meaning or that some constructions are normal is, under
corpus linguistics, not to make up examples that seem reasonable, but to
look at &lt;strong&gt;representative collections of text&lt;/strong&gt; (corpora) and trying to
find the examples there. The conclusions you get this way are backed by
real-world language&amp;nbsp;use.&lt;/p&gt;
&lt;p&gt;An argument often brought against generative linguistics is that it
focuses on the (hard) border between grammatical and not grammatical,
and the border is usually defined by made-up examples. This is
inappropriate for studying how the norms are exploited in real language
use, for example. I refer the interested to the work of &lt;a href="http://www.patrickhanks.com/"&gt;Patrick
Hanks&lt;/a&gt; [&lt;a href="#f1"&gt;1&lt;/a&gt;, &lt;a href="#f2"&gt;2&lt;/a&gt;].&lt;/p&gt;
&lt;p&gt;Corpus linguistics is sensitive to the corpus used. For this example
let&amp;#8217;s use two British English corpora: the &lt;a href="http://www.natcorp.ox.ac.uk/"&gt;British National Corpus&lt;/a&gt;
and the &lt;a href="http://oxforddictionaries.com/words/the-oxford-english-corpus"&gt;Oxford English Corpus&lt;/a&gt;. Measuring by number of words, the
latter is around 20 times bigger. The strong point of the &lt;span class="caps"&gt;BNC&lt;/span&gt; is the
attention given to the mixing proportions of various domains. The &lt;span class="caps"&gt;OEC&lt;/span&gt;,
on the other hand, is larger and more recent. I have a feeling (but I
cannot strongly affirm) that the differences in the following results
arise from the inclusion in the &lt;span class="caps"&gt;OEC&lt;/span&gt; of blogs dating from the&amp;nbsp;mid-2000s.&lt;/p&gt;
&lt;h2&gt;Cognitive salience vs. social&amp;nbsp;salience&lt;/h2&gt;
&lt;p&gt;One of the key ideas that motivate corpus approaches is the mismatch
between these. The cognitive salience of something is the ease with
which we can recall it. An example often used in language is the fixed
expression &lt;em&gt;kicking the bucket&lt;/em&gt;. It is one of the standard examples of
fixed expressions that people give very often when asked. It is supposed
to mean &lt;em&gt;dying&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;However, big surprise: the &lt;span class="caps"&gt;BNC&lt;/span&gt; has only 18 instances of this phrase, out
of which only 3 are idiomatic, the rest being either literal or
metalinguistic. This is a nice example of the salience contrast, but we
mustn&amp;#8217;t hurry to conclusions. The &lt;span class="caps"&gt;OEC&lt;/span&gt; has 193 examples (still few,
relative to its size) but a lot more of them are idiomatic uses. To save
the time I didn&amp;#8217;t look at all the examples, but took a random sample of
size 18, to compare the relative frequencies to &lt;span class="caps"&gt;BNC&lt;/span&gt;. Here, 15 out of 18
instances are idiomatic and none are meta. Quite a&amp;nbsp;difference!&lt;/p&gt;
&lt;p&gt;This goes to show the importance of context when we draw conclusions
about language use. Now let&amp;#8217;s tackle the list with a similar&amp;nbsp;analysis.&lt;/p&gt;
&lt;h2&gt;The&amp;nbsp;idioms&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Piece of&amp;nbsp;cake&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In &lt;span class="caps"&gt;BNC&lt;/span&gt;, this phrase occurs 51 times. 29 of these occurrences,
however, the meaning is literal. In &lt;span class="caps"&gt;OEC&lt;/span&gt; we find 601 occurrences. In
a random sample of size 51 we find 12 literal&amp;nbsp;uses.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Costing an arm and a&amp;nbsp;leg&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For flexibility we search for the phrase &lt;em&gt;an arm and a leg&lt;/em&gt;. In &lt;span class="caps"&gt;BNC&lt;/span&gt;
it can be found 29 times: one literal, four with the verb &lt;em&gt;to pay&lt;/em&gt;,
and 16 with &lt;em&gt;to cost&lt;/em&gt;. In &lt;span class="caps"&gt;OEC&lt;/span&gt; it appears 228 times. We take, again,
a sample of size 29 and find no literal uses, 16 with &lt;em&gt;to cost&lt;/em&gt;,
four with &lt;em&gt;to pay&lt;/em&gt;, three with &lt;em&gt;to charge&lt;/em&gt; and a few different uses.
The figurative meaning is the same in all cases: a lot of&amp;nbsp;money.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Break a leg&lt;/strong&gt;
    &lt;p&gt;
    &lt;span class="caps"&gt;BNC&lt;/span&gt;: 16, 13 of which are literal. &lt;span class="caps"&gt;OEC&lt;/span&gt;: 70 hits, 10/16&amp;nbsp;literal.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hitting the&amp;nbsp;books&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;BNC&lt;/span&gt;: 1 occurrence of &lt;em&gt;hit the record books&lt;/em&gt;, which has a different
meaning. The idiom is never used. &lt;span class="caps"&gt;OEC&lt;/span&gt;: 135, one of which&amp;nbsp;literal.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Letting the cat out of the&amp;nbsp;bag&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We just looked for cooccurrences of &lt;em&gt;cat&lt;/em&gt; in the context of the
phrase &lt;em&gt;out of the bag&lt;/em&gt;.&lt;br /&gt;
&lt;span class="caps"&gt;BNC&lt;/span&gt;: 19, out of which 3 metalinguistic/literal. &lt;span class="caps"&gt;OEC&lt;/span&gt;: 298, and out
of a sample of 19, all were&amp;nbsp;idiomatic.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hitting the nail on the&amp;nbsp;head&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;BNC&lt;/span&gt;: 12 instances, all idiomatic. &lt;span class="caps"&gt;OEC&lt;/span&gt;: 484, and out of a sample of
12 all were&amp;nbsp;idiomatic.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;When pigs fly&lt;/strong&gt;
    &lt;p&gt;
    We looked for the lemma &lt;em&gt;fly&lt;/em&gt; before the word &lt;em&gt;pigs&lt;/em&gt; therefore
    catching multiple variations.&lt;br /&gt;
    &lt;span class="caps"&gt;BNC&lt;/span&gt;: 17 hits, &lt;span class="caps"&gt;OEC&lt;/span&gt;:&amp;nbsp;240.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Judging a book by its&amp;nbsp;cover&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We looked for the fixed phrase &lt;em&gt;book by its cover&lt;/em&gt;, because the
leading verb might vary.&lt;br /&gt;
In the &lt;span class="caps"&gt;BNC&lt;/span&gt;, 11 instances (1 of them with tell instead of judge). In
&lt;span class="caps"&gt;OEC&lt;/span&gt;, 195 instances. Sampling 11, all were&amp;nbsp;idiomatic.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Biting off more than one can&amp;nbsp;chew&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;BNC&lt;/span&gt;: 16 occurences, one of which with &amp;#8220;to take&amp;#8221; instead of &amp;#8220;to
bite&amp;#8221;. &lt;span class="caps"&gt;OEC&lt;/span&gt;: 231, all idiomatic after sampling&amp;nbsp;16.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Scratching one&amp;#8217;s&amp;nbsp;back&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;BNC&lt;/span&gt;: 23, out of which only 5 idiomatic. &lt;span class="caps"&gt;OEC&lt;/span&gt;: 756, 5/23&amp;nbsp;idiomatic.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Recalculating the&amp;nbsp;rank&lt;/h2&gt;
&lt;p&gt;
We now have enough data to reorder the expressions and compare. The
result will be more approximate for the &lt;span class="caps"&gt;OEC&lt;/span&gt; because of our use of small
subsamples to estimate the frequencies, but hopefully it will still be
interesting. The way we are estimating the counts for the &lt;span class="caps"&gt;OEC&lt;/span&gt; is as
follows: take, for instance, *break a leg*. It was found 70 times, and
out of a sample of 16, 10 were literal. The expected number of idiomatic
uses is therefore:

&lt;center&gt;
[latex]n = &amp;#92;left ( 1 - &amp;#92;frac{10}{16} &amp;#92;right ) &amp;#92;cdot 70 =
26.25[/latex]

&lt;/center&gt;

Repeating this computation and skipping a ton of steps leads to the
following&amp;nbsp;rankings:

&lt;/p&gt;

&lt;div style="float: left; margin-left: 5em;"&gt;
**In the British National&amp;nbsp;Corpus:**

&lt;/p&gt;
1.  Costing an arm and a leg
2.  Piece of cake
3.  When pigs fly
4.  Letting the cat out of the bag
5.  Biting off more than one can chew
6.  Hitting the nail on the head
7.  Judging a book by its cover
8.  Scratching one’s back
9.  Break a leg
10. Hitting the books

&lt;/div&gt;

&lt;div style="float: right; margin-right: 5em;"&gt;
**In the Oxford English&amp;nbsp;Corpus:**

&lt;/p&gt;
1.  Hitting the nail on the head
2.  Piece of cake
3.  Letting the cat out of the bag
4.  When pigs fly
5.  Biting off more than one can chew
6.  Costing an arm and a leg
7.  Judging a book by its cover
8.  Scratching one’s back
9.  Hitting the books
10. Break a leg

&lt;/div&gt;

&lt;p&gt;We can see that apart from the apparent switching of &lt;em&gt;hitting the nail
on the head&lt;/em&gt; with &lt;em&gt;costing an arm and a leg&lt;/em&gt;, the rankings are not too
different. We can quantify this by using the &lt;strong&gt;Rank Distance&lt;/strong&gt;, a metric
introduced by Liviu P. Dinu [&lt;a href="#f3"&gt;3&lt;/a&gt;, &lt;a href="#f4"&gt;4&lt;/a&gt;]. Here, all our 3 rankings are
over the same domain: we are not looking for the most frequent idioms in
the corpora, this would be very hard. We are just reordering the
proposed rank according to the occurrences in &lt;span class="caps"&gt;BNC&lt;/span&gt; and &lt;span class="caps"&gt;OEC&lt;/span&gt;. In this
simple case, Rank Distance reduces to [latex]\ell_1[/latex] distance
over rank position vectors. The weighted Rank Distance, bounded on
[latex][0, 1][/latex] is in this case given by a scaling factor of
[latex]0.5k\^2[/latex] where &lt;em&gt;k&lt;/em&gt; is the length of the rankings (10 in
our&amp;nbsp;case).&lt;/p&gt;
&lt;p&gt;The computed distance between the original ranking and the &lt;span class="caps"&gt;BNC&lt;/span&gt;
reordering is 0.52. Between the original and the &lt;span class="caps"&gt;OEC&lt;/span&gt; reordering, it is
0.68. Our two reorderings are much closer: the distance is 0.28. This is
mostly because that the permutations between the two reorderings affect
the top position, and are therefore weighted&amp;nbsp;more.&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s also interesting to look at the ratio of the counts. Interestingly,
they approximately differ by a constant factor not far from the relative
size difference of the two corpora, as would be&amp;nbsp;expected.&lt;/p&gt;
&lt;p&gt;We have to throw away &lt;em&gt;hitting the books&lt;/em&gt; because its &lt;span class="caps"&gt;BNC&lt;/span&gt; zero count
leads to divisions by zero. After this step, the average of the relative
counts of the idioms is 19.5, with a standard deviation of 10.1, while
&lt;span class="caps"&gt;OED&lt;/span&gt; is supposed to have around 20 times more words than the &lt;span class="caps"&gt;BNC&lt;/span&gt;.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;Well, it seems people don&amp;#8217;t say &lt;em&gt;break a leg&lt;/em&gt; and &lt;em&gt;let&amp;#8217;s hit the books&lt;/em&gt;
as often as the original author claims. The popularity of most of the
cited idioms seems supported by the data, but we have no easy way to
find other idioms that might turn out to be much more frequent. Corpus
linguistics is a reliable way to measure the social salience of language
patterns It should always be used to verify and back empty claims of the
form &lt;em&gt;X is correct&lt;/em&gt;, &lt;em&gt;Y is frequent&lt;/em&gt; or &lt;em&gt;Nobody says Z&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;[&lt;span id="f1"&gt;1&lt;/span&gt;] Patrick Hanks, &lt;a href="http://www.patrickhanks.com/uploads/5/1/4/9/5149363/howpeopleusewordstomakemeanings.pdf"&gt;How people use words to make
meanings&lt;/a&gt;.&lt;br /&gt;
[&lt;span id="f2"&gt;2&lt;/span&gt;] Patrick Hanks, &lt;a href="http://www.amazon.com/Lexical-Analysis-Exploitations-Patrick-Hanks/dp/0262018578"&gt;Lexical Analysis: Norms and
Exploitations&lt;/a&gt;. The &lt;span class="caps"&gt;MIT&lt;/span&gt; Press (January 25, 2013)&lt;br /&gt;
[&lt;span id="f3"&gt;3&lt;/span&gt;] Liviu P. Dinu, Florin Manea. &lt;a href="http://dl.acm.org/citation.cfm?id=1167105"&gt;An efficient
approach for the rank aggregation problem&lt;/a&gt;. In: Theoretical Computer
Science, Volume 359 Issue 1, 14 August 2006. Pages 455 - 461.&lt;br /&gt;
[&lt;span id="f4"&gt;4&lt;/span&gt;] Liviu P. Dinu, [On the Classification and
Aggregation of Hierarchies with Different Constitutive Elements][].
Fundam. Inform. 55(1): 39-50&amp;nbsp;(2003)&lt;/p&gt;
&lt;p&gt;[On the Classification and Aggregation of Hierarchies with Different
  Constitutive Elements]:&amp;nbsp;http://dl.acm.org/citation.cfm?id=937465&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Mon, 11 Feb 2013 16:50:00 +0100</pubDate><guid>tag:vene.ro,2013-02-11:blog/really-most-common-english-idioms.html</guid><category>bnc</category><category>british national corpus</category><category>corpus</category><category>fixed expression</category><category>fixed phrase</category><category>idioms</category><category>oec</category><category>oxford english corpus</category><category>corpus linguistics</category><category>nlp</category></item><item><title>Scikit-learn-speed: An overview on the final day</title><link>http://vene.ro/blog/scikit-learn-speed-an-overview-on-the-final-day.html</link><description>&lt;p&gt;This summer, I was granted the project called &lt;em&gt;scikit-learn-speed&lt;/em&gt;,
consisting of developing a benchmarking platform for &lt;em&gt;scikit-learn&lt;/em&gt; and
using it to find potential speedups, and in the end, make the library go
faster wherever I&amp;nbsp;can.&lt;/p&gt;
&lt;p&gt;On the official closing day of this work, I&amp;#8217;d like to take a moment and
recall the accomplishments and failures of this project, and all the
lessons to be&amp;nbsp;learned.&lt;/p&gt;
&lt;h2&gt;The &lt;em&gt;scikit-learn-speed&lt;/em&gt; benchmark&amp;nbsp;platform&lt;/h2&gt;
&lt;p&gt;[&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2012/08/skl-speed-300x163.png" title="skl-speed" /&gt;][]&lt;br /&gt;
[&lt;em&gt;Scikit-learn-speed&lt;/em&gt;][&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2012/08/skl-speed-300x163.png" title="skl-speed" /&gt;] is a continuous benchmark suite for the
&lt;a href="http://scikit-learn.org"&gt;&lt;em&gt;scikit-learn&lt;/em&gt;&lt;/a&gt; library. It has the following&amp;nbsp;features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;vbench&lt;/em&gt;-powered integration with&amp;nbsp;Git&lt;/li&gt;
&lt;li&gt;Easily triggered build and report generation: just type &lt;code&gt;make&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Easily readable and writeable template for benchmarks:
    &lt;p&gt;
    [sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
    {&lt;br /&gt;
    &amp;#8216;obj&amp;#8217;: &amp;#8216;LogisticRegression&amp;#8217;,&lt;br /&gt;
    &amp;#8216;init_params&amp;#8217;: {&amp;#8216;C&amp;#8217;: 1e5},&lt;br /&gt;
    &amp;#8216;datasets&amp;#8217;: (&amp;#8216;arcene&amp;#8217;, &amp;#8216;madelon&amp;#8217;),&lt;br /&gt;
    &amp;#8216;statements&amp;#8217;: (&amp;#8216;fit&amp;#8217;, &amp;#8216;predict&amp;#8217;)&lt;br /&gt;
    }, &amp;#8230;&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/li&gt;
&lt;li&gt;Many attributes recorded: time (w/ estimated standard deviation),
    memory usage, cProfiler output, line_profiler output,&amp;nbsp;tracebacks&lt;/li&gt;
&lt;li&gt;Multi-step benchmarks: i.e. &lt;code&gt;fit&lt;/code&gt; followed by &lt;code&gt;predict&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What were the lessons I learned&amp;nbsp;here?&lt;/p&gt;
&lt;h3&gt;Make your work reusable: the trade-off between good design and&amp;nbsp;get-it-working-now&lt;/h3&gt;
&lt;p&gt;For the task of rolling out a continuous benchmarking platform, we
decided pretty early in the project to adopt Wes McKinney&amp;#8217;s &lt;em&gt;vbench&lt;/em&gt;. If
my goal would&amp;#8217;ve been to maintain &lt;em&gt;vbench&lt;/em&gt; and extend it into a
multi-purpose, reusable benchmarking framework, the work would&amp;#8217;ve been
structured differently. It also would have been very open-ended and
difficult to&amp;nbsp;quantify.&lt;/p&gt;
&lt;p&gt;The way things have been, I came up with features that we need in
&lt;em&gt;scikit-learn-speed&lt;/em&gt;, and tried to implement them in &lt;em&gt;vbench&lt;/em&gt; without
refactoring too much, but still by trying to make them as reusable as&amp;nbsp;possible.&lt;/p&gt;
&lt;p&gt;The result? I got all the features for &lt;em&gt;scikit-learn-speed&lt;/em&gt;, but the
implementation is not yet clean enough to be merged into &lt;em&gt;vbench&lt;/em&gt;. This
is fine for a project with a tight deadline such as this one: after it&amp;#8217;s
done, I will just spend another weekend on cleaning the work up and
making sure it&amp;#8217;s appreciated upstream. This will be easier because of
the constraint to keep compatibility with &lt;em&gt;scikit-learn-speed&lt;/em&gt;.&lt;/p&gt;
&lt;h3&gt;Never work quietly (unless you&amp;#8217;re a&amp;nbsp;ninja)&lt;/h3&gt;
&lt;p&gt;I know some students who prefer that the professor doesn&amp;#8217;t even know
they exist until the final, when they would score an A, and (supposedly)
leave the professor amazed. In real life, plenty of people would be
interested in what you are doing, as long as they know about it. The &lt;span class="caps"&gt;PSF&lt;/span&gt;
goes a long way to help this, with the &amp;#8220;blog weekly&amp;#8221; rule. In the end,
however, it&amp;#8217;s all up to you to make sure that everybody who should know
finds out about your work. It will spare the world the duplicated work,
the abandoned projects, but most importantly, those people could point
you to things you have missed. Try to mingle in real-life as well,
attend conferences, meetups, coding&amp;nbsp;sprints.&lt;/p&gt;
&lt;p&gt;I was able to slightly &amp;#8220;join forces&amp;#8221; with a couple of people who
contacted me about my new &lt;em&gt;vbench&lt;/em&gt; features (Hi Jon and Joel!), I have
shaped my design slightly towards their requirements as well, and
hopefully the result will be a more general &lt;em&gt;vbench&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;The&amp;nbsp;speedups&lt;/h2&gt;
&lt;p&gt;Once &lt;em&gt;scikit-learn-speed&lt;/em&gt; was up and running, I couldn&amp;#8217;t believe how
useful it is to be able to scroll, catch slow code and jump straight at
the profiler output with one click. I jumped on the following&amp;nbsp;speed-ups:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Multiple outputs in linear models. (&lt;a href="https://github.com/scikit-learn/scikit-learn/pull/913"&gt;&lt;span class="caps"&gt;PR&lt;/span&gt;&lt;/a&gt;)
    &lt;p&gt;
    Some of them proved trickier than expected, so I didn&amp;#8217;t implement it
    for all the module yet, but it is ready for some&amp;nbsp;estimators.&lt;/li&gt;
&lt;li&gt;Less callable functions passed around in &lt;code&gt;FastICA&lt;/code&gt; (&lt;a href="https://github.com/scikit-learn/scikit-learn/pull/927"&gt;merged&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Speed up &lt;code&gt;euclidean_distances&lt;/code&gt; by rewriting in Cython. (&lt;a href="https://github.com/scikit-learn/scikit-learn/pull/1006"&gt;&lt;span class="caps"&gt;PR&lt;/span&gt;&lt;/a&gt;)
    &lt;p&gt;
    This meant making more operations support an &lt;code&gt;out&lt;/code&gt; argument, for
    passing preallocated memory. This touches many&lt;br /&gt;
    different objects in the codebase: clustering, manifold learning,
    nearest neighbour&amp;nbsp;methods.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://localhost:8001/2012/08/18/inverses-pseudoinverses-numerical-issues-speed-symmetry/" title="Inverses and pseudoinverses. Numerical issues, speed, symmetry."&gt;Insight into inverse and pseudoinverse computation&lt;/a&gt;, new &lt;code&gt;pinvh&lt;/code&gt;
    function for inverting symmetric/hermitian matrices. (&lt;a href="https://github.com/scikit-learn/scikit-learn/pull/1015"&gt;&lt;span class="caps"&gt;PR&lt;/span&gt;&lt;/a&gt;)
    &lt;p&gt;
    This speeds up the covariance module (especially &lt;code&gt;MinCovDet&lt;/code&gt;),
    &lt;code&gt;ARDRegression&lt;/code&gt; and the mixture models. It also lead to an [upstream
    contribution to&amp;nbsp;Scipy][]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OrthogonalMatchingPursuit&lt;/code&gt; forward stepwise path for
    cross-validation (&lt;a href="https://github.com/scikit-learn/scikit-learn/pull/1042"&gt;&lt;span class="caps"&gt;PR&lt;/span&gt;&lt;/a&gt;)
    &lt;p&gt;
    This is only halfway finished, but it will lead to faster and easier
    optimization of the &lt;code&gt;OMP&lt;/code&gt; sparsity&amp;nbsp;parameter.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lessons? These will be pretty&amp;nbsp;obvious.&lt;/p&gt;
&lt;h3&gt;Write tests, tests,&amp;nbsp;tests!&lt;/h3&gt;
&lt;p&gt;This is a no-brainer, but it still didn&amp;#8217;t stick. In that one case out of
10 that I didn&amp;#8217;t explicitly test, a bug was obviously hiding. When you
want to add a new feature, it&amp;#8217;s best to start by writing a failing test,
and then &lt;a href="http://c2.com/cgi/wiki?MakeItWorkMakeItRightMakeItFast"&gt;making it pass&lt;/a&gt;. Sure, you will miss tricky bugs, but you
will never have embarrassing, obvious bugs in your code&amp;nbsp;:)&lt;/p&gt;
&lt;h3&gt;Optimization doesn&amp;#8217;t have to be&amp;nbsp;ugly&lt;/h3&gt;
&lt;p&gt;Developers often shun optimization. It&amp;#8217;s true, you should profile first,
and you shouldn&amp;#8217;t focus on speeding up stuff that is dominated by other
computations that are orders of magnitude slower. However, there is an
elephant in the room: the assumption that making code faster invariably
makes it less clear, and takes a lot of&amp;nbsp;effort.&lt;/p&gt;
&lt;p&gt;The following code is a part of scipy&amp;#8217;s &lt;code&gt;pinv2&lt;/code&gt; function as it currently
is written:&lt;br /&gt;
[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
cutoff = cond*np.maximum.reduce(s)&lt;br /&gt;
psigma = np.zeros((m, n), t)&lt;br /&gt;
for i in range(len(s)):&lt;br /&gt;
if s[i] &gt; cutoff:&lt;br /&gt;
psigma[i,i] = 1.0/np.conjugate(s[i])&lt;br /&gt;
return np.transpose(np.conjugate(np.dot(np.dot(u,psigma),vh)))&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;psigma&lt;/code&gt; is a diagonal matrix, and some time and memory can be saved
with simple vectorization. However, this part of the code dominated by
an above call to &lt;code&gt;svd&lt;/code&gt;. The profiler output would say that we shouldn&amp;#8217;t
bother, but is it really a bother? Look at Jake&amp;#8217;s new&amp;nbsp;version:&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
above_cutoff = (s &gt; cond * np.max(s))&lt;br /&gt;
psigma_diag = np.zeros_like(s)&lt;br /&gt;
psigma_diag[above_cutoff] = 1.0 /&amp;nbsp;s[above_cutoff]&lt;/p&gt;
&lt;p&gt;return np.transpose(np.conjugate(np.dot(u * psigma_diag, vh)))&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s shorter, more elegant, easier to read, and nevertheless faster. I
would say it is worth&amp;nbsp;it.&lt;/p&gt;
&lt;h3&gt;Small speed-ups can&amp;nbsp;propagate&lt;/h3&gt;
&lt;p&gt;Sure, it&amp;#8217;s great if you can compute an inverse two times faster, say in
0.5s instead of 1s. But if some algorithm calls this function in a loop
that might iterate 100, 300, or 1000 times, this small speed-up seems
much more important, doesn&amp;#8217;t&amp;nbsp;it?&lt;/p&gt;
&lt;p&gt;What I&amp;#8217;m trying to say with this is that in a well-engineered system, a
performance improvement to a relatively small component (such as the
function that computes a pseudoinverse) can lead to multiple spread out
improvements. Be careful of the double edge of this sword, a bug
introduced in a small part can cause multiple failures downstream. But
you &lt;em&gt;are&lt;/em&gt; fully covered by your test suite, aren&amp;#8217;t&amp;nbsp;you?&lt;/p&gt;
&lt;p&gt;Overall it has been a fruitful project that may have not resulted in a
large number of speed-ups, but a few considerable ones nonetheless. And
I venture the claim that the &lt;em&gt;scikit-learn-speed&lt;/em&gt; tool will prove useful
over time, and that the efforts deployed during this project have
stretched beyond the boundary of the &lt;em&gt;scikit-learn&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;[&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2012/08/skl-speed-300x163.png" title="skl-speed" /&gt;]:&amp;nbsp;http://jenkins-scikit-learn.github.com/scikit-learn-speed/&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Mon, 20 Aug 2012 02:44:00 +0200</pubDate><guid>tag:vene.ro,2012-08-20:blog/scikit-learn-speed-an-overview-on-the-final-day.html</guid><category>gsoc</category><category>optimization</category><category>scikit-learn-speed</category><category>speedup</category><category>summary</category><category>vbench</category><category>benchmarking</category><category>python</category><category>scikit-learn</category></item><item><title>Inverses and pseudoinverses. Numerical issues, speed, symmetry.</title><link>http://vene.ro/blog/inverses-pseudoinverses-numerical-issues-speed-symmetry.html</link><description>&lt;p&gt;The matrix inverse is a cornerstone of linear algebra, taught, along
with its applications, since high school. The inverse of a matrix
\$latex A\$, if it exists, is the matrix \$latex A\^{-1}\$ such that
\$latex &lt;span class="caps"&gt;AA&lt;/span&gt;\^{-1} = A\^{-1}A = I_n\$. Based on the requirement that the
left and right multiplications should be equal, it follows that it only
makes sense to speak of inverting square matrices. But just the square
shape is not enough: for a matrix \$latex A\$ to have an inverse,
\$latex A\$ must be full&amp;nbsp;rank.&lt;/p&gt;
&lt;p&gt;The inverse provides an elegant (on paper) method of finding solutions
to systems of \$latex n\$ equations with \$latex n\$ unknowns, which
correspond to solving \$latex Ax = b\$ for \$latex x\$. If we&amp;#8217;re lucky
and \$latex A\^{-1}\$ exists, then we can find \$latex x = A\^{-1}b\$.
For this to work, it must be the case&amp;nbsp;that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We have exactly as many unknowns as&amp;nbsp;equations&lt;/li&gt;
&lt;li&gt;No equation is redundant, i.e. can be expressed as a linear
    combination of the&amp;nbsp;others&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this setting, there is a unique solution for \$latex&amp;nbsp;x\$.&lt;/p&gt;
&lt;h2&gt;The Moore-Penrose&amp;nbsp;pseudoinverse&lt;/h2&gt;
&lt;p&gt;What if we have more equations than unknowns? It is most likely the case
that we cannot satisfy all the equations perfectly, so let&amp;#8217;s settle for
a solution that best fits the constraints, in the sense of minimising
the sum of squared errors. We solve \$latex \operatorname{arg\,min}_x
||b -&amp;nbsp;Ax||\$.&lt;/p&gt;
&lt;p&gt;And how about the other extreme, where we have a lot of unknowns, but
just a few equations constraining them. We will probably have an
infinity of solutions, how can we choose one? A popular choice is to
take the one of least \$latex \ell_2\$ norm: \$latex
\operatorname{arg\,min}_x ||x|| \operatorname{s.t.} Ax = b\$. Is
there a way to generalize the idea of a matrix inverse for this&amp;nbsp;setting?&lt;/p&gt;
&lt;p&gt;The pseudoinverse of an arbitrary-shaped matrix \$latex A\$, written
\$latex A\^{+}\$, has the same shape as \$latex A\^{T}\$ and solves our
problem: the answer to both optimization methods above is given by
\$latex x =&amp;nbsp;A\^{+}y\$.&lt;/p&gt;
&lt;p&gt;The theoretical definition of the pseudoinverse is given by the
following conditions. The intuitive way to read them is as properties of
\$latex &lt;span class="caps"&gt;AA&lt;/span&gt;\^+\$ or \$latex&amp;nbsp;A\^+A\$:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\$latex &lt;span class="caps"&gt;AA&lt;/span&gt;\^+A =&amp;nbsp;A\$&lt;/li&gt;
&lt;li&gt;\$latex A\^+&lt;span class="caps"&gt;AA&lt;/span&gt;\^+ =&amp;nbsp;A\^+\$&lt;/li&gt;
&lt;li&gt;\$latex (&lt;span class="caps"&gt;AA&lt;/span&gt;\^+)\^T = &lt;span class="caps"&gt;AA&lt;/span&gt;\^+\$&lt;/li&gt;
&lt;li&gt;\$latex (A\^+A)\^T =&amp;nbsp;A\^+A\$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These conditions do not however give us a way to get our hands on a
pseudoinverse, so we need something&amp;nbsp;else.&lt;/p&gt;
&lt;h2&gt;How to compute the pseudoinverse on&amp;nbsp;paper&lt;/h2&gt;
&lt;p&gt;The first time I ran into the pseudoinverse, I didn&amp;#8217;t even know its
definition, only the expression of the closed-form solution of such a
problem, and given&amp;nbsp;as:&lt;/p&gt;
&lt;p&gt;\$latex A\^+ = (A\^T&amp;nbsp;A)\^{-1}A\^T\$&lt;/p&gt;
&lt;p&gt;What can we see from this&amp;nbsp;expression:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It gives us a way to compute the pseudoinverse, and hence to solve
    the&amp;nbsp;problem&lt;/li&gt;
&lt;li&gt;If \$latex A\$ is actually invertible, it means \$latex A\^T\$ is
    invertible, so we have \$latex A\^+ = A\^{-1}(A\^T)\^{-1}A\^T =&amp;nbsp;A\^{-1}\$&lt;/li&gt;
&lt;li&gt;Something bad happens if \$latex A\^&lt;span class="caps"&gt;TA&lt;/span&gt;\$ is not&amp;nbsp;invertible.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The pseudoinverse is still defined, and unique, when \$latex A\^&lt;span class="caps"&gt;TA&lt;/span&gt;\$ is
not invertible, but we cannot use the expression above to compute&amp;nbsp;it.&lt;/p&gt;
&lt;h2&gt;Numerical&amp;nbsp;issues&lt;/h2&gt;
&lt;p&gt;Before going on, we should clarify and demystify some of the urban
legends about numerical computation of least squares problems. You might
have heard the following unwritten&amp;nbsp;rules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Never compute \$latex A\^{-1}\$, solve the system&amp;nbsp;directly&lt;/li&gt;
&lt;li&gt;If you really need \$latex A\^{-1}\$, use &lt;code&gt;pinv&lt;/code&gt; and not &lt;code&gt;inv&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first of these rules is based on some misguided beliefs, but is
still good advice. If your goal is a one-shot answer to a system,
there&amp;#8217;s no use in explicitly computing a possibly large inverse, when
all you need is \$latex x\$. But &lt;a href="http://arxiv.org/abs/1201.6035"&gt;this paper&lt;/a&gt; shows that computing the
inverse is not necessarily a bad thing. The key to this is conditional
accuracy, and as long as the &lt;code&gt;inv&lt;/code&gt; function used has good conditional
bounds, you will get as good results as with a least squares&amp;nbsp;solver.&lt;/p&gt;
&lt;p&gt;The second rule comes from numerical stability, and will definitely bite
you if misunderstood. If \$latex A\$ is a square matrix with a row full
of zeros, it&amp;#8217;s clearly not invertible, so an algorithm attempting to
compute the inverse will fail and you will be able to catch that
failure. But what if the row is not exactly zero, but the sum of several
other rows, and a slight loss of precision is propagated at every&amp;nbsp;step?&lt;/p&gt;
&lt;h2&gt;Numerical rank vs. actual&amp;nbsp;rank&lt;/h2&gt;
&lt;p&gt;The rank of a matrix \$latex A\$ is defined as the number of linearly
independent rows (or equivalently, columns) in \$latex A\$. In other
words, the number of non-redundant equations in the system. We&amp;#8217;ve seen
before that if the rank is less than the total number of rows, the
system cannot have a unique solution anymore, so the matrix \$latex A\$
is not&amp;nbsp;invertible.&lt;/p&gt;
&lt;p&gt;The rank of a matrix is a computationally tricky problem. On paper, with
small matrices, you would look at minors of decreasing size, until you
find the first non-zero one. This is unfeasible to implement on a
computer, so numerical analysis has a different approach. Enter the
singular value&amp;nbsp;decomposition!&lt;/p&gt;
&lt;p&gt;The &lt;span class="caps"&gt;SVD&lt;/span&gt; of a matrix \$latex A\$ is \$latex A = &lt;span class="caps"&gt;USV&lt;/span&gt;\^{T}\$, where \$latex
S\$ is diagonal and \$latex U, V\$ are orthogonal. The elements on the
diagonal of \$latex S\$ are called the singular values of \$latex A\$.
It can be seen that to get a row full of zeros when multiplying three
such matrices, a singular value needs to be exactly&amp;nbsp;zero.&lt;/p&gt;
&lt;p&gt;The ugly thing that could happen is that one (or usually more) singular
values are not exactly zero, but very low values, due to propagated
imprecision. Why is this a problem? By looking at the &lt;span class="caps"&gt;SVD&lt;/span&gt; and noting its
properties, it becomes clear that \$latex A\^{-1} = &lt;span class="caps"&gt;VS&lt;/span&gt;\^{-1}U\^{T}\$ and
since \$latex S\$ is diagonal, its inverse is formed by taking the
inverse of all the elements on the diagonal. But if a singular value is
very small but not quite zero, its inverse is very large and it will
blow up the whole computation of the inverse. The right thing to do here
is either to tell the user that \$latex A\$ is numerically rank
deficient, or to return a pseudoinverse instead. A pseudoinverse would
mean: give up on trying to get \$latex &lt;span class="caps"&gt;AA&lt;/span&gt;\^+\$ to be the identity
matrix, simply aim for a diagonal matrix with approximately ones and
zeroes. In other words, when singular values are very low, set them to&amp;nbsp;0.&lt;/p&gt;
&lt;p&gt;How do you set the threshold? This is actually a delicate issue, being
discussed on &lt;a href="http://thread.gmane.org/gmane.comp.python.numeric.general/50396/focus=50912"&gt;the numeric Python mailing list&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Scipy&amp;nbsp;implementations&lt;/h2&gt;
&lt;p&gt;Scipy exposes &lt;code&gt;inv&lt;/code&gt;, &lt;code&gt;pinv&lt;/code&gt; and &lt;code&gt;pinv2&lt;/code&gt;. &lt;code&gt;inv&lt;/code&gt; secretly invokes &lt;span class="caps"&gt;LAPACK&lt;/span&gt;,
that ancient but crazy robust code that&amp;#8217;s been used since the 70s, to
first compute a pivoted &lt;span class="caps"&gt;LU&lt;/span&gt; decomposition that is then used to compute
the inverse. &lt;code&gt;pinv&lt;/code&gt; also uses &lt;span class="caps"&gt;LAPACK&lt;/span&gt;, but for computing the
least-squares solution to the system \$latex &lt;span class="caps"&gt;AX&lt;/span&gt; = I\$. &lt;code&gt;pinv2&lt;/code&gt; computes
the &lt;span class="caps"&gt;SVD&lt;/span&gt; and transposes everything like shown above. Both &lt;code&gt;pinv&lt;/code&gt; and
&lt;code&gt;pinv2&lt;/code&gt; expose &lt;code&gt;cond&lt;/code&gt; and &lt;code&gt;rcond&lt;/code&gt; arguments to handle the treatment of
very small singular values, but (&lt;em&gt;attention!&lt;/em&gt;) they behave&amp;nbsp;differently!&lt;/p&gt;
&lt;p&gt;The different implementations also lead to different speed. Let&amp;#8217;s look
at inverting a random square&amp;nbsp;matrix:&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [1]: import numpy as&amp;nbsp;np&lt;/p&gt;
&lt;p&gt;In [2]: from scipy import&amp;nbsp;linalg&lt;/p&gt;
&lt;p&gt;In [3]: a = np.random.randn(1000,&amp;nbsp;1000)&lt;/p&gt;
&lt;p&gt;In [4]: timeit linalg.inv(a)&lt;br /&gt;
10 loops, best of 3: 132 ms per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [5]: timeit linalg.pinv(a)&lt;br /&gt;
1 loops, best of 3: 18.8 s per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [6]: timeit linalg.pinv2(a)&lt;br /&gt;
1 loops, best of 3: 1.58 s per loop&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Woah, huge difference! But do all three methods return the &amp;#8220;right&amp;#8221;&amp;nbsp;result?&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [7]: linalg.inv(a)[:3, :3]&lt;br /&gt;
Out[7]:&lt;br /&gt;
array([[ 0.03636918, 0.01641725, 0.00736503],&lt;br /&gt;
[-0.04575771, 0.03578062, 0.02937733],&lt;br /&gt;
[ 0.00542367, 0.01246306, 0.0122156&amp;nbsp;]])&lt;/p&gt;
&lt;p&gt;In [8]: linalg.pinv(a)[:3, :3]&lt;br /&gt;
Out[8]:&lt;br /&gt;
array([[ 0.03636918, 0.01641725, 0.00736503],&lt;br /&gt;
[-0.04575771, 0.03578062, 0.02937733],&lt;br /&gt;
[ 0.00542367, 0.01246306, 0.0122156&amp;nbsp;]])&lt;/p&gt;
&lt;p&gt;In [9]: linalg.pinv2(a)[:3, :3]&lt;br /&gt;
Out[9]:&lt;br /&gt;
array([[ 0.03636918, 0.01641725, 0.00736503],&lt;br /&gt;
[-0.04575771, 0.03578062, 0.02937733],&lt;br /&gt;
[ 0.00542367, 0.01246306, 0.0122156&amp;nbsp;]])&lt;/p&gt;
&lt;p&gt;In [10]: np.testing.assert_array_almost_equal(linalg.inv(a),&amp;nbsp;linalg.pinv(a))&lt;/p&gt;
&lt;p&gt;In [11]: np.testing.assert_array_almost_equal(linalg.inv(a),
linalg.pinv2(a))&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Looks good! This is because we got lucky, though, and &lt;code&gt;a&lt;/code&gt; was invertible
to start with. Let&amp;#8217;s look at its&amp;nbsp;spectrum:&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [12]: _, s, _ =&amp;nbsp;linalg.svd(a)&lt;/p&gt;
&lt;p&gt;In [13]: np.min(s), np.max(s)&lt;br /&gt;
Out[13]: (0.029850235603382822, 62.949785645178906)&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;This is a lovely range for the singular values of a matrix, not too
small, not too large. But what if we built the matrix in a way that
would always pose problems? Specifically, let&amp;#8217;s look at the case of
covariance&amp;nbsp;matrices:&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [14]: a = np.random.randn(1000,&amp;nbsp;50)&lt;/p&gt;
&lt;p&gt;In [15]: a = np.dot(a,&amp;nbsp;a.T)&lt;/p&gt;
&lt;p&gt;In [16]: _, s, _ =&amp;nbsp;linalg.svd(a)&lt;/p&gt;
&lt;p&gt;In [17]: s[-9:]&lt;br /&gt;
Out[17]:&lt;br /&gt;
array([ 7.40548924e-14, 6.48102455e-14, 5.75803505e-14,&lt;br /&gt;
5.44263048e-14, 4.51528730e-14, 3.55317976e-14,&lt;br /&gt;
2.46939141e-14, 1.54186776e-14,&amp;nbsp;5.08135874e-15])&lt;/p&gt;
&lt;p&gt;[/sourcecode]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;a&lt;/code&gt; has at least 9 tiny singular values. Actually it&amp;#8217;s easy to see why
there are 950 of&amp;nbsp;them:&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [18]: np.sum(s \&amp;lt; 1e-10)&lt;br /&gt;
Out[18]: 950&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;How do our functions behave in this case? Instead of just looking at a
corner, let&amp;#8217;s use our gift of sight:[&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2012/08/pseudoinverses-300x218.png" title="Pseudoinverses" /&gt;][]&lt;/p&gt;
&lt;p&gt;The small eigenvalues are large enough that &lt;code&gt;inv&lt;/code&gt; thinks the matrix is
full rank. &lt;code&gt;pinv&lt;/code&gt; does better but it still fails, you can see a group of
high-amplitude noisy columns. &lt;code&gt;pinv2&lt;/code&gt; is faster and it also gives us a
useful result in this&amp;nbsp;case.&lt;/p&gt;
&lt;p&gt;Wait, does this mean that &lt;code&gt;pinv2&lt;/code&gt; is simply better, and &lt;code&gt;pinv&lt;/code&gt; is&amp;nbsp;useless?&lt;/p&gt;
&lt;p&gt;Not quite. Remember, we are now trying to actually invert matrices, and
degrade gracefully in case of rank deficiency. But what if we need the
pseudoinverse to solve an actual non-square, wide or tall&amp;nbsp;system?&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [19]: a = np.random.randn(1000,&amp;nbsp;50)&lt;/p&gt;
&lt;p&gt;In [20]: timeit linalg.pinv(a)&lt;br /&gt;
10 loops, best of 3: 104 ms per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [21]: timeit linalg.pinv(a.T)&lt;br /&gt;
100 loops, best of 3: 7.08 ms per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [22]: timeit linalg.pinv2(a)&lt;br /&gt;
10 loops, best of 3: 114 ms per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [23]: timeit linalg.pinv2(a.T)&lt;br /&gt;
10 loops, best of 3: 126 ms per loop&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Huge victory for &lt;code&gt;pinv&lt;/code&gt; in the wide case! Hurray! With all this insight,
we can draw a line and see what we&amp;nbsp;learned.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you are 100% sure that your matrix is invertible, use &lt;code&gt;inv&lt;/code&gt; for a
    huge speed gain. The implementation of &lt;code&gt;inv&lt;/code&gt; from Scipy is based on
    &lt;span class="caps"&gt;LAPACK&lt;/span&gt;&amp;#8217;s &lt;code&gt;*getrf&lt;/code&gt; + &lt;code&gt;*getri&lt;/code&gt;, known to have good&amp;nbsp;bounds.&lt;/li&gt;
&lt;li&gt;If you are trying to solve a tall or wide system, use &lt;code&gt;pinv&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If your matrix is square but might be rank deficient, use &lt;code&gt;pinv2&lt;/code&gt;
    for speed and numerical&amp;nbsp;gain.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Improving the symmetric&amp;nbsp;case&lt;/h2&gt;
&lt;p&gt;But wait a second, can&amp;#8217;t we do better? \$latex &lt;span class="caps"&gt;AA&lt;/span&gt;\^T\$ is symmetric,
can&amp;#8217;t we make use of that to speed up the computation even more?
Clearly, if \$latex A\$ is symmetric, in its &lt;span class="caps"&gt;SVD&lt;/span&gt; \$latex A = &lt;span class="caps"&gt;USV&lt;/span&gt;\^T\$,
we must have \$latex U = V\$. But this is exactly the eigendecomposition
of a symmetric matrix \$latex A\$. The eigendecomposition can be
computed cheaper than the &lt;span class="caps"&gt;SVD&lt;/span&gt; using Scipy &lt;code&gt;eigh&lt;/code&gt;, that uses &lt;span class="caps"&gt;LAPACK&lt;/span&gt;&amp;#8217;s
&lt;code&gt;*evr&lt;/code&gt;. As part of my GSoC this year, with help from &lt;a href="http://jakevdp.github.com/"&gt;Jake
VanderPlas&lt;/a&gt;, we made a &lt;a href="https://github.com/scipy/scipy/pull/289"&gt;pull request to Scipy&lt;/a&gt; containing a &lt;code&gt;pinvh&lt;/code&gt;
function that is equivalent to &lt;code&gt;pinv2&lt;/code&gt; but faster for symmetric&amp;nbsp;matrices.&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [24]: timeit linalg.pinv2(a)&lt;br /&gt;
1 loops, best of 3: 1.54 s per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [25]: timeit linalg.pinvh(a)&lt;br /&gt;
1 loops, best of 3: 621 ms per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [26]: np.testing.assert_array_almost_equal(linalg.pinv2(a),
linalg.pinvh(a))&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;[&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2012/08/pseudoinverses-300x218.png" title="Pseudoinverses" /&gt;]:&amp;nbsp;http://localhost:8001/wp-content/uploads/2012/08/pseudoinverses.png&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Sat, 18 Aug 2012 19:41:00 +0200</pubDate><guid>tag:vene.ro,2012-08-18:blog/inverses-pseudoinverses-numerical-issues-speed-symmetry.html</guid><category>inv</category><category>matrix inverse</category><category>numerical analysis</category><category>numerical methods</category><category>pinv</category><category>pinvh</category><category>positive semidefinite</category><category>pseudoinverse</category><category>symmetric</category><category>benchmarking</category><category>python</category></item><item><title>The scikit-learn-speed ship has set sail! Faster than ever, with multi-step benchmarks!</title><link>http://vene.ro/blog/the-scikit-learn-speed-ship-has-set-sail-faster-than-ever-with-multi-step-benchmarks.html</link><description>&lt;p&gt;I am pleased to announce that last night at 2:03 &lt;span class="caps"&gt;AM&lt;/span&gt;, the first fully
automated run of the scikit-learn-speed test suite has run on our
Jenkins instance! You can admire it at &lt;a href="http://jenkins-scikit-learn.github.com/scikit-learn-speed/"&gt;its temporary home&lt;/a&gt; for now.
As soon as we verify that everything is good, we will move this to the
official scikit-learn&amp;nbsp;page.&lt;/p&gt;
&lt;p&gt;I would like to take this opportunity to tell you about our latest
changeset. We made running the benchmark suite tons simpler by adding a
friendly Makefile. You can read more about its usage in the guide. But
by far, our coolest new toy&amp;nbsp;is:&lt;/p&gt;
&lt;h2&gt;Multi-step&amp;nbsp;benchmarks&lt;/h2&gt;
&lt;p&gt;A standard vbench benchmark has three units of code, represented as
strings: &lt;code&gt;code&lt;/code&gt;, &lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;cleanup&lt;/code&gt;. With the original timeit-based
benchmarks, this means that for every run, the setup would be executed
once. Then, the main loop runs &lt;code&gt;repeat&lt;/code&gt; times, and within each
iteration, the &lt;code&gt;code&lt;/code&gt; is run &lt;code&gt;ncalls&lt;/code&gt; times. Then &lt;code&gt;cleanup&lt;/code&gt; happens, the
best time is returned, and everybody is&amp;nbsp;happy.&lt;/p&gt;
&lt;p&gt;In scikit-learn, most of our interesting objects go through a state
change called &lt;em&gt;fitting&lt;/em&gt;. This metaphor is right at home in the machine
learning field, where we separate the learning phase for the prediction
phase. The prediction step cannot be invoked on an object that hasn&amp;#8217;t
been&amp;nbsp;fitted.&lt;/p&gt;
&lt;p&gt;For some algorithms, one of these steps is trivial. A brute force
Nearest Neighbors classifier can be instantaneously fit, but prediction
takes a while. On the opposite end we have linear models, with tons of
complicated algorithms to fit them, but evaluation is a simple
matrix-vector product that Numpy handles&amp;nbsp;perfectly.&lt;/p&gt;
&lt;p&gt;But many of scikit-learn&amp;#8217;s estimators have both steps interesting. Let&amp;#8217;s
take Non-negative Matrix Factorization. It has three interesting
functions: The &lt;code&gt;fit&lt;/code&gt; that computes \$latex X = &lt;span class="caps"&gt;WH&lt;/span&gt; \$, the &lt;code&gt;transform&lt;/code&gt;
that computes a non-negative projection on the components learned in
&lt;code&gt;fit&lt;/code&gt;, and &lt;code&gt;fit_transform&lt;/code&gt; that takes advantage of the observation that
when fitting, we also get the transformed \$latex X \$ for&amp;nbsp;free.&lt;/p&gt;
&lt;p&gt;When benchmarking &lt;span class="caps"&gt;NMF&lt;/span&gt;, we initially had to design 3&amp;nbsp;benchmarks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setup =&lt;/code&gt;standard, &lt;code&gt;code = obj.fit(X)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setup =&lt;/code&gt;standard, &lt;code&gt;code = obj.fit_transform(X)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setup =&lt;/code&gt;standard&lt;code&gt;+ obj.fit(X)&lt;/code&gt;, &lt;code&gt;code = obj.transform(X)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;How much time were we&amp;nbsp;wasting?&lt;/h2&gt;
&lt;p&gt;Let&amp;#8217;s say it takes 10 seconds. For every benchmark, we time the code by
running it 3 times. We run it once more to measure memory usage, once
more for &lt;code&gt;cProfile&lt;/code&gt; and one last time for &lt;code&gt;line_profiler&lt;/code&gt;. This is a
total of 6 times per benchmark. We need to multiply this by 2 again for
running on two datasets. So when benchmarking &lt;code&gt;NMF&lt;/code&gt;, because we need to
fit before predicting, we do it 12 extra times. If a fit takes 5
seconds, this means one minute wasted on benchmarking just one
estimator. &lt;em&gt;Wouldn&amp;#8217;t it be nice to &lt;code&gt;fit&lt;/code&gt;, &lt;code&gt;fit_transform&lt;/code&gt; and
&lt;code&gt;transform&lt;/code&gt; in a&amp;nbsp;sequence?&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Behind the&amp;nbsp;scenes&lt;/h2&gt;
&lt;p&gt;We made the &lt;code&gt;PythonBenchmark code&lt;/code&gt; parameter also support getting a
sequence of strings, instead of just a string. On the database side,
every benchmark result entry gets an extra component in the primary key,
the number of the step it&amp;nbsp;measures.&lt;/p&gt;
&lt;p&gt;In the benchmark description files, nothing is&amp;nbsp;changed:&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
{&lt;br /&gt;
&amp;#8216;obj&amp;#8217;: &amp;#8216;&lt;span class="caps"&gt;NMF&lt;/span&gt;&amp;#8217;,&lt;br /&gt;
&amp;#8216;init_params&amp;#8217;: {&amp;#8216;n_components&amp;#8217;: 2},&lt;br /&gt;
&amp;#8216;datasets&amp;#8217;: (&amp;#8216;blobs&amp;#8217;,),&lt;br /&gt;
&amp;#8216;statements&amp;#8217;: (&amp;#8216;fit_unsup&amp;#8217;, &amp;#8216;transform_unsup&amp;#8217;, &amp;#8216;fit_transform&amp;#8217;)&lt;br /&gt;
},&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;But before, we would take the cartesian product of datasets and
statements, and build a &lt;code&gt;Benchmark&lt;/code&gt; object for every pairing. Now, we
just pass the tuple as it is, and vbench is smart enough to do the right
thing.&lt;br /&gt;
We avoided the extra calls to &lt;code&gt;fit&lt;/code&gt; in a lot of benchmarks. The whole
suite now takes almost half the time to&amp;nbsp;run!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This trick is currently hosted in the
&lt;code&gt;abstract_multistep_benchmarks&lt;/code&gt; vbench branch in my&amp;nbsp;fork.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Sat, 11 Aug 2012 17:32:00 +0200</pubDate><guid>tag:vene.ro,2012-08-11:blog/the-scikit-learn-speed-ship-has-set-sail-faster-than-ever-with-multi-step-benchmarks.html</guid><category>multi-step</category><category>multistep</category><category>vbench</category><category>benchmarking</category><category>python</category><category>scikit-learn</category></item><item><title>Profiler output, benchmark standard deviation and other goodies in scikit-learn-speed</title><link>http://vene.ro/blog/profiler-output-benchmark-standard-deviation-and-other-goodies-in-scikit-learn-speed.html</link><description>&lt;p&gt;This post is about the &lt;a href="http://scikit-learn.org"&gt;scikit-learn&lt;/a&gt;benchmarking project that I am
working on, called &lt;a href="https://github.com/vene/scikit-learn-speed"&gt;scikit-learn-speed&lt;/a&gt;. This is a continuous
benchmarking suite that runs and generates &lt;span class="caps"&gt;HTML&lt;/span&gt; reports using Wes
McKinney&amp;#8217;s &lt;a href="http://wesmckinney.com/blog/?p=373"&gt;vbench&lt;/a&gt; framework, to which I had to make some (useful, I
hope)&amp;nbsp;additions.&lt;/p&gt;
&lt;h2&gt;What it looks like&amp;nbsp;now&lt;/h2&gt;
&lt;p&gt;You can check out a &lt;a href="http://vene.github.com/scikit-learn-speed"&gt;teaser/demo&lt;/a&gt; that was run on equidistant releases
from the last two months. What has changed since the last version?
Here&amp;#8217;s a list in order of&amp;nbsp;obviousness:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We now use the lovely scikit-learn&amp;nbsp;theme&lt;/li&gt;
&lt;li&gt;Timing graphs now show the ±1 standard deviation&amp;nbsp;range&lt;/li&gt;
&lt;li&gt;cProfile output is displayed for all the benchmarks, so we can
    easily see at a glance what&amp;#8217;s&amp;nbsp;up&lt;/li&gt;
&lt;li&gt;Said profiler output is collapsible using &lt;a href="http://www.jqueryui.com/demos/accordion/"&gt;JQueryUI&amp;nbsp;goodness&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;There now is an improved &lt;a href="http://vene.github.com/scikit-learn-speed/quick_start.html"&gt;Quick Start guide&lt;/a&gt; to running vbench on
    your&amp;nbsp;machine&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;What made this&amp;nbsp;possible&lt;/h2&gt;
&lt;p&gt;I have done some more refactoring in my vbench fork, because I didn&amp;#8217;t
want to have a huge, monolithic &lt;code&gt;Benchmark&lt;/code&gt; class that was specific to
what we want in scikit-learn-speed. So on this branch, I set up a
mixin/multiple inheritance hierarchy of benchmark&amp;nbsp;classes.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Benchmark&lt;/code&gt; class in vbench is now an abstract base class, with some
common functionality and structure.&lt;br /&gt;
Our &lt;code&gt;SklBenchmark&lt;/code&gt; class is defined in scikit-learn-speed&amp;nbsp;as:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class SklBenchmark(CProfileBenchmarkMixin,  MemoryBenchmarkMixin, PythonBenchmark):&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s read this from right to&amp;nbsp;left:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PythonBenchmark&lt;/code&gt;: This class stores &lt;code&gt;code&lt;/code&gt;, &lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;cleanup&lt;/code&gt;
    Python code as strings, and implements simple timing mechanisms
    using the &lt;code&gt;time&lt;/code&gt; module.&lt;/li&gt;
&lt;li&gt;Bonus: &lt;code&gt;TimeitBenchmark&lt;/code&gt;: This class extends &lt;code&gt;PythonBenchmark&lt;/code&gt; with
    the &lt;code&gt;timeit&lt;/code&gt; micro-benchmark timing method previously used in
    vbench. We turned this off in&amp;nbsp;scikit-learn-speed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MemoryBenchmarkMixin&lt;/code&gt;: This adds memory benchmarking using&amp;nbsp;[memory_profiler][].&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CProfileBenchmarkMixin&lt;/code&gt;: This runs the code through &lt;a href="http://docs.python.org/library/profile.html#module-cProfile"&gt;cProfile&lt;/a&gt;
    and implements mechanisms to report the output.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The database is not flexible enough to adapt to arbitrary benchmark
structure right now, so if anybody would like to help the effort, it
would be very&amp;nbsp;appreciated.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Fri, 27 Jul 2012 11:01:00 +0200</pubDate><guid>tag:vene.ro,2012-07-27:blog/profiler-output-benchmark-standard-deviation-and-other-goodies-in-scikit-learn-speed.html</guid><category>gsoc</category><category>memory_profiler</category><category>scikit-learn-speed</category><category>vbench</category><category>benchmarking</category><category>python</category><category>scikit-learn</category></item><item><title>Scikit-learn-speed HTML reports teaser</title><link>http://vene.ro/blog/scikit-learn-speed-html-reports-teaser.html</link><description>&lt;p&gt;&lt;span class="caps"&gt;EDIT&lt;/span&gt;: I made the plots a little more readable, check it&amp;nbsp;out!&lt;/p&gt;
&lt;p&gt;Last time, I teased you with a screenshot of local output. Now, I will
tease you with the benchmarks run on a couple of recent commits, along
with some from earlier this&amp;nbsp;year.&lt;/p&gt;
&lt;p&gt;After some effort and bugfixes, the project now reliably runs on
different machines, so the next step to host it on a remote server and
invoke it daily is getting closer. In the mean time, you can have a look
at &lt;a href="http://vene.github.com/scikit-learn-speed/" title="scikit-learn-speed"&gt;the sample output&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Note that just last time, the plots look jagged but the differences are
mostly minor and significant conclusions cannot be drawn yet, but as the
suite will start running daily, the plots will become much more
meaningful. I could waste time running the suite on more previous
commits, but the results wouldn&amp;#8217;t be comparable with the ones from the
deployed system, because of hardware&amp;nbsp;differences.&lt;/p&gt;
&lt;p&gt;Playing around with this makes me want a couple of features in vbench.
One is the possibility to overlay related benchmarks on the same plot
(for example, different parameters for the same algorithm and data):
this could be useful to spot patterns. A second one is some query /
sorting support: see what are the most expensive benchmarks, see what
benchmarks show the biggest jump in performance (but this could become a
historical wall of fame or&amp;nbsp;shame).&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Fri, 20 Jul 2012 14:40:00 +0200</pubDate><guid>tag:vene.ro,2012-07-20:blog/scikit-learn-speed-html-reports-teaser.html</guid><category>gsoc</category><category>scikit-learn-speed</category><category>vbench</category><category>benchmarking</category><category>python</category><category>scikit-learn</category></item><item><title>Memory benchmarking with vbench</title><link>http://vene.ro/blog/memory-benchmarking-with-vbench.html</link><description>&lt;p&gt;The &lt;a href="https://github.com/vene/scikit-learn-speed"&gt;scikit-learn-speed project&lt;/a&gt; now has memory usage&amp;nbsp;benchmarking!&lt;/p&gt;
&lt;p&gt;This was accomplished by building on what I described in my recent
posts, specifically the extensions to Fabian&amp;#8217;s [memory_profiler][] that
you can find in &lt;a href="https://github.com/vene/memory_profiler"&gt;my fork&lt;/a&gt;, but they will be merged upstream soon. The
key element is the &lt;code&gt;%magic_memit&lt;/code&gt; function whose development I blogged
about &lt;a href="http://localhost:8001/2012/06/30/quick-memory-usage-benchmarking-in-ipython/" title="Quick memory usage benchmarking in IPython"&gt;on&lt;/a&gt; &lt;a href="http://localhost:8001/2012/07/02/more-on-memory-benchmarking/" title="More on memory benchmarking"&gt;several&lt;/a&gt; &lt;a href="http://localhost:8001/2012/07/04/on-why-my-memit-fails-on-osx/" title="On why my %memit fails on OSX"&gt;occasions&lt;/a&gt;. I plugged this into &lt;a href="http://wesmckinney.com/blog/?p=373"&gt;vbench&lt;/a&gt;
in a similar way to how the timings are computed, all with great&amp;nbsp;success.&lt;/p&gt;
&lt;p&gt;Here is a screenshot of the way a simple benchmark looks now, with just
a few data&amp;nbsp;points.&lt;/p&gt;
&lt;p&gt;[caption id=&amp;#8221;attachment_464&amp;#8221; align=&amp;#8221;aligncenter&amp;#8221; width=&amp;#8221;600&amp;#8221;][![A
screenshot showing generated output from the scikit-learn-speed project,
illustrating memory usage benchmarking.][]][] Memory benchmarking in
scikit-learn-speed powered by&amp;nbsp;vbench.[/caption]&lt;/p&gt;
&lt;p&gt;You can check it out and use it yourself for your benchmarks, but you
need to use the vbench from the &lt;a href="https://github.com/vene/vbench/tree/memory"&gt;memory branch on my fork&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Of course, there are some important caveats. I am running this on my
laptop, which runs &lt;span class="caps"&gt;OS&lt;/span&gt; X Lion, so, under the effect of &lt;a href="http://localhost:8001/2012/07/04/on-why-my-memit-fails-on-osx/" title="On why my %memit fails on OSX"&gt;this
bug&lt;/a&gt;, I hardcoded the &amp;#8216;&lt;code&gt;-i&lt;/code&gt;&lt;span class="quo"&gt;&amp;#8216;&lt;/span&gt; so the memory benchmarks are not
realistic. Also, the y-range should probably be forced wider, because
the plots look erratic, showing the very small noise at a&amp;nbsp;large-scale.&lt;/p&gt;
&lt;p&gt;[A screenshot showing generated output from the scikit-learn-speed
  project, illustrating memory usage benchmarking.]: http://localhost:8001/wp-content/uploads/2012/07/vbench1.png
    &amp;#8220;Memory benchmarking in scikit-learn-speed powered by vbench.&amp;#8221;
  [![A screenshot showing generated output from the scikit-learn-speed
  project, illustrating memory usage benchmarking.][]]:&amp;nbsp;http://localhost:8001/wp-content/uploads/2012/07/vbench1.png&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Thu, 05 Jul 2012 12:38:00 +0200</pubDate><guid>tag:vene.ro,2012-07-05:blog/memory-benchmarking-with-vbench.html</guid><category>memit</category><category>memory</category><category>vbench</category><category>python</category><category>scikit-learn</category></item><item><title>On why my %memit fails on OSX</title><link>http://vene.ro/blog/on-why-my-memit-fails-on-osx.html</link><description>&lt;p&gt;In my &lt;a href="http://localhost:8001/2012/07/02/more-on-memory-benchmarking/" title="More on memory benchmarking"&gt;last post&lt;/a&gt; I mentioned that I&amp;#8217;m not satisfied with the current
state of &lt;code&gt;%memit&lt;/code&gt;, because some more complicated numerical function
calls make it crash. I will start this post with a reminder of a pretty
important&amp;nbsp;bug:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[On MacOS X (10.7 but maybe more), after forking a new process, there
is a segfault in Grand Central Dispatch on the &lt;span class="caps"&gt;BLAS&lt;/span&gt; &lt;span class="caps"&gt;DGEMM&lt;/span&gt; function from
Accelerate.][]&lt;br /&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class="caps"&gt;EDIT&lt;/span&gt; 1:&lt;/strong&gt; In a hurry, I forgot to mention how &lt;a href="http://twitter.com/ogrisel/"&gt;Olivier Grisel&lt;/a&gt; and
&lt;a href="https://github.com/cournape"&gt;David Cournapeau&lt;/a&gt; spent some time narrowing down this issue, starting
from an &lt;a href="https://github.com/scikit-learn/scikit-learn/issues/636"&gt;odd testing bug in scikit-learn&lt;/a&gt;. They reported it to Apple,
but there was, as of the date of this post, no&amp;nbsp;reaction.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class="caps"&gt;EDIT&lt;/span&gt; 2:&lt;/strong&gt; MinRK &lt;a href="https://twitter.com/minrk/status/228265246819774464" title="Min's tweet"&gt;confirms&lt;/a&gt;, and I verified shortly after, that this
bug is fixed in Mountain Lion (10.8). Still not sure how far back it
goes, though, so feedback is&amp;nbsp;welcome.&lt;/p&gt;
&lt;p&gt;When I first tried to make the &lt;code&gt;%memit&lt;/code&gt; magic, I thought about simply
measuring the current memory, running the command, and measuring the
memory again. The problem is the results are not consistent, because
Python &lt;a href="http://effbot.org/pyfaq/why-doesnt-python-release-the-memory-when-i-delete-a-large-object.htm"&gt;tries to reuse already allocated memory whenever it can&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Using memory_profiler, here&amp;#8217;s an example illustrating this elastic
memory management:&lt;br /&gt;
[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
# mem_test.py&lt;br /&gt;
import numpy as&amp;nbsp;np&lt;/p&gt;
&lt;p&gt;def make_a_large_array():&lt;br /&gt;
return np.ones((1000,&amp;nbsp;1000))&lt;/p&gt;
&lt;p&gt;def main():&lt;br /&gt;
make_a_large_array()&lt;br /&gt;
make_a_large_array()&lt;br /&gt;&amp;nbsp;make_a_large_array()&lt;/p&gt;
&lt;p&gt;# in IPython:&lt;br /&gt;
In [1]: import&amp;nbsp;mem_test&lt;/p&gt;
&lt;p&gt;In [2]: %mprun -f mem_test.main mem_test.main()&lt;br /&gt;
Filename:&amp;nbsp;mem_test.py&lt;/p&gt;
&lt;h1&gt;Line # Mem usage Increment Line&amp;nbsp;Contents&lt;/h1&gt;
&lt;p&gt;8 24.8477 &lt;span class="caps"&gt;MB&lt;/span&gt; 0.0000 &lt;span class="caps"&gt;MB&lt;/span&gt; def main():&lt;br /&gt;
9 24.8633 &lt;span class="caps"&gt;MB&lt;/span&gt; 0.0156 &lt;span class="caps"&gt;MB&lt;/span&gt; make_a_large_array()&lt;br /&gt;
10 32.4688 &lt;span class="caps"&gt;MB&lt;/span&gt; 7.6055 &lt;span class="caps"&gt;MB&lt;/span&gt; make_a_large_array()&lt;br /&gt;
11 32.4688 &lt;span class="caps"&gt;MB&lt;/span&gt; 0.0000 &lt;span class="caps"&gt;MB&lt;/span&gt; make_a_large_array()&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;If this was in an IPython environment, and one would like to see how
much memory &lt;code&gt;make_a_large_array()&lt;/code&gt; uses, you could say we can simply run
it a few times and take the maximum. However, if you happened to
accidentally call &lt;code&gt;main()&lt;/code&gt; once before, you will no longer get a good&amp;nbsp;result:&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [3]: %mprun -f mem_test.main mem_test.main()&lt;br /&gt;
Filename:&amp;nbsp;mem_test.py&lt;/p&gt;
&lt;h1&gt;Line # Mem usage Increment Line&amp;nbsp;Contents&lt;/h1&gt;
&lt;p&gt;8 32.4922 &lt;span class="caps"&gt;MB&lt;/span&gt; 0.0000 &lt;span class="caps"&gt;MB&lt;/span&gt; def main():&lt;br /&gt;
9 32.5234 &lt;span class="caps"&gt;MB&lt;/span&gt; 0.0312 &lt;span class="caps"&gt;MB&lt;/span&gt; make_a_large_array()&lt;br /&gt;
10 32.5234 &lt;span class="caps"&gt;MB&lt;/span&gt; 0.0000 &lt;span class="caps"&gt;MB&lt;/span&gt; make_a_large_array()&lt;br /&gt;
11 32.5234 &lt;span class="caps"&gt;MB&lt;/span&gt; 0.0000 &lt;span class="caps"&gt;MB&lt;/span&gt; make_a_large_array()&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;So how can we get consistent results for the memory usage of an
instruction? We could run it in a fresh, new process. I implemented this
in %memit and it&amp;nbsp;shows:&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [5]: %memit mem_test.make_a_large_array()&lt;br /&gt;
maximum of 3: 8.039062 &lt;span class="caps"&gt;MB&lt;/span&gt; per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [6]: %memit mem_test.make_a_large_array()&lt;br /&gt;
maximum of 3: 8.035156 &lt;span class="caps"&gt;MB&lt;/span&gt; per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [7]: %memit mem_test.make_a_large_array()&lt;br /&gt;
maximum of 3: 8.042969 &lt;span class="caps"&gt;MB&lt;/span&gt; per loop&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;This way you can also realistically benchmark&amp;nbsp;assignments:&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [8]: %memit X = mem_test.make_a_large_array()&lt;br /&gt;
maximum of 3: 8.054688 &lt;span class="caps"&gt;MB&lt;/span&gt; per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [9]: %memit X = mem_test.make_a_large_array()&lt;br /&gt;
maximum of 3: 8.058594 &lt;span class="caps"&gt;MB&lt;/span&gt; per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [10]: %memit X = mem_test.make_a_large_array()&lt;br /&gt;
maximum of 3: 8.058594 &lt;span class="caps"&gt;MB&lt;/span&gt; per loop&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;If we don&amp;#8217;t spawn a subprocess, &lt;code&gt;del&lt;/code&gt; doesn&amp;#8217;t help, but allocating new
variables does:&lt;br /&gt;
[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [11]: %memit -i X = mem_test.make_a_large_array()&lt;br /&gt;
maximum of 3: 7.632812 &lt;span class="caps"&gt;MB&lt;/span&gt; per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [12]: del&amp;nbsp;X&lt;/p&gt;
&lt;p&gt;In [13]: %memit -i X = mem_test.make_a_large_array()&lt;br /&gt;
maximum of 3: 0.000000 &lt;span class="caps"&gt;MB&lt;/span&gt; per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [14]: %memit -i Y = mem_test.make_a_large_array()&lt;br /&gt;
maximum of 3: 7.632812 &lt;span class="caps"&gt;MB&lt;/span&gt; per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [15]: %memit -i Z = mem_test.make_a_large_array()&lt;br /&gt;
maximum of 3: 7.632812 &lt;span class="caps"&gt;MB&lt;/span&gt; per loop&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Now, the problem is that when the function that you are benchmarking
contains calls to &lt;code&gt;np.dot&lt;/code&gt; (matrix multiplication), the subprocess will
consistently fail with &lt;span class="caps"&gt;SIGSEGV&lt;/span&gt; on affected &lt;span class="caps"&gt;OS&lt;/span&gt; X systems. These are
actually pretty much all the functions that I intended &lt;code&gt;%memit&lt;/code&gt; for:
numerical applications. For that reason, I have made &lt;code&gt;%memit&lt;/code&gt; notify the
user when all subprocesses fail, and to suggest the usage of the &lt;code&gt;-i&lt;/code&gt;
flag.&lt;/p&gt;
&lt;p&gt;I think that, with this update, &lt;code&gt;%memit&lt;/code&gt; is flexible and usable enough
for actual use, and therefore for merging into&amp;nbsp;memory_profiler.&lt;/p&gt;
&lt;p&gt;[On MacOS X (10.7 but maybe more), after forking a new process, there
  is a segfault in Grand Central Dispatch on the &lt;span class="caps"&gt;BLAS&lt;/span&gt; &lt;span class="caps"&gt;DGEMM&lt;/span&gt; function
  from Accelerate.]:&amp;nbsp;https://gist.github.com/2027412&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Wed, 04 Jul 2012 12:49:00 +0200</pubDate><guid>tag:vene.ro,2012-07-04:blog/on-why-my-memit-fails-on-osx.html</guid><category>IPython</category><category>magic</category><category>memit</category><category>mprun</category><category>benchmarking</category><category>python</category></item><item><title>More on memory benchmarking</title><link>http://vene.ro/blog/more-on-memory-benchmarking.html</link><description>&lt;p&gt;Following up on my task to make it easier to benchmark memory usage in
Python, I updated Fabian&amp;#8217;s [memory_profiler][] to include a couple of
useful IPython magics. While in my &lt;a href="http://localhost:8001/2012/06/30/quick-memory-usage-benchmarking-in-ipython/" title="Quick memory usage benchmarking in IPython"&gt;last post&lt;/a&gt;, I used the new IPython
0.13 syntax for defining magics, this time I used the
backwards-compatible one from the previous&amp;nbsp;version.&lt;/p&gt;
&lt;p&gt;You can find this work-in-progress as a [pull request on
memory_profiler][] from where you can trace it to my GitHub repo.
Here&amp;#8217;s what you can do with&amp;nbsp;it:&lt;/p&gt;
&lt;h2&gt;%mprun&lt;/h2&gt;
&lt;p&gt;Copying the spirit of &lt;code&gt;%lprun&lt;/code&gt;, since imitation is the most sincere form
of flattery, you can use %mprun to easily view line-by-line memory usage
reports, without having to go in and add the &lt;code&gt;@profile&lt;/code&gt; decorator.&lt;/p&gt;
&lt;p&gt;For&amp;nbsp;example:&lt;/p&gt;
&lt;p&gt;[sourcecode&amp;nbsp;lang=&amp;#8221;python&amp;#8221;]&lt;/p&gt;
&lt;p&gt;In [1]: import numpy as&amp;nbsp;np&lt;/p&gt;
&lt;p&gt;In [2]: from sklearn.linear_model import&amp;nbsp;ridge_regression&lt;/p&gt;
&lt;p&gt;In [3]: X, y = np.array([[1, 2], [3, 4], [5, 6]]), np.array([2, 4,&amp;nbsp;6])&lt;/p&gt;
&lt;p&gt;In [4]: %mprun -f ridge_regression ridge_regression(X, y,&amp;nbsp;1.0)&lt;/p&gt;
&lt;p&gt;(&amp;#8230;)&lt;/p&gt;
&lt;p&gt;109 41.6406 &lt;span class="caps"&gt;MB&lt;/span&gt; 0.0000 &lt;span class="caps"&gt;MB&lt;/span&gt; if n_features &gt; n_samples or \&lt;br /&gt;
110 41.6406 &lt;span class="caps"&gt;MB&lt;/span&gt; 0.0000 &lt;span class="caps"&gt;MB&lt;/span&gt; isinstance(sample_weight, np.ndarray) or \&lt;br /&gt;
111 41.6406 &lt;span class="caps"&gt;MB&lt;/span&gt; 0.0000 &lt;span class="caps"&gt;MB&lt;/span&gt; sample_weight != 1.0:&lt;br /&gt;
112&lt;br /&gt;
113 # kernel ridge&lt;br /&gt;
114 # w = X.T * inv(X X\^t + alpha*Id) y&lt;br /&gt;
115 A = np.dot(X, X.T)&lt;br /&gt;
116 A.flat[::n_samples + 1] += alpha * sample_weight&lt;br /&gt;
117 coef = np.dot(X.T, _solve(A, y, solver, tol))&lt;br /&gt;
118 else:&lt;br /&gt;
119 # ridge&lt;br /&gt;
120 # w = inv(X\^t X + alpha*Id) * X.T y&lt;br /&gt;
121 41.6484 &lt;span class="caps"&gt;MB&lt;/span&gt; 0.0078 &lt;span class="caps"&gt;MB&lt;/span&gt; A = np.dot(X.T, X)&lt;br /&gt;
122 41.6875 &lt;span class="caps"&gt;MB&lt;/span&gt; 0.0391 &lt;span class="caps"&gt;MB&lt;/span&gt; A.flat[::n_features + 1] += alpha&lt;br /&gt;
123 41.7344 &lt;span class="caps"&gt;MB&lt;/span&gt; 0.0469 &lt;span class="caps"&gt;MB&lt;/span&gt; coef = _solve(A, np.dot(X.T, y), solver,
tol)&lt;br /&gt;
124&lt;br /&gt;
125 41.7344 &lt;span class="caps"&gt;MB&lt;/span&gt; 0.0000 &lt;span class="caps"&gt;MB&lt;/span&gt; return&amp;nbsp;coef.T&lt;/p&gt;
&lt;p&gt;[/sourcecode]&lt;/p&gt;
&lt;h2&gt;%memit&lt;/h2&gt;
&lt;p&gt;As described in my previous post, this is a &lt;code&gt;%timeit&lt;/code&gt;-like magic for
quickly seeing how much memory a Python command uses.&lt;br /&gt;
Unlike %timeit, however, the command needs to be executed in a fresh
process. I have to dig in some more to debug this, but if the command is
run in the current process, very often the difference in memory usage
will be insignificant, I assume because preallocated memory is used. The
problem is that when running in a new process, some functions that I
tried to bench crash with &lt;code&gt;SIGSEGV&lt;/code&gt;. For a lot of stuff, though,
&lt;code&gt;%memit&lt;/code&gt; is currently&amp;nbsp;usable:&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [1]: import numpy as&amp;nbsp;np&lt;/p&gt;
&lt;p&gt;In [2]: X = np.ones((1000,&amp;nbsp;1000))&lt;/p&gt;
&lt;p&gt;In [3]: %memit X.T&lt;br /&gt;
worst of 3: 0.242188 &lt;span class="caps"&gt;MB&lt;/span&gt; per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [4]: %memit np.asfortranarray(X)&lt;br /&gt;
worst of 3: 15.687500 &lt;span class="caps"&gt;MB&lt;/span&gt; per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [5]: Y =&amp;nbsp;X.copy(&amp;#8216;F&amp;#8217;)&lt;/p&gt;
&lt;p&gt;In [6]: %memit np.asfortranarray(Y)&lt;br /&gt;
worst of 3: 0.324219 &lt;span class="caps"&gt;MB&lt;/span&gt; per loop&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;It is very easy, using this small tool, to see what forces memory
copying and what does&amp;nbsp;not.&lt;/p&gt;
&lt;h2&gt;Installation&amp;nbsp;instructions&lt;/h2&gt;
&lt;p&gt;First, you have to get the source code of this version of
memory_profiler. Then, it depends on your version of IPython. If you
have 0.10, you have to edit &lt;code&gt;~/.ipython/ipy_user_conf.py&lt;/code&gt; like this:
(once again, instructions &lt;em&gt;borrowed&lt;/em&gt; from&amp;nbsp;[line_profiler][])&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
# These two lines are standard and probably already there.&lt;br /&gt;
import IPython.ipapi&lt;br /&gt;
ip =&amp;nbsp;IPython.ipapi.get()&lt;/p&gt;
&lt;p&gt;# These two are the important ones.&lt;br /&gt;
import memory_profiler&lt;br /&gt;
ip.expose_magic(&amp;#8216;mprun&amp;#8217;, memory_profiler.magic_mprun)&lt;br /&gt;
ip.expose_magic(&amp;#8216;memit&amp;#8217;, memory_profiler.magic_memit)&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;If you&amp;#8217;re using IPython 0.11 or newer, the steps are different. First
create a configuration profile:&lt;br /&gt;
[sourcecode lang=&amp;#8221;bash&amp;#8221;]&lt;br /&gt;
\$ ipython profile create&lt;br /&gt;
[/sourcecode]&lt;br /&gt;
Then create a file named &lt;code&gt;~/.ipython/extensions/memory_profiler_ext.py&lt;/code&gt;
with the following&amp;nbsp;content:&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
import&amp;nbsp;memory_profiler&lt;/p&gt;
&lt;p&gt;def load_ipython_extension(ip):&lt;br /&gt;
ip.define_magic(&amp;#8216;mprun&amp;#8217;, memory_profiler.magic_mprun)&lt;br /&gt;
ip.define_magic(&amp;#8216;memit&amp;#8217;, memory_profiler.magic_memit)&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Then register it in &lt;code&gt;~/.ipython/profile_default/ipython_config.py&lt;/code&gt;, like
this. Of course, if you already have other extensions such as
&lt;code&gt;line_profiler_ext&lt;/code&gt;, just add the new one to the&amp;nbsp;list.&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
c.TerminalIPythonApp.extensions = [&lt;br /&gt;
&amp;#8216;memory_profiler_ext&amp;#8217;,&lt;br /&gt;
]&lt;br /&gt;
c.InteractiveShellApp.extensions = [&lt;br /&gt;
&amp;#8216;memory_profiler_ext&amp;#8217;,&lt;br /&gt;
]&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Now launch IPython and you can use the new magics like in the examples&amp;nbsp;above.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Mon, 02 Jul 2012 11:27:00 +0200</pubDate><guid>tag:vene.ro,2012-07-02:blog/more-on-memory-benchmarking.html</guid><category>IPython</category><category>magic</category><category>memit</category><category>memory</category><category>memory_profiler</category><category>mprun</category><category>benchmarking</category><category>python</category></item><item><title>Quick memory usage benchmarking in IPython</title><link>http://vene.ro/blog/quick-memory-usage-benchmarking-in-ipython.html</link><description>&lt;p&gt;Everybody loves &lt;code&gt;%timeit&lt;/code&gt;, there&amp;#8217;s no doubt about it. So why not have
something like that, but for measuring how much memory your line takes?
Well, now you can; grab a hold of the script in the following gist and
run it like in the&amp;nbsp;example.&lt;/p&gt;
&lt;p&gt;[gist&amp;nbsp;id=3022718]&lt;/p&gt;
&lt;p&gt;Instead of taking care of the dirty process inspection stuff myself, I
decided to delegate this to Fabian&amp;#8217;s simple but very good
[&lt;code&gt;memory_profiler&lt;/code&gt;][]. There is also &lt;a href="http://guppy-pe.sourceforge.net/"&gt;Guppy&lt;/a&gt; available, but its design
seems a bit and overkill for this&amp;nbsp;task.&lt;/p&gt;
&lt;p&gt;Please contact me if you find problems with this implementation, this is
a preliminary, quick hack-y version.&amp;nbsp;:)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Sat, 30 Jun 2012 08:53:00 +0200</pubDate><guid>tag:vene.ro,2012-06-30:blog/quick-memory-usage-benchmarking-in-ipython.html</guid><category>benchmark</category><category>IPython</category><category>magic</category><category>memory</category><category>memory_profiler</category><category>profiling</category><category>benchmarking</category><category>python</category></item><item><title>Compiling and Installing GLARF and the bundled Charniak parser on MacOS X</title><link>http://vene.ro/blog/compiling-and-installing-glarf-and-the-bundled-charniak-parser-on-macos-x.html</link><description>&lt;p&gt;It seems that I keep getting handed buggy code to install. These are
cases of research software where the developers didn&amp;#8217;t make the effort
to make sure their tool works on the platforms it&amp;nbsp;should.&lt;/p&gt;
&lt;p&gt;[&lt;span class="caps"&gt;GLARF&lt;/span&gt;][] (Grammatical and Logical Argument Representation Framework)
is, in their words, &amp;#8220;a typed feature structure framework for
representing regularizations of parse trees&amp;#8221;. It is a processing
pipeline from &lt;span class="caps"&gt;NYU&lt;/span&gt; with rich output including many types of structure in
the given text. However, it is clearly a case of software whose
maintenance was abandoned when it &amp;#8220;worked&amp;#8221; for them. The whole install
and run procedure is pretty messy, but at least it&amp;#8217;s documented. The
problem is, following it step by step doesn&amp;#8217;t work on my MacBook. As
usual, I needed to hack through it a&amp;nbsp;bit.&lt;/p&gt;
&lt;p&gt;The Charniak parser distributed with &lt;span class="caps"&gt;GLARF&lt;/span&gt; has now been superseded by
the [&lt;span class="caps"&gt;BLLIP&lt;/span&gt; parser][]. The new one is tricky to compile as well, but I
have yet to see if it plugs into &lt;span class="caps"&gt;GLARF&lt;/span&gt;, so I leave this for a future&amp;nbsp;post.&lt;/p&gt;
&lt;p&gt;Here are the steps I needed to take to make &lt;span class="caps"&gt;GLARF&lt;/span&gt;&amp;nbsp;work:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
Download and unzip the &lt;span class="caps"&gt;GLARF&lt;/span&gt;&amp;nbsp;package.

&lt;/li&gt;
&lt;li&gt;
Make sure you have `sbcl` in your path, and your `perl` is in (or linked
from)&amp;nbsp;`/usr/bin/perl`

&lt;/li&gt;
&lt;li&gt;
Set the environment variables. I like to make a shell script to set them
so I don&amp;#8217;t have to do it every time. So I write something looking like
this:

[sourcecode lang=&amp;#8221;bash&amp;#8221;]  
\# glarf\_env.sh

export &lt;span class="caps"&gt;GLARF&lt;/span&gt;=/Users/vene/code/&lt;span class="caps"&gt;GLARF&lt;/span&gt;  
export &lt;span class="caps"&gt;GLARF&lt;/span&gt;\_JET=\${&lt;span class="caps"&gt;GLARF&lt;/span&gt;}/&lt;span class="caps"&gt;JET&lt;/span&gt;  
export &lt;span class="caps"&gt;PATH&lt;/span&gt;=\$&lt;span class="caps"&gt;PATH&lt;/span&gt;:.  
[/sourcecode]

&lt;p&gt;
Then for every session when I want to use &lt;span class="caps"&gt;GLARF&lt;/span&gt;, I do
`source&amp;nbsp;glarf_env.sh`.

&lt;/li&gt;
&lt;li&gt;
Compile &lt;span class="caps"&gt;GLARF&lt;/span&gt; by running `$&lt;span class="caps"&gt;GLARF&lt;/span&gt;/commands-2010/compile-glarf`. *Note:*
this only compiles the pipeline lisp&amp;nbsp;code.

&lt;/li&gt;
&lt;li&gt;
Now, according to their instructions, you&amp;#8217;re done. However, if you try
to run it, you&amp;#8217;d notice the output is incomplete. (It goes through the
named entity extraction part, but it doesn&amp;#8217;t run the parser.) The reason
for this is that they distribute the Charniak parser with a precompiled
binary that runs on Linux, but not on the Mac. So we need to recompile
it. So go to `$&lt;span class="caps"&gt;GLARF&lt;/span&gt;/charniak-parser-2005/parser05Aug16-static/&lt;span class="caps"&gt;PARSE2&lt;/span&gt; `,
run `make clean` and roll up your&amp;nbsp;sleeves.

&lt;/li&gt;
&lt;li&gt;
Obviously, simply running `make` doesn&amp;#8217;t work. [As documented by Pawel
Mazur][], we need to edit `BchartSm.C` to add the line
`#include&amp;nbsp;&amp;#8220;GotIter.h&amp;#8221;`

&lt;/li&gt;
&lt;li&gt;
On my system this still isn&amp;#8217;t enough, and I get some linker errors. By
poking through the Makefile, I noticed I could fix it by commenting out
the 5th line: `&lt;span class="caps"&gt;LDFLAGS&lt;/span&gt;=-static`.

&lt;/li&gt;
&lt;li&gt;
Now run make and watch it work, hurrah!&amp;nbsp;&amp;#92;o/

&lt;/li&gt;
&lt;li&gt;
To see if &lt;span class="caps"&gt;GLARF&lt;/span&gt; itself works now, go to
`$&lt;span class="caps"&gt;GLARF&lt;/span&gt;/commands-2010/run-glarf/` and run
`make-all-glarf-a sample-files-a N`. You should get beautiful, beautiful
&lt;span class="caps"&gt;GLARF&lt;/span&gt; output&amp;nbsp;files.

&lt;/li&gt;
&lt;/ul&gt;
Phew, now that was quite an effort!

  [&lt;span class="caps"&gt;GLARF&lt;/span&gt;]: http://nlp.cs.nyu.edu/meyers/&lt;span class="caps"&gt;GLARF&lt;/span&gt;.html
  [&lt;span class="caps"&gt;BLLIP&lt;/span&gt; parser]: https://github.com/&lt;span class="caps"&gt;BLLIP&lt;/span&gt;/bllip-parser
  [As documented by Pawel Mazur]:&amp;nbsp;http://web.science.mq.edu.au/~mpawel/resources/notes/compilingCharniakJohnson.htm</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Thu, 21 Jun 2012 12:32:00 +0200</pubDate><guid>tag:vene.ro,2012-06-21:blog/compiling-and-installing-glarf-and-the-bundled-charniak-parser-on-macos-x.html</guid><category>bllip</category><category>charniak</category><category>glarf</category><category>installation</category><category>parser</category><category>nlp</category></item><item><title>Compiling MegaM on MacOS X</title><link>http://vene.ro/blog/compiling-megam-on-macos-x.html</link><description>&lt;p&gt;&lt;a href="http://hal3.name/megam"&gt;MegaM&lt;/a&gt; is Hal Daumé &lt;span class="caps"&gt;III&lt;/span&gt;&amp;#8217;s maxent (logistic regression, and much more)
modeling software written in OCaml. It is feature-packed and seems to be
used a lot, despite being slightly dated. &lt;a href="http://nltk.org" title="Natural Language Toolkit"&gt;&lt;span class="caps"&gt;NLTK&lt;/span&gt;&lt;/a&gt; is able to use&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;In order to compile it as of 2012, with the current version of OCaml, I
had to do some tricks that I would like to document here. It&amp;#8217;s no big
deal but it could save somebody precious&amp;nbsp;minutes.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Download and unpack the gzip&amp;nbsp;archive.&lt;/li&gt;
&lt;li&gt;Install ocaml using macports: &lt;code&gt;sudo port install ocaml&lt;/code&gt;. &lt;em&gt;Note:&lt;/em&gt;
    this installed version 3.12.1_5, &lt;span class="caps"&gt;YMMV&lt;/span&gt; with newer versions&amp;nbsp;later.&lt;/li&gt;
&lt;li&gt;Point the compiler to the correct headers. First run &lt;code&gt;ocamlc -where&lt;/code&gt;
    to find out the correct path. On my system it&amp;#8217;s
    &lt;code&gt;/opt/local/lib/ocaml/caml&lt;/code&gt;. Change the &lt;code&gt;WITHCLIBS&lt;/code&gt; line (#73) in
    the Makefile to point&amp;nbsp;there.&lt;/li&gt;
&lt;li&gt;As of OCaml 3.12.0, the &lt;code&gt;-lstr&lt;/code&gt; compiler flag should be replaced
    with &lt;code&gt;-lcamlstr&lt;/code&gt;. It occurs on line #62 within the definition of
    &lt;code&gt;WITHSTR&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;make&lt;/code&gt; or &lt;code&gt;make opt&lt;/code&gt; and&amp;nbsp;enjoy.&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Fri, 08 Jun 2012 11:45:00 +0200</pubDate><guid>tag:vene.ro,2012-06-08:blog/compiling-megam-on-macos-x.html</guid><category>compile</category><category>install</category><category>maxent</category><category>megam</category><category>nlp</category></item><item><title>Dynamically generated benchmarks with vbench</title><link>http://vene.ro/blog/dynamically-generated-benchmarks-with-vbench.html</link><description>&lt;p&gt;To construct a &lt;code&gt;vbench&lt;/code&gt; benchmark you need a setup string and a code
string. The constructor&amp;#8217;s signature&amp;nbsp;is:  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;Benchmark(self, code, setup, ncalls=None, repeat=3, cleanup=None, name=None, description=None, start_date=None, logy=False)&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Why generate benchmarks&amp;nbsp;dynamically?&lt;/h2&gt;
&lt;p&gt;For most &lt;code&gt;scikit-learn&lt;/code&gt; purposes, the &lt;code&gt;code&lt;/code&gt; string will be very close
to &lt;code&gt;"algorithm.fit(X, y)"&lt;/code&gt;, &lt;code&gt;"algorithm.transform(X)"&lt;/code&gt; or
&lt;code&gt;"algorithm.predict(X)"&lt;/code&gt;. We can generate a lot of benchmarks by
changing what the algorithm is, and changing what the data is or the way
it is&amp;nbsp;generated.&lt;/p&gt;
&lt;p&gt;A possible idea would be to create a
&lt;abbr title="domain-specific language" lang="en"&gt;&lt;span class="caps"&gt;DSL&lt;/span&gt;&lt;/abbr&gt; in which to
specify scikit-learn tests and create benchmarks from them. However,
before engineering such a solution, I wanted to test out how to generate
three related benchmarks using different arguments for the dataset
generation&amp;nbsp;function.&lt;/p&gt;
&lt;p&gt;This is what I came up&amp;nbsp;with:&lt;/p&gt;
&lt;p&gt;[sourcecode language=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
from vbench.benchmark import&amp;nbsp;Benchmark&lt;/p&gt;
&lt;p&gt;_setup = &amp;#8220;&amp;#8221;&amp;#8220;&lt;br /&gt;
from deps import&amp;nbsp;*&lt;/p&gt;
&lt;p&gt;kwargs = %s&lt;br /&gt;
X, y = make_regression(random_state=0, **kwargs)&lt;br /&gt;
lr = LinearRegression()&lt;br /&gt;&amp;nbsp;&amp;#8220;&amp;#8221;&amp;#8220;&lt;/p&gt;
&lt;p&gt;_configurations = [&lt;br /&gt;
(&amp;#8216;linear_regression_many_samples&amp;#8217;,&lt;br /&gt;
{&amp;#8216;n_samples&amp;#8217;: 10000, &amp;#8216;n_features&amp;#8217;: 100}),&lt;br /&gt;
(&amp;#8216;linear_regression_many_features&amp;#8217;,&lt;br /&gt;
{&amp;#8216;n_samples&amp;#8217;: 100, &amp;#8216;n_features&amp;#8217;: 10000}),&lt;br /&gt;
(&amp;#8216;linear_regression_many_targets&amp;#8217;,&lt;br /&gt;
{&amp;#8216;n_samples&amp;#8217;: 1000, &amp;#8216;n_features&amp;#8217;: 100, &amp;#8216;n_targets&amp;#8217;: 100})&lt;br /&gt;&amp;nbsp;]&lt;/p&gt;
&lt;p&gt;_statement = &amp;#8220;lr.fit(X,&amp;nbsp;y)&amp;#8221;&lt;/p&gt;
&lt;p&gt;_globs = globals()&lt;br /&gt;
_globs.update({name: Benchmark(_statement, _setup % str(kwargs),
name=name)&lt;br /&gt;
for name, kwargs in&amp;nbsp;_configurations})&lt;/p&gt;
&lt;p&gt;[/sourcecode]&lt;/p&gt;
&lt;p&gt;It works perfectly, but I don&amp;#8217;t like having to hack the globals to make
the benchmarks detectable. This is because of the way the vbench suite
gathers benchmarks. In &lt;code&gt;__init__.py&lt;/code&gt; we have to do
&lt;code&gt;from linear_regression import *&lt;/code&gt;. With a small update to the detection
method, we could replace the hacky part with a public lists of Benchmark&amp;nbsp;objects.&lt;/p&gt;
&lt;h2&gt;Exposed&amp;nbsp;issues&lt;/h2&gt;
&lt;p&gt;While working on this, after my first attempt, I was surprised to see
that there were no results added to the database, and output plots were
empty. It turns out that the generated benchmarks weren&amp;#8217;t running, even
though if I copied and pasted their source code from the generated html,
it would run. Vbench was not issuing any sort of message to let me know
that anything was&amp;nbsp;wrong.&lt;/p&gt;
&lt;p&gt;So what was the problem? My fault, of course, whitespace. But in all
fairness, we should add better&amp;nbsp;feedback.&lt;/p&gt;
&lt;p&gt;This is what I was doing to generate the setup&amp;nbsp;string:&lt;/p&gt;
&lt;p&gt;[sourcecode lang=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
def _make_setup(kwargs):&lt;br /&gt;
return &amp;#8220;&amp;#8221;&amp;#8220;&lt;br /&gt;
from deps import&amp;nbsp;*&lt;/p&gt;
&lt;p&gt;kwargs = %s&lt;br /&gt;
X, y = make_regression(random_state=0, **kwargs)&lt;br /&gt;
lr = LinearRegression()&lt;br /&gt;
&amp;#8220;&amp;#8221;&amp;#8221; % str(kwargs)&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s clear as daylight now that I overzealously indented the multiline
string. But man, was it hard to debug! Also, in this example, the bug
led to a refactoring that made the whole thing nicer and more direct.
Hopefully, my experience with vbench will lead to some improvements to
this cool and highly useful piece of&amp;nbsp;software.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Thu, 07 Jun 2012 01:57:00 +0200</pubDate><guid>tag:vene.ro,2012-06-07:blog/dynamically-generated-benchmarks-with-vbench.html</guid><category>gsoc</category><category>vbench</category><category>benchmarking</category><category>python</category></item><item><title>First contact with vbench</title><link>http://vene.ro/blog/first-contact-with-vbench.html</link><description>&lt;p&gt;With a slight delay caused by going to lovely lovely Istanbul for the
&lt;span class="caps"&gt;LREC&lt;/span&gt; conference where I presented a &lt;a href="http://vene.ro/papers/lrec12-poster.pdf"&gt;poster&lt;/a&gt;, I am back to work on the
Google Summer of Code project. By the way, this year&amp;#8217;s logo and swag
looks a lot nicer than last year&amp;#8217;s, thank you Google!&lt;br /&gt;
[&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2012/05/P5280194-300x225.jpg" title="GSoC swag" /&gt;][]&lt;br /&gt;
The backbone of my GSoC consists of putting together a continuous
benchmark platform. I took a good look at &lt;a href="https://github.com/pydata/vbench"&gt;vbench&lt;/a&gt; and spent an
evening hacking Wes&amp;#8217;s benchmarks suite config into something that will
run on my machine. These are the key points I got from this&amp;nbsp;experience.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vbench is, at least for the moment, very specific to [Wes&amp;#8217; and
    Pandas&amp;#8217; needs][]. This is also because there weren&amp;#8217;t so many other
    users that could have brought&amp;nbsp;contributions.&lt;/li&gt;
&lt;li&gt;Even though it has support for some configuration and automation,
    vbench seems largely suited for running on a local machine.
    Specifically, it is &lt;span class="caps"&gt;NOT&lt;/span&gt; designed to run continuously but in one-off
    runs, going back in git history and getting the last commit for each
    day, and running the benchmark with it. Of course, it is trivial to
    patch it into getting just one&amp;nbsp;commit.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;code-as-strings&lt;/em&gt; approach is not ideal. The first thought is
    that it should be replaced with reading &lt;code&gt;.py&lt;/code&gt; files into strings,
    but there are two issues with this:&lt;ol&gt;
&lt;li&gt;One benchmark file can have a lot of setup code and several key
    lines that need to actually be benched. This can be fixed using
    convensions (ie. setup functions and &lt;code&gt;bench_*&lt;/code&gt; functions) in the
    spirit of testing suites, or using&amp;nbsp;decorators.&lt;/li&gt;
&lt;li&gt;I would like to be able to run bench files as python scripts,
    but the vbench import system breaks this. This can be fixed by
    hijacking the imports when reading the&amp;nbsp;file.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our project has different dynamics than Pandas, so it&amp;#8217;s important that
the published results run on an independent machine, but it would be
great if an individual developer can run the benchmark himself while
coding but before pushing his changes upstream. Of course, his numbers
would only be comparable to the numbers he gets on his own machine
before his changes, but a developer shouldn&amp;#8217;t wait for the daily
benchmark for knowing if he made an&amp;nbsp;improvement.&lt;/p&gt;
&lt;p&gt;On the other hand there is &lt;a href="http://code.google.com/p/unladen-swallow/"&gt;unladen-swallow&lt;/a&gt;&amp;#8216;s &lt;a href="http://code.google.com/p/unladen-swallow/wiki/Benchmarks"&gt;benchmark system&lt;/a&gt;
using the [&lt;code&gt;perf.py&lt;/code&gt;][] file. I didn&amp;#8217;t try it out yet, so I would like
feedback, but there are some key things that can be taken from&amp;nbsp;them:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Memory usage&amp;nbsp;benchmarking&lt;/li&gt;
&lt;li&gt;Python scripts as benchmarks, with a simple but efficient Benchmark
    object&amp;nbsp;hierarchy&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What&amp;#8217;s missing&amp;nbsp;is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A system to remember previous results and compare them, similar to
    vbench&amp;#8217;s&amp;nbsp;database&lt;/li&gt;
&lt;li&gt;The ability to bench only an area of the code without rerunning the
    setup. (Not really sure whether vbench&amp;#8217;s way is actually&amp;nbsp;better)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;At a first glance, it seems that a very good system can be obtained by
combining these two excellent projects (or rather, improving vbench with
features from &lt;code&gt;perf.py&lt;/code&gt;). While I continue exploring this, I would like
to hear feedback from people who had to do with similar issues. As for
the GSoC timeline, I plan to join forces with Immanuel and design a
solid benchmark suite for the linear models over the next 2&amp;nbsp;weeks.&lt;/p&gt;
&lt;p&gt;[&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2012/05/P5280194-300x225.jpg" title="GSoC swag" /&gt;]:&amp;nbsp;http://localhost:8001/wp-content/uploads/2012/05/P5280194.jpg&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Tue, 29 May 2012 12:57:00 +0200</pubDate><guid>tag:vene.ro,2012-05-29:blog/first-contact-with-vbench.html</guid><category>benchmarks</category><category>perf.py</category><category>performance</category><category>vbench</category><category>scikit-learn</category></item><item><title>Support vector regression on Anscombe’s dataset</title><link>http://vene.ro/blog/support-vector-regression-on-anscombes-dataset.html</link><description>&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Anscombe's_quartet" title="Anscombe's quartet"&gt;Anscombe&amp;#8217;s quartet&lt;/a&gt; is a set of four toy datasets that look very
different, but many of their statistics coincide. They were developed by
Francis Anscombe as a striking visual to show that even for small
datasets, blindly examining their statistical properties without
considering their structure can&amp;nbsp;mislead.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Anscombe's datasets" src="http://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Anscombe%27s_quartet_3.svg/640px-Anscombe%27s_quartet_3.svg.png" /&gt;&lt;/p&gt;
&lt;p&gt;Particularly, the four datasets have the same &lt;a href="http://scikit-learn.org/stable/modules/linear_model.html#ordinary-least-squares" title="Ordinary least squares regression"&gt;least squares regression
line&lt;/a&gt;. While the second dataset is a clear example of a nonlinear
correlation which cannot be accurately captured by any linear model, the
third dataset is actually perfectly linear, with no noise, but just a
single outlier that shifts the regression line&amp;nbsp;considerably.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://scikit-learn.org/stable/modules/svm.html#regression" title="Support vector regression"&gt;Support vector regression&lt;/a&gt; is an extension of the support vector
machine idea to tackle the regression problem. It is based on the
observation that a &lt;span class="caps"&gt;SVM&lt;/span&gt; classifier builds its decision boundary as a
function of a (small) subset of training points. For regression, &lt;span class="caps"&gt;SVR&lt;/span&gt;
fits a &lt;em&gt;tube&lt;/em&gt; that is robust to noise within a width
[latex]\epsilon[/latex]. For this particular example, using a small
width makes the solution robust to the obvious outlier. For very small
but non-zero [latex]\epsilon[/latex], the solution is a combination of
the outlier and on two other points. For [latex]\epsilon=0[/latex], you
can see that every point except a non-outlier is highlighted. This is
actually the perfect solution but very&amp;nbsp;dense.&lt;/p&gt;
&lt;p&gt;[&lt;img alt="Support vector regression on Anscombe's third dataset with no
noise" src="" /&gt;][]&lt;/p&gt;
&lt;p&gt;Every frame displays the global mean squared error and the true mean
squared error, &lt;em&gt;i.e.&lt;/em&gt; over the inlying points. If the epsilon size is
well chosen, &lt;span class="caps"&gt;SVR&lt;/span&gt; can perform robustly with a sparse solution. Since our
interest was in avoiding the outlier, we assumed no noise in the inlying
data, so a very small epsilon is perfect. For real data a larger epsilon
is often useful because of variability in the data. When adding noise,
&lt;span class="caps"&gt;SVR&lt;/span&gt; still manages to avoid the outlier, but when the tube width becomes
zero, the solution is again very dense, very&amp;nbsp;non-parametric.&lt;/p&gt;
&lt;p&gt;[&lt;img alt="Support vector regression on Anscombe's third dataset with
noise" src="http://localhost:8001/wp-content/uploads/2012/05/svr_noise.gif" title="SVR on Anscombe's dataset with noise" /&gt;][]&lt;/p&gt;
&lt;p&gt;Here is the code you can use to play around with&amp;nbsp;this.&lt;/p&gt;
&lt;p&gt;[gist&amp;nbsp;id=2815589]&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;http://localhost:8001/wp-content/uploads/2012/05/svr.gif
&amp;quot;SVR on Anscombe&amp;#39;s dataset with no noise&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;[![Support vector regression on Anscombe&amp;#8217;s third dataset with no
  noise][]]: http://localhost:8001/wp-content/uploads/2012/05/svr.gif
  [![Support vector regression on Anscombe&amp;#8217;s third dataset with
  noise][]]:&amp;nbsp;http://localhost:8001/wp-content/uploads/2012/05/svr_noise.gif&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Sun, 27 May 2012 21:59:00 +0200</pubDate><guid>tag:vene.ro,2012-05-27:blog/support-vector-regression-on-anscombes-dataset.html</guid><category>anscombe</category><category>outlier</category><category>robust regression</category><category>support vector regression</category><category>svm</category><category>svr</category><category>python</category><category>scikit-learn</category></item><item><title>GSoC 2012 proposal: Need for scikit-learn speed</title><link>http://vene.ro/blog/gsoc-2012-proposal-need-for-scikit-learn-speed.html</link><description>&lt;p&gt;This summer I hope to be able to put in another full-time amount of
effort into scikit-learn. After a successful Google Summer of Code
project last year on dictionary learning, I now plan to do some
low-level work. The title of my proposal is: &amp;#8220;Need for scikit-learn
speed&amp;#8221; and, in a nutshell, will make the scikit go faster and will help
it stay that&amp;nbsp;way.&lt;/p&gt;
&lt;p&gt;Scikit-learn has always enforced standards of quality that kept all
implementations at a non-trivial level (i.e. faster than using &lt;a href="http://docs.scipy.org/doc/scipy/reference/optimize.html"&gt;the
generic optimizers in scipy&lt;/a&gt;). However, not all modules are equal:
some have received more attention for speed than others (for example the
&lt;span class="caps"&gt;SGD&lt;/span&gt; classes). I intend to raise the bar towards a more uniform&amp;nbsp;level.&lt;/p&gt;
&lt;h2&gt;Are you crazy, can you really do&amp;nbsp;this?&lt;/h2&gt;
&lt;p&gt;Well, of course. This might not the usual GSoC proposal, but I can show
how I can do it and how it&amp;#8217;s easily quantifiable. Actually, a very
important part of the work will be to make scikit-learn&amp;#8217;s speed easily&amp;nbsp;measurable.&lt;/p&gt;
&lt;p&gt;As for the specific speed-ups, I have shown &lt;a href="http://localhost:8001/2011/08/07/optimizing-orthogonal-matching-pursuit-code-in-numpy-part-1/" title="Optimizing Orthogonal Matching Pursuit code in Numpy, part 1"&gt;in&lt;/a&gt; &lt;a href="http://localhost:8001/2011/08/11/optimizing-orthogonal-matching-pursuit-code-in-numpy-part-2/" title="Optimizing Orthogonal Matching Pursuit code in Numpy, part 2"&gt;the&lt;/a&gt; &lt;a href="http://localhost:8001/2011/11/18/the-nasty-bug-crawling-in-my-orthogonal-matching-pursuit-code/" title="The nasty bug crawling in my Orthogonal Matching Pursuit code"&gt;past&lt;/a&gt; that
I can do algorithmic and memory layout optimizations in numerical code.
There are parts in the scikit-learn that can benefit from such work: for
example only recently Peter merged this &lt;a href="https://github.com/scikit-learn/scikit-learn/pull/545"&gt;pull request&lt;/a&gt; significantly
improving SGDClassifier&amp;#8217;s test time performance by switching the memory
layout of the coefficients: they were laid out optimally for the
training phase, not for the prediction&amp;nbsp;phase.&lt;/p&gt;
&lt;p&gt;There are certainly more opportunities for such speed improvements in
the scikit. Of course there is a lot of code that can&amp;#8217;t reasonably be
made any faster (I have a feeling that SGDClassifier is at the moment
such a case, but we can&amp;#8217;t know for sure without heavy profiling). But
generally there are many speed fixes that could weigh a lot: for
example, a &lt;a href="http://cython.org/"&gt;Cython&lt;/a&gt; implementation of the &lt;code&gt;euclidean_distances&lt;/code&gt;
function that is able to use preallocated memory will improve the
performance of raw NearestNeighbours queries as well as of the KMeans
and hierarchical clustering&amp;nbsp;algorithms.&lt;/p&gt;
&lt;h2&gt;How will we be able to tell if you&amp;nbsp;succeed?&lt;/h2&gt;
&lt;p&gt;A key part of the GSoC project is setting up a
&lt;abbr title="Continuous Integration"&gt;&lt;span class="caps"&gt;CI&lt;/span&gt;&lt;/abbr&gt;-style benchmark platform.
The point is to be able to track how the speed of certain operations
evolves in time. For such purposes, Wes McKinney developed the
&lt;a href="https://github.com/pydata/vbench"&gt;vbench&lt;/a&gt; project, introduced in &lt;a href="http://wesmckinney.com/blog/?p=373"&gt;this blog post&lt;/a&gt;. The goal is for
every scikit-learn module to have several such benchmarks, for
differently shaped and structured&amp;nbsp;data.&lt;/p&gt;
&lt;p&gt;Having such a benchmark suite available is the equivalent of a test
suite, in terms of performance. It makes developers be extra conscious
of the effect of their changes. It also makes it more fun to chase speed
improvements, thanks to the positive reinforcement it&amp;nbsp;gives.&lt;/p&gt;
&lt;p&gt;There are some static benchmarks comparing the performance of
scikit-learn algorithms with other well-known libraries in the
&lt;a href="http://scikit-learn.sourceforge.net/ml-benchmarks/"&gt;ml-benchmarks&lt;/a&gt; project. It would be very helpful to have such a
benchmark suite that automatically keeps&amp;nbsp;up-to-date.&lt;/p&gt;
&lt;h2&gt;Side&amp;nbsp;effects&lt;/h2&gt;
&lt;p&gt;The cool thing about such a project is that it should raise the overall
quality of the scikit. The refactoring will lead to an increase in test
coverage, because the low-coverage modules are expected to be less
optimized as well. Also, the benchmarks will lead to well-backed
summaries in the documentation, such as &lt;a href="http://scikit-learn.org/dev/modules/clustering.html#overview-of-clustering-methods"&gt;the one recently added in the
clustering section&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Since the scikit is reaching a state where many well-known algorithms
are available, the &lt;strong&gt;1.0&lt;/strong&gt; release is slowly approaching. My Google
Summer of Code project should bring the scikit significantly closer to
that&amp;nbsp;milestone.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Mon, 16 Apr 2012 00:37:00 +0200</pubDate><guid>tag:vene.ro,2012-04-16:blog/gsoc-2012-proposal-need-for-scikit-learn-speed.html</guid><category>gsoc</category><category>proposal</category><category>scikit-learn</category></item><item><title>Romanian people and coffee</title><link>http://vene.ro/blog/romanian-people-and-coffee.html</link><description>&lt;p&gt;So I got my hands of the &lt;a href="http://googleresearch.blogspot.com/2006/08/all-our-n-gram-are-belong-to-you.html" title="Google Research"&gt;Google N-gram data&lt;/a&gt; for the Romanian
language. It&amp;#8217;s noisy as hell, has some other subtle issues too, but
here&amp;#8217;s the first thing I&amp;nbsp;noticed:&lt;/p&gt;
&lt;p&gt;The Romanian word for coffee is &lt;em&gt;cafea&lt;/em&gt;, and the more you crave it, the
longer you pronunce the final &lt;em&gt;a&lt;/em&gt;: I really need some &lt;em&gt;cafeaaaa&lt;/em&gt; right&amp;nbsp;now.&lt;/p&gt;
&lt;p&gt;Thanks to Google, here are the&amp;nbsp;numbers:&lt;/p&gt;
&lt;p&gt;[![Distribution of the length of the final letter in the Romanian word
for&amp;nbsp;coffee.][]][]&lt;/p&gt;
&lt;p&gt;Post scriptum: I hope you like the theme: I installed the &lt;a href="http://www.huyng.com/posts/sane-color-scheme-for-matplotlib/" title="www.huyng.com/posts/sane-color-scheme-for-matplotlib"&gt;sane
matplotlib color scheme&lt;/a&gt; from Huy&amp;nbsp;Nguyen.&lt;/p&gt;
&lt;p&gt;[Distribution of the length of the final letter in the Romanian word
  for coffee.]: http://localhost:8001/wp-content/uploads/2012/04/cafeaaa-300x218.png
    &amp;#8220;cafeaaa&amp;#8221;
  [![Distribution of the length of the final letter in the Romanian word
  for coffee.][]]:&amp;nbsp;http://localhost:8001/wp-content/uploads/2012/04/cafeaaa.png&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Fri, 13 Apr 2012 21:20:00 +0200</pubDate><guid>tag:vene.ro,2012-04-13:blog/romanian-people-and-coffee.html</guid><category>Uncategorized</category><category>coffee</category><category>ngram</category></item><item><title>Nash-Williams theorem on the Hamiltonian property of some regular graphs</title><link>http://vene.ro/blog/nash-williams-theorem-on-the-hamiltonian-property-of-some-regular-graphs.html</link><description>&lt;p&gt;I have been digging on the internet for the proof of this theorem for
the last couple of days without success. The result was published by Sir
Crispin Nash-Williams as &lt;em&gt;Valency Sequences which force graphs to have
Hamiltonian Circuits&lt;/em&gt;. Interim Rep, University of Waterloo Res Rep.,
Waterloo, Ontario, 1969. However, this old paper is unavailable online
but I have a proof in some lecture notes from my class, that I want to
share&amp;nbsp;here.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theorem.&lt;/strong&gt; Let [latex]G=(V, E)[/latex] be an [latex]n[/latex]-regular
graph with [latex]|V| = 2n + 1[/latex]. Then, [latex]G[/latex] is&amp;nbsp;Hamiltonian.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proof.&lt;/strong&gt; We first remark that [latex]n[/latex] must be even, since
\$\$\sum_{x \in V} d(x) = n(2n + 1) = 2|E|\$\$ We might try to apply
Dirac&amp;#8217;s theorem, which would give us a Hamiltonian cycle if [latex]
\forall x \in V, d(x) \geq \frac{|V|}{2}[/latex]. But in the current
case, [latex]\forall x \in V, d(x) = n \&amp;lt;&amp;nbsp;\frac{2n+1}{2}[/latex].&lt;/p&gt;
&lt;p&gt;So we force Dirac by adding an extra vertex [latex]w[/latex] and
connecting it to all [latex] x \in V [/latex]. In this new graph
[latex]G&amp;#8217;[/latex], [latex]d(x) = n + 1 \forall x \in V[/latex] and
[latex]d(w) = 2n + 1[/latex]. Therefore we have a Hamiltonian cycle that
passes through [latex]w[/latex] and in which, [latex]w[/latex] is
adjacent to two vertices [latex]x[/latex] and [latex]y \in V[/latex].
Therefore this cycle induces a Hamiltonian path in [latex]G[/latex]:
\$\$P = [x = v_0, v_1, &amp;#8230;, v_{2n-1}, v_{2n}=y]&amp;nbsp;\$\$&lt;/p&gt;
&lt;p&gt;Suppose that [latex]G[/latex] is not Hamiltonian. It follows that if
[latex] v_0v_i \in E [/latex], then [latex] v_{i-1}v_{2n} \notin
E[/latex] and also that if [latex] v_0v_i \notin E [/latex], then
[latex] v_{i-1}v_{2n} \in&amp;nbsp;E[/latex].&lt;/p&gt;
&lt;p&gt;We have two cases. If [latex]v_0[/latex] is adjacent to [latex]v_1,
&amp;#8230;, v_n[/latex] then it follows that [latex]v_{2n}[/latex] is
adjacent to [latex]v_n, v_{n+1}, &amp;#8230;, v_{2n-1}[/latex], since it
cannot be adjacent to any [latex]v_i, i \&amp;lt; n[/latex] without creating a
Hamiltonian cycle. But in this case, in the graph induced by the first
half [latex]G[\{v_0, v_1, &amp;#8230; v_n\}][/latex], [latex]v_n[/latex]
cannot be adjacent to all the others, since in [latex]G[/latex] it has
degree [latex]n[/latex] and it already has [latex]2[/latex] outgoing
edges. So there is at least one vertex [latex]v_i, i \&amp;lt; n[/latex] that
isn&amp;#8217;t adjacent to it, which means [latex]v_i[/latex] is adjacent to
some [latex]v_j, j &gt; n[/latex], thus forming a Hamiltonian&amp;nbsp;cycle.&lt;/p&gt;
&lt;p&gt;In the second case, we have a vertex [latex]v_i, 2 \leq i \leq 2n -
1[/latex] such that [latex]v_0v_i \notin E[/latex] and
[latex]v_0v_{i+1} \in E[/latex]. This also means that
[latex]v_{i-1}v_{2n} \in&amp;nbsp;E[/latex].&lt;/p&gt;
&lt;p&gt;We therefore have a cycle of length [latex]2n[/latex] in
[latex]G[/latex] that excludes [latex]v_i[/latex]. Let&amp;#8217;s rename this
cycle [latex]C=[y_1, y_2, &amp;#8230;, y_{2n}, y_1][/latex] and&amp;nbsp;[latex]v_i=y_0[/latex].&lt;/p&gt;
&lt;p&gt;[latex]y_0[/latex] cannot be adjacent to two consecutive vertices
[latex]y_i[/latex] and [latex]y_{i+1}[/latex] because this will give a
Hamiltonian cycle. But we know that [latex]deg(y_0) = n[/latex]. It
follows that it&amp;#8217;s adjacent to all of the even or odd numbered vertices.
We assume the latter, without loss of generality. Let [latex]2k[/latex]
be some even index. Notice that we have [latex]\{y_0y_{2k-1},
y_0y_{2k+1}\} \subset E[/latex] and we can follow the cycle
[latex]C[/latex] from [latex]y_{2k+1}[/latex] all the way back to
[latex]y_{2n-1}[/latex] giving us a new cycle [latex]C&amp;#8217; = [y_1, y_2,
&amp;#8230;, y_{2n-1}, y_0, y_{2k+1}, &amp;#8230;, y_{2n}, y_1][/latex] also of
length [latex]2n[/latex]. So by repeating the same reasoning for every
even vertex, by placing it in the middle and building a cycle around it,
it follows that every even vertex is adjacent to all the odd vertices.
But there are [latex]n+1[/latex] even indices, so it follows that the
degree of any odd vertex is at least [latex]n+1[/latex], contradicting
the initial conditions of the theorem.&amp;nbsp;[latex]\square[/latex]&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Sun, 29 Jan 2012 22:31:00 +0100</pubDate><guid>tag:vene.ro,2012-01-29:blog/nash-williams-theorem-on-the-hamiltonian-property-of-some-regular-graphs.html</guid><category>graph</category><category>graph theory</category><category>hamiltonian</category><category>nash-williams</category><category>Uncategorized</category></item><item><title>Moving out</title><link>http://vene.ro/blog/moving-out.html</link><description>&lt;p&gt;Happy new year,&amp;nbsp;friends!&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ve made a New Year&amp;#8217;s resolution to build a better web presence and
make better use of the domain that I previously only used for&amp;nbsp;mail.&lt;/p&gt;
&lt;p&gt;This has prompted me to move my blog over to http://localhost:8001 which
hopefully is shorter, better, faster and&amp;nbsp;stronger!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Fri, 06 Jan 2012 00:16:00 +0100</pubDate><guid>tag:vene.ro,2012-01-06:blog/moving-out.html</guid><category>Uncategorized</category></item><item><title>The nasty bug crawling in my Orthogonal Matching Pursuit code</title><link>http://vene.ro/blog/the-nasty-bug-crawling-in-my-orthogonal-matching-pursuit-code.html</link><description>&lt;p&gt;A while back, Bob L. Sturm blogged about a &lt;a href="http://media.aau.dk/null_space_pursuits/2011/10/efficient-omp.html"&gt;similar implementation of
&lt;span class="caps"&gt;OMP&lt;/span&gt;&lt;/a&gt; to the one in scikit-learn. Instead of using the Cholesky
decomposition like we did, his Matlab code uses the &lt;span class="caps"&gt;QR&lt;/span&gt; decomposition, to
a similar (or maybe even identical) outcome, in theory. So lucky that
Alejandro pointed out to him the existence of the scikit-learn
implementation, and that Bob&amp;#8217;s code &lt;a href="http://media.aau.dk/null_space_pursuits/2011/10/omp-in-python-strange-results.html"&gt;exposed a bug&lt;/a&gt; that all the test
coverage didn&amp;#8217;t catch! This plot should increase, certainly not
decrease! Something is clearly wrong here.&lt;br /&gt;
&lt;a href="http://media.aau.dk/null_space_pursuits/2011/10/omp-in-python-strange-results.html"&gt;&lt;img alt="OMP buggy phase transition, decreasing instead of
increasing" src="http://media.aau.dk/null_space_pursuits/2011/10/17/OMPscikit.png" title="OMP buggy phase transition" /&gt;&lt;/a&gt;&lt;br /&gt;
Luckily we were able to find it and &lt;a href="http://media.aau.dk/null_space_pursuits/2011/10/to-the-rescue.html"&gt;fix it&lt;/a&gt; very quickly. I have
updated the old entries I wrote on the &lt;span class="caps"&gt;OMP&lt;/span&gt; optimizations, so they no
longer include the bug. But I take this opportunity to explain what
exactly went&amp;nbsp;wrong.&lt;/p&gt;
&lt;p&gt;A key part of the optimization was that slicing out arbitrary columns
out of an array is slow when they are passed to &lt;span class="caps"&gt;BLAS&lt;/span&gt; functions like
matrix multiplication. In order to make the most out of your code, the
data should have a contiguous layout. We achieved this by swapping
active dictionary atoms (columns) to the beginning of the&amp;nbsp;array.&lt;/p&gt;
&lt;p&gt;Something that can happen, but won&amp;#8217;t happen very often, is that after an
atom is selected as active, the atom that takes its place after swapping
needs to be selected. This is rare because dictionaries have many
columns, out of which only very very few will be active. But when it
happens, because the code didn&amp;#8217;t keep track of swapped indices, the
corresponding coefficient of the solution would get updated twice,
leading to more zero entries than we should have. A keen eye could have
noticed that the first `n_nonzero_coefs` entries in &lt;span class="caps"&gt;OMP&lt;/span&gt; solution
vectors were never non-zero. But alas, my eye was not a keen one at&amp;nbsp;all.&lt;/p&gt;
&lt;p&gt;In other words, the following test (that was written after the bug was
found, unfortunately) was failing:&lt;br /&gt;
[sourcecode lang=&amp;#8221;Python&amp;#8221;]&lt;br /&gt;
def test_swapped_regressors():&lt;br /&gt;
gamma = np.zeros(n_features)&lt;br /&gt;
# X[:, 21] should be selected first, then X[:, 0] selected second,&lt;br /&gt;
# which will take X[:, 21]&amp;#8217;s place in case the algorithm does&lt;br /&gt;
# column swapping for optimization (which is the case at the moment)&lt;br /&gt;
gamma[21] = 1.0&lt;br /&gt;
gamma[0] = 0.5&lt;br /&gt;
new_y = np.dot(X, gamma)&lt;br /&gt;
new_Xy = np.dot(X.T, new_y)&lt;br /&gt;
gamma_hat = orthogonal_mp(X, new_y, 2)&lt;br /&gt;
gamma_hat_gram = orthogonal_mp_gram(G, new_Xy, 2)&lt;br /&gt;
# active indices should be [0, 21], but prior to the bugfix&lt;br /&gt;
# the algorithm would update only [21] but twice&lt;br /&gt;
assert_equal(np.flatnonzero(gamma_hat), [0, 21])&lt;br /&gt;
assert_equal(np.flatnonzero(gamma_hat_gram), [0, 21])&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Note that this bug has been fixed for a while, but I didn&amp;#8217;t get the free
time to write this post until now. Good news is: we fixed it, and did so
very quickly after the report. So you can still trust me, I&amp;nbsp;guess!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Fri, 18 Nov 2011 20:51:00 +0100</pubDate><guid>tag:vene.ro,2011-11-18:blog/the-nasty-bug-crawling-in-my-orthogonal-matching-pursuit-code.html</guid><category>bug</category><category>omp</category><category>orthogonal matching pursuit</category><category>dictionary learning</category><category>scikit-learn</category></item><item><title>Sampling Gamma random variates through the ratio-of-uniforms method</title><link>http://vene.ro/blog/sampling-gamma-random-variates-through-the-ratio-of-uniforms-method.html</link><description>&lt;p&gt;One year ago I had the chance to take a class on Monte Carlo simulation
with prof. Ion Văduva, and my assignment for the class was to implement
exactly what it says in the title of the blog post. I am going to walk
you through the idea behind&amp;nbsp;this.&lt;/p&gt;
&lt;h3&gt;General&amp;nbsp;formulation&lt;/h3&gt;
&lt;p&gt;The ratio-of-uniforms is a method that can be applied to many density
functions. Essentially, given a density function over [latex]
\mathbb{R}\^m[/latex], [latex] f(x) = \frac{h(x)}{H}[/latex] where
[latex]H[/latex] is a normalization constant (ie. [latex] h(x) \geq
0[/latex], [latex] H = \int h(x)dX[/latex]). Given a parameter [latex]
c &gt; 0 [/latex] and a parametrization [latex]\phi[/latex] from [latex]
\mathbb{R}\^{m+1}[/latex] to [latex] \mathbb{R}\^{m}[/latex] expressed
as: \$\$ \phi(v_0, v_1, &amp;#8230;, v_m) = \left ( \frac{v_1}{v_0\^c},
\frac{v_2}{v_0\^c}, &amp;#8230;, \frac{v_m}{v_0\^c} \right )\$\$&lt;br /&gt;
Define the set [latex] \mathcal{C} = \{\mathbf{v} \big |
\gamma(\mathbf{v}) \leq 0, v_0 &gt; 0\} \in
\mathbb{R}\^{m+1}[/latex] where&lt;br /&gt;
\$\$\gamma(\mathbf{v}) = \log v_0 - \frac{\log h(\phi(v_0,
v_1, &amp;#8230;, v_m))}{mc + 1}\$\$ If [latex] \mathcal{C}[/latex] is
bounded and we sample a uniform vector [latex] \mathbf{V} \sim
\text{Uniform}(\mathcal{C})[/latex] then [latex] \phi(\mathbf{V})
\sim f(x)[/latex]. Also note that the measure (volume) of the set
[latex] \mathcal{C}[/latex] is [latex] \frac{H}{mc + 1}[/latex]. I do
not have any references for the proof, except for a book in Romanian,
but if you are interested, just leave me a comment and I&amp;#8217;ll do a
follow-up post with the&amp;nbsp;proofs.&lt;/p&gt;
&lt;h3&gt;Univariate&amp;nbsp;scenario&lt;/h3&gt;
&lt;p&gt;For the univariate case, all the above simplifies to \$\$ \mathcal{C} =
\left \{(u, v) \Big | 0 \&amp;lt; u \&amp;lt; \sqrt&lt;br /&gt;
{h\left (\frac{v}{u\^c}\right )} \right \} \$\$. We generate
[latex] (U, V) \sim \text{Uniform}(\mathcal{C})[/latex] and take
[latex] \frac{V}{U\^c} \sim f(x)[/latex].&lt;br /&gt;
Since we are looking at the (univariate) Gamma distribution, described
by: \$\$ f(x; \nu, \theta) = \frac{x\^{\mu - 1}
\exp(\frac{-x}{\theta})}{\theta\^k\Gamma(k)}\$\$ [latex]
\nu[/latex] is the shape parameter and [latex] \theta[/latex] is the
scale parameter.&lt;br /&gt;
But because of the property that if [latex] X \sim \text{Gamma}(\nu,
\theta)[/latex], then for any [latex] k &gt; 0[/latex], [latex] kX \sim
\text{Gamma}(\nu, k\theta)[/latex], we conclude that we can fix
[latex] \theta[/latex] to 1 without loss of generality. Replacing in
the style of the definition in the previous section, we have [latex]
h(x; \nu) = x\^{\nu-1}e\^{-x}[/latex] and [latex] H_\nu =
\Gamma(\nu)[/latex].&lt;br /&gt;
This allows us to compute the equation of the boundary of the set
[latex] \mathcal{C}[/latex] which ends up being described by
[latex]\gamma(u, v) = \log{u} - \frac{\nu - 1}{c + 1}
\log{\left(\frac{v}{u\^c}\right)} + \frac{1}{c+1}
\frac{v}{u\^c}[/latex]. For visualisation purposes, here is how it
would look like for [latex] \nu=6, c=1[/latex] (plotted using &lt;a href="http://www.wolframalpha.com/" title="Wolfram Alpha"&gt;Wolfram
Alpha&lt;/a&gt;):[&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2011/10/regiunea.png" title="The accepting set C" /&gt;][]&lt;/p&gt;
&lt;h3&gt;Sampling&amp;nbsp;algorithm&lt;/h3&gt;
&lt;p&gt;In order to uniformly sample from this set, we can apply basic rejection
sampling: just uniformly sample from a rectangular region surrounding
the set, and reject the points that do not satisfy the condition. In
order to do this as efficiently as possible, we need to compute the
minimal bounding box, which can be done by solving a couple of
optimization problems using Lagrange multipliers and the &lt;span class="caps"&gt;KKT&lt;/span&gt; conditions.
Also by looking closely at the image, you can see that the lower left
corner is exactly the origin: this turns out not to be a coincidence. I
won&amp;#8217;t go into detail here, but here are the bounds I derived:&lt;br /&gt;
\$\$ 0 \&amp;lt; u \&amp;lt; (\nu - 1)\^\frac{\nu - 1}{c + 1} e \^ {-\frac{\nu -
1}{c + 1}} \text{ and } 0\&amp;lt; v \&amp;lt; \left(\frac{c\nu +
1}{c}\right)\^{\frac{c\nu + 1}{c + 1}} e \^ {- \frac {c\nu +&amp;nbsp;1}{c+1}}\$\$&lt;/p&gt;
&lt;p&gt;The probability of acceptance (which can be seen as the efficiency) of
the rejection sampling method is given by the ratio of the areas of the
set [latex] \mathcal{C}[/latex] and the bounding box. The larger this
probability, the less points we throw away and the more efficient the
algorithm is. Using the values derived above, this probability is: \$\$
p(\nu, c) = \frac{\Gamma(\nu)e\^{\nu}}{(c+1) (\nu -
1)\^{\frac{\nu - 1}{c + 1}} \left(\frac{c\nu +
1}{c}\right)\^{\frac{c\nu + 1}{c +&amp;nbsp;1}}}\$\$&lt;/p&gt;
&lt;p&gt;Personally I got stumped here. The idea would be to determine the ideal
[latex] c[/latex] for a given [latex] \nu[/latex] in order to maximize
the probability, but I didn&amp;#8217;t manage to do it (I leave it as an exercise
for the reader ;)). Anyway, this is enough to proceed with an
implementation, so I&amp;#8217;m gonna give the Python code for it. Note that I
used the name k for the shape parameter instead of [latex] \nu[/latex].
Also note that the case when [latex] 0 \&amp;lt; \nu \&amp;lt; 1[/latex] needed to be
treated separately, which I did using the following property: Let
[latex] \nu \in (0, 1)[/latex]. If [latex] X&amp;#8217; \sim
\text{Gamma}(1+\nu, 1), U \sim \text{Uniform}(0, 1)[/latex] then
\$\$ X = X&amp;#8217; \cdot \sqrt[\nu]{U} \sim \text{Gamma}(\nu, 1)\$\$ For
a proof of this fact, see [&lt;a href="#footnote-1"&gt;1&lt;/a&gt;], which is a great article on
generating Gamma&amp;nbsp;variates.&lt;/p&gt;
&lt;h3&gt;Implementation&lt;/h3&gt;
&lt;p&gt;[sourcecode language=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
from import numpy as&amp;nbsp;np&lt;/p&gt;
&lt;p&gt;def _cond(u, v, k, c):&lt;br /&gt;
&amp;#8220;&amp;#8221;&amp;#8220;Identity function describing the acceptance region&amp;#8221;&amp;#8220;&amp;#8221;&lt;br /&gt;
x = v / u ** c&lt;br /&gt;
return (c + 1) * np.log(u) \&amp;lt;= (k - 1) * np.log(x) -&amp;nbsp;x&lt;/p&gt;
&lt;p&gt;def vn_standard_gamma(k, c=1.0, rng=np.random):&lt;br /&gt;
&amp;#8220;&amp;#8221;&amp;#8220;Generates a single standard gamma random variate&amp;#8221;&amp;#8220;&amp;#8221;&lt;br /&gt;
if k \&amp;lt;= 0:&lt;br /&gt;
raise ValueError(&amp;#8220;Gamma shape should be positive&amp;#8221;)&lt;br /&gt;
elif k \&amp;lt; 1:&lt;br /&gt;
return vn_standard_gamma(1 + k, c, rng) * rng.uniform() ** (1 /
k)&lt;br /&gt;
elif k == 1:&lt;br /&gt;
return rng.standard_exponential()&lt;br /&gt;
else:&lt;br /&gt;
a, b = get_bounds(k, c)&lt;br /&gt;
while True:&lt;br /&gt;
u, v = rng.uniform(0, a), rng.uniform(0, b)&lt;br /&gt;
if _cond(u, v, k, c):&lt;br /&gt;
break;&lt;br /&gt;
return v / u **&amp;nbsp;c&lt;/p&gt;
&lt;p&gt;def vn_gamma(k, t, shape=1, c=1.0, rng=np.random):&lt;br /&gt;
&amp;#8220;&amp;#8221;&amp;#8220;Vectorized function to generate multiple gamma variates&amp;#8221;&amp;#8220;&amp;#8221;&lt;br /&gt;
generator = lambda x: t * vn_standard_gamma(k, c, rng)&lt;br /&gt;
generator = np.vectorize(generator)&lt;br /&gt;
return&amp;nbsp;generator(np.empty(shape))&lt;/p&gt;
&lt;p&gt;def get_bounds(k, c=1.0):&lt;br /&gt;
&amp;#8220;&amp;#8221;&amp;#8220;Computes the minimal upper bounds surrounding the acceptance
region&amp;#8221;&amp;#8220;&amp;#8221;&lt;br /&gt;
a = ((k - 1) / np.e) ** ((k - 1) / (c + 1))&lt;br /&gt;
b = ((c * k + 1) / (c * np.e)) ** ((c * k + 1) / (c + 1))&lt;br /&gt;
return a,&amp;nbsp;b&lt;/p&gt;
&lt;p&gt;def prob_acc(k, c=1.0):&lt;br /&gt;
&amp;#8220;&amp;#8221;&amp;#8220;Calculates the probability of acceptance for the given
parameters&amp;#8221;&amp;#8220;&amp;#8221;&lt;br /&gt;
from scipy.special import gamma&lt;br /&gt;
a, b = get_bounds(k, c)&lt;br /&gt;
return gamma(k) / ((c + 1) * a * b)&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;h3&gt;Results&lt;/h3&gt;
&lt;p&gt;And of course I should show you that it works. Here are some histograms
for various values of [latex] \nu[/latex], with the theoretical density
plotted in dotted red, after sampling [latex] 10\^5[/latex] values. The
y-axis is the frequency (sorry for labeling in Romanian), and for the
red dotted line it can be interpreted as the theoretical probability.
You can clearly see the goodness of fit is&amp;nbsp;excellent.&lt;/p&gt;
&lt;p&gt;[&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2011/10/hist1.png" title="Histogram for nu=6" /&gt;][][&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2011/10/hist2.png" title="Histogram for nu=100" /&gt;][][&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2011/10/hist3.png" title="Histogram for nu=0.66" /&gt;][]&lt;/p&gt;
&lt;p&gt;&lt;span id="footnote-1"&gt;&lt;a href="#footnote-1"&gt;1&lt;/a&gt;&lt;/span&gt;: George Marsaglia and Wai Wan Tsang.
1998. &lt;a href="http://www.jstatsoft.org/v03/i03/paper"&gt;The Monty Python method for generating random variables&lt;/a&gt;. &lt;span class="caps"&gt;ACM&lt;/span&gt;
Trans. Math. Softw. 24, 3 (September 1998), 341-350.
&lt;a href="http://doi.acm.org/10.1145/292395.292453"&gt;&lt;span class="caps"&gt;DOI&lt;/span&gt;=10.1145/292395.292453&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2011/10/regiunea.png" title="The accepting set C" /&gt;]: http://localhost:8001/wp-content/uploads/2011/10/regiunea.png
  [&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2011/10/hist1.png" title="Histogram for nu=6" /&gt;]: http://localhost:8001/wp-content/uploads/2011/10/hist1.png
  [&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2011/10/hist2.png" title="Histogram for nu=100" /&gt;]: http://localhost:8001/wp-content/uploads/2011/10/hist2.png
  [&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2011/10/hist3.png" title="Histogram for nu=0.66" /&gt;]:&amp;nbsp;http://localhost:8001/wp-content/uploads/2011/10/hist3.png&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Sun, 09 Oct 2011 15:40:00 +0200</pubDate><guid>tag:vene.ro,2011-10-09:blog/sampling-gamma-random-variates-through-the-ratio-of-uniforms-method.html</guid><category>monte carlo</category><category>numpy</category><category>random sampling</category><category>ratio-of-uniforms</category><category>scipy</category><category>python</category></item><item><title>RANLP 2011 in Hissar, BG</title><link>http://vene.ro/blog/ranlp-2011-in-hissar-bg.html</link><description>&lt;p&gt;Last week was marked by the international &lt;span class="caps"&gt;RANLP&lt;/span&gt; (Recent Advances in
Natural Language Processing) conference, taking place in a nice spa in
Hissar, Bulgaria. The excellent folks from the &lt;a href="http://clg.wlv.ac.uk/"&gt;computational
linguistics group&lt;/a&gt; at the University of Wolverhampton were behind it,
together with the &lt;a href="http://www.iict.bas.bg/EN/index.html"&gt;Institute of Information and Communication
Technologies&lt;/a&gt; from the Bulgarian Academy of Sciences.&lt;br /&gt;
[caption id=&amp;#8221;attachment_247&amp;#8221; align=&amp;#8221;alignleft&amp;#8221; width=&amp;#8221;225&amp;#8221; caption=&amp;#8221;
&amp;#8220;][&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2011/09/319030_10150303323328171_677848170_8151131_1046590975_n1.jpg?w=225" title="Warm spring in Hissar" /&gt;][]&lt;/p&gt;
&lt;p&gt;A fountain with warm mineral spring water in Hissarya. &lt;br /&gt;
&lt;small&gt;Picture by &lt;a href="http://pers-www.wlv.ac.uk/~ex0233/" title="Miranda Chong"&gt;Miranda&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;[/caption]&lt;br /&gt;
I must begin by thanking them: the organization was impeccable! I&amp;#8217;m not
sure, but I think that at one point Ivelina was even running around
buying routers to improve wifi coverage (which is already spectacular in
Bulgaria &amp;#8212; I&amp;#8217;ve received reports from &lt;a href="http://pers-www.wlv.ac.uk/~ex0233/" title="Miranda Chong"&gt;Miranda&lt;/a&gt; that you can get wifi
in the&amp;nbsp;mountains!)&lt;/p&gt;
&lt;p&gt;The schedule was busy, with three tracks going in parallel, in order to
cover a wide range of topics in computational linguistics. The student
workshop should also be noted for the excellent quality of the works&amp;nbsp;there.&lt;/p&gt;
&lt;p&gt;Of course it would be infeasible to write about all the great people I
met and their high quality work. And if I were to write about all the
fun we had, it would probably make this post look unprofessional :).
This doesn&amp;#8217;t mean I forgot about any of you, and as soon as I get the
chance to work on something related, I will most certainly write about
it, and&amp;nbsp;you.&lt;/p&gt;
&lt;p&gt;So, if I would have to summarize the trends and the ideas stated during
the conference and especially during the keynotes, I would&amp;nbsp;say:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When talking about word sense disambiguation, it&amp;#8217;s wrong to speak
    about the different meanings of a word, but rather about the
    potential a word has for bringing a certain meaning in a certain
    context. See &lt;a href="http://www.patrickhanks.com/"&gt;Patrick Hanks&lt;/a&gt;&amp;#8216; &lt;a href="http://nlp.fi.muni.cz/projects/cpa/"&gt;Corpus Pattern Analysis&lt;/a&gt;. Without
    something like this, to have good &lt;span class="caps"&gt;WSD&lt;/span&gt; you need to heavily adjust the
    overlapping meanings from a Wordnet-style&amp;nbsp;ontology.&lt;/li&gt;
&lt;li&gt;Certain relations, such as temporal and spacial ones, can naturally
    be modeled by complex domain-specific logics (see [Inderjeet
    Mani][]&amp;#8217;s new book, Interpreting Motion: Grounded Representations
    for Spatial Language, that is due for publishing). But these only
    appear in a small subset of human communication. The attempt to map
    human language to a complete logic in which to do general-purpose
    inference seems futile: &lt;a href="http://u.cs.biu.ac.il/~dagan/"&gt;Ido Dagan&lt;/a&gt; suggests textual entailment:
    reasoning directly in natural language, and only abstracting away to
    a formal logic system when need&amp;nbsp;arises.&lt;/li&gt;
&lt;li&gt;If you have a large enough sample of n-gram frequency data, you can
    eventually beat the performance you can get with a limited amount of
    labeled data, and most importantly: it generalizes much better when
    going out of the domain you trained on. Apparently the best tool for
    this at the moment is the &lt;a href="http://ngrams.googlelabs.com/datasets"&gt;Google n-gram data&lt;/a&gt;, which has some
    limitations. In time, we can easily extend this data by huge amounts
    by mining n-grams from Wikipedia (which allegedly has a higher count
    of distinct n-grams than the Google dataset), and more importantly,
    by aligning multi-language data, making use of transliterations and
    cognate&amp;nbsp;identification.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Please note that I may be (or most probably, am) ignorant of older
instances of similar ideas, and I may have misunderstood certain claims.
Please feel free to discuss in the comments whether you think I forgot
about something important, or whether I am plain wrong about something.
In particular, I seem to have been completely ignorant of the existence
of the Google n-gram data, which has been around for quite a while, so I
must have missed other important things as&amp;nbsp;well.&lt;/p&gt;
&lt;p&gt;Take care, kind readers, and express your opinion!&lt;br /&gt;&amp;nbsp;V&lt;/p&gt;
&lt;p&gt;[&lt;img alt="" src="http://localhost:8001/wp-content/uploads/2011/09/319030_10150303323328171_677848170_8151131_1046590975_n1.jpg?w=225" title="Warm spring in Hissar" /&gt;]:&amp;nbsp;http://localhost:8001/wp-content/uploads/2011/09/319030_10150303323328171_677848170_8151131_1046590975_n1.jpg&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Tue, 20 Sep 2011 14:17:00 +0200</pubDate><guid>tag:vene.ro,2011-09-20:blog/ranlp-2011-in-hissar-bg.html</guid><category>conferences</category><category>nlp</category></item><item><title>Dictionary learning in scikit-learn 0.9</title><link>http://vene.ro/blog/dictionary-learning-in-scikit-learn-0-9.html</link><description>&lt;p&gt;Thanks to Olivier, Gaël and Alex, who reviewed the code heavily the last
couple of days, and with apologies for my lack of activity during a
sequence of conferences, Dictionary learning has officially been merged
into scikit-learn master, and just in time for the new scikit-learn 0.9
release. Here are some glimpses of the examples you can run for&amp;nbsp;yourself:&lt;/p&gt;
&lt;p&gt;[&lt;img alt="Dictionary learned from Lena patches" src="http://localhost:8001/wp-content/uploads/2011/09/plot_image_denoising_1.png" title="plot_image_denoising_1" /&gt;][]&lt;/p&gt;
&lt;p&gt;[&lt;img alt="Noisy image for denoising" src="http://localhost:8001/wp-content/uploads/2011/09/plot_image_denoising_24.png" title="plot_image_denoising_24" /&gt;][]&lt;/p&gt;
&lt;p&gt;[![Image denoising with Dictionary learning and Orthogonal matching&amp;nbsp;pursuit][]][]&lt;/p&gt;
&lt;p&gt;The stars of this new release are: the manifold learning module by Jake
Vanderplas and Fabian Pedregosa, the Dirichlet process gaussian mixture
model by Alexandre Passos, and many others, as you can see from the
&lt;a href="http://scikit-learn.sourceforge.net/dev/whats_new.html" title="scikit-learn development changelog"&gt;development changelog&lt;/a&gt; (as soon as the release is made, I will update
this post with permanent&amp;nbsp;links).&lt;/p&gt;
&lt;p&gt;The release is due tomorrow. I will also be in charge with building the
Windows installers for this release, let&amp;#8217;s hope I do a good job and you
can think of me and smile when&amp;nbsp;installing!&lt;/p&gt;
&lt;p&gt;[&lt;img alt="Dictionary learned from Lena patches" src="http://localhost:8001/wp-content/uploads/2011/09/plot_image_denoising_1.png" title="plot_image_denoising_1" /&gt;]: http://localhost:8001/wp-content/uploads/2011/09/plot_image_denoising_1.png
  [&lt;img alt="Noisy image for denoising" src="http://localhost:8001/wp-content/uploads/2011/09/plot_image_denoising_24.png" title="plot_image_denoising_24" /&gt;]: http://localhost:8001/wp-content/uploads/2011/09/plot_image_denoising_24.png
  [Image denoising with Dictionary learning and Orthogonal matching
  pursuit]: http://localhost:8001/wp-content/uploads/2011/09/plot_image_denoising_44.png
    &amp;#8220;Image denoising with Dictionary learning and Orthogonal matching pursuit&amp;#8221;
  [![Image denoising with Dictionary learning and Orthogonal matching
  pursuit][]]:&amp;nbsp;http://localhost:8001/wp-content/uploads/2011/09/plot_image_denoising_44.png&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Mon, 19 Sep 2011 19:15:00 +0200</pubDate><guid>tag:vene.ro,2011-09-19:blog/dictionary-learning-in-scikit-learn-0-9.html</guid><category>dictionary learning</category><category>scikit-learn</category></item><item><title>Long overdue update. EuroScipy and SSLST 2011</title><link>http://vene.ro/blog/long-overdue-update-euroscipy-and-sslst-2011.html</link><description>&lt;p&gt;Anybody reading my blog should have expected me to blog about the end of
my GSoC. Sorry to disappoint, but I simply did not experience anything
similar to an ending. On the contrary, I feel like things have barely
started. Also, I apologize for one of the few posts here without pretty
pictures!&amp;nbsp;:)&lt;/p&gt;
&lt;p&gt;For the last two weeks, I&amp;#8217;ve been traveling. I attended the EuroScipy
conference thanks to Fabian, who offered me a place to sleep during the
week. We sprinted hard, we discussed tricky APIs, we drank a lot of
coffee, beer, and ate well in lovely Paris. It was great to meet all of
the celebrities, the people who keep the scientific Python globe&amp;nbsp;turning.&lt;/p&gt;
&lt;p&gt;Many thanks to Gael and Emmanuelle, who worked very, very hard on
organizing everything, so they weren&amp;#8217;t around and I didn&amp;#8217;t get to say
goodbye when I ran to catch my plane last&amp;nbsp;Sunday.&lt;/p&gt;
&lt;p&gt;I was in a hurry, heading to Tarragona, a beautiful city on the Catalan
coast, where the public university organized the 2011 summer school in
linguistics and speech technologies (&lt;span class="caps"&gt;SSLST&lt;/span&gt;). This was a great
opportunity to meet many fellow young researchers working in
computational linguistics. I will not go into details now, because I
plan expand on this, but I would like to state a couple of things.
Firsty, even though &lt;span class="caps"&gt;NLP&lt;/span&gt; seems to be mostly a Java-dominated affair (note
for example &lt;a href="http://nlp.stanford.edu/software/index.shtml"&gt;Stanford&amp;#8217;s &lt;span class="caps"&gt;NLP&lt;/span&gt; toolkit&lt;/a&gt; and &lt;a href="http://gate.ac.uk/"&gt;Sheffield&amp;#8217;s &lt;span class="caps"&gt;GATE&lt;/span&gt;&lt;/a&gt;), the
[computational linguistics and psycholinguistics research center
(CLiPS)][] at the University of Antwerp actually briefly manifested its
devotion to Python and &lt;span class="caps"&gt;NLTK&lt;/span&gt; via its research director, Walter&amp;nbsp;Daelemans.&lt;/p&gt;
&lt;p&gt;It was good to see a little love for Python in this field. &lt;span class="caps"&gt;NLTK&lt;/span&gt; is very
underrepresented in the SciPy community, I couldn&amp;#8217;t find anybody at the
EuroScipy conference knowing too much about it or about the people
behind&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;Another lab that has done a lot of cool work is &lt;a href="http://www.uclouvain.be/cental"&gt;Cental&lt;/a&gt; at the
Catholic University of Louvain, and they also use Python for natural
language processing. Maybe in the coming years, we will see a Python for
Computational Linguistics sattelite, along with Physics and
Neuroscience. Doesn&amp;#8217;t it sound more fun?&amp;nbsp;:P&lt;/p&gt;
&lt;p&gt;Secondly, I wish &lt;span class="caps"&gt;SSLST&lt;/span&gt; were organized by someone like Gael! As the
discussion at dinner regarding who will organize next year&amp;#8217;s EuroScipy
went, it is imperative that the organizers be actively involved in the
community, and generally passionate about it. Even though I&amp;#8217;m comparing
apples and oranges, Carlos Martin-Vide behaved in this context like a
old, tired, emotionless academic, not taking into account even lunch
breaks for the whole group, not to mention any sort of getting together
or even a group photo (which, alas, we were not able to take, apart from
small groups.) They said it couldn&amp;#8217;t be done. Of course it could, they
just didn&amp;#8217;t want it hard&amp;nbsp;enough.&lt;/p&gt;
&lt;p&gt;Finally, before signing off, I would like to announce that because the
Romanian Ministry of Education failed to specify the allocated number of
public positions for masters&amp;#8217; programmes, the admission exam at the
University of Bucharest will be delayed by a couple of weeks. Luckily,
this will allow me to attend &lt;a href="http://lml.bas.bg/ranlp2011/start3.php"&gt;&lt;span class="caps"&gt;RANLP&lt;/span&gt; 2011&lt;/a&gt; in Hissar, Bulgaria a week
from now, where I will present my poster entitled:&lt;br /&gt;
&amp;#8220;Can alternations be learned? A machine learning approach to Romanian
verb conjugation&amp;#8221; by Liviu P. Dinu, Emil Ionescu, Vlad Niculae and
Octavia-Maria Sulea. See you in&amp;nbsp;Hissar!&lt;/p&gt;
&lt;p&gt;[computational linguistics and psycholinguistics research center
  (CLiPS)]:&amp;nbsp;http://www.clips.ua.ac.be/&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Mon, 05 Sep 2011 00:08:00 +0200</pubDate><guid>tag:vene.ro,2011-09-05:blog/long-overdue-update-euroscipy-and-sslst-2011.html</guid><category>Uncategorized</category></item><item><title>Optimizing Orthogonal Matching Pursuit code in Numpy, part 2</title><link>http://vene.ro/blog/optimizing-orthogonal-matching-pursuit-code-in-numpy-part-2.html</link><description>&lt;p&gt;&lt;span class="caps"&gt;EDIT&lt;/span&gt;: There was a bug in the final version of the code presented here.
It is fixed now, for its backstory, check out &lt;a href="http://venefrombucharest.wordpress.com/2011/11/18/the-nasty-bug-crawling-in-my-orthogonal-matching-pursuit-code/" title="The nasty bug crawling in my Orthogonal Matching Pursuit code"&gt;my blog post on it&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;When we last saw our hero, he was fighting with the dreaded
implementation of least-angle regression, knowing full well that it was
his destiny to be&amp;nbsp;faster.&lt;/p&gt;
&lt;p&gt;We had come up with a more robust implementation, catching malformed
cases that would have broken the naive implementation, and also it was
orders of magnitude faster than said implementation. However, our
benchmark [&lt;a href="#footnote-1"&gt;1&lt;/a&gt;] showed that it was a couple of times slower than
least-angle&amp;nbsp;regression.&lt;/p&gt;
&lt;p&gt;By poking around the &lt;code&gt;scikits.learn&lt;/code&gt; codebase, I noticed that there is a
triangular system solver in &lt;code&gt;scikits.learn.utils.arrayfuncs&lt;/code&gt;. Unlike the
&lt;code&gt;scipy.linalg&lt;/code&gt; one, this one only works with lower triangular arrays,
and it forcefully overwrites &lt;code&gt;b&lt;/code&gt;. Even though if weren&amp;#8217;t faster, it
should still be used: &lt;code&gt;scikits.learn&lt;/code&gt; aims to be as backwards-compatible
with SciPy as possible, and &lt;code&gt;linalg.solve_triangular&lt;/code&gt; was added in
0.9.0. Anyway, let&amp;#8217;s just see whether it&amp;#8217;s&amp;nbsp;faster:&lt;/p&gt;
&lt;p&gt;[sourcecode language=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In &lt;a href="#footnote-1"&gt;1&lt;/a&gt;: import numpy as&amp;nbsp;np&lt;/p&gt;
&lt;p&gt;In &lt;a href="#footnote-2"&gt;2&lt;/a&gt;: from scipy import&amp;nbsp;linalg&lt;/p&gt;
&lt;p&gt;In [3]: from scikits.learn.datasets import&amp;nbsp;make_spd_matrix&lt;/p&gt;
&lt;p&gt;In [4]: from scikits.learn.utils.arrayfuncs import&amp;nbsp;solve_triangular&lt;/p&gt;
&lt;p&gt;In [5]: G =&amp;nbsp;make_spd_matrix(1000)&lt;/p&gt;
&lt;p&gt;In [6]: L = linalg.cholesky(G,&amp;nbsp;lower=True)&lt;/p&gt;
&lt;p&gt;In [7]: x =&amp;nbsp;np.random.randn(1000)&lt;/p&gt;
&lt;p&gt;In [8]: y =&amp;nbsp;x.copy()&lt;/p&gt;
&lt;p&gt;In [9]: timeit solve_triangular(L, x)&lt;br /&gt;
100 loops, best of 3: 3.45 ms per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [10]: timeit linalg.solve_triangular(L, y, lower=True,
overwrite_b=True)&lt;br /&gt;
10 loops, best of 3: 134 ms per loop&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Wow! That&amp;#8217;s 40x faster. We&amp;#8217;re catching two rabbits with one stone here,
let&amp;#8217;s do the change! Notice that we can just copy [latex]
\mathbf{v}[/latex] into the appropriate place in [latex] L[/latex] and
then solve in&amp;nbsp;place.&lt;/p&gt;
&lt;p&gt;But whoops! When solving the [latex] &lt;span class="caps"&gt;LL&lt;/span&gt;&amp;#8217;[/latex] system, we take
advantage of the &lt;code&gt;transpose&lt;/code&gt; attribute in &lt;code&gt;linalg.solve_triangular&lt;/code&gt;,
which the &lt;code&gt;scikits.learn&lt;/code&gt; version does not expose. We could think of a
solution, but here&amp;#8217;s a better idea: Shouldn&amp;#8217;t there be some way to
directly solve the entire system in one&amp;nbsp;go?&lt;/p&gt;
&lt;p&gt;Well, there is. It is an &lt;span class="caps"&gt;LAPACK&lt;/span&gt; function by the name of &lt;code&gt;potrs&lt;/code&gt;. If you
are not aware, &lt;span class="caps"&gt;LAPACK&lt;/span&gt; is a Fortran library with solvers for various
types of linear systems and eigenproblems. &lt;span class="caps"&gt;LAPACK&lt;/span&gt; along with &lt;span class="caps"&gt;BLAS&lt;/span&gt; (on
which it is based) pretty much powers all the scientific computation
that happens. &lt;span class="caps"&gt;BLAS&lt;/span&gt; is an &lt;span class="caps"&gt;API&lt;/span&gt; with multiple implementations dating from
1979, while &lt;span class="caps"&gt;LAPACK&lt;/span&gt; dates from 1992. If you ever used Matlab, this is
what was called behind the scenes. SciPy, again, provides a high-level
wrapper around this, the &lt;code&gt;linalg.cho_solve&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;But SciPy also gives us the possibility to import functions directly
from &lt;span class="caps"&gt;LAPACK&lt;/span&gt;, through the use of &lt;code&gt;linalg.lapack.get_lapack_funcs&lt;/code&gt;. Let&amp;#8217;s
see how the low-level &lt;span class="caps"&gt;LAPACK&lt;/span&gt; function compares to the SciPy wrapper, for
our use&amp;nbsp;case:&lt;/p&gt;
&lt;p&gt;[sourcecode language=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [11]: x =&amp;nbsp;np.random.randn(1000)&lt;/p&gt;
&lt;p&gt;In [12]: y =&amp;nbsp;x.copy()&lt;/p&gt;
&lt;p&gt;In [13]: timeit linalg.cho_solve((L, True), x)&lt;br /&gt;
1 loops, best of 3: 95.4 ms per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [14]: potrs, = linalg.lapack.get_lapack_funcs((&amp;#8216;potrs&amp;#8217;,),&amp;nbsp;(G,))&lt;/p&gt;
&lt;p&gt;In [15]: potrs&lt;br /&gt;
Out[15]: &amp;lt;fortran&amp;nbsp;object&amp;gt;&lt;/p&gt;
&lt;p&gt;In [16]: timeit potrs(L, y)&lt;br /&gt;
100 loops, best of 3: 9.49 ms per loop&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;That&amp;#8217;s 10 times faster! So now we found an obvious way to optimize the&amp;nbsp;code:&lt;/p&gt;
&lt;p&gt;[sourcecode language=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
def cholesky_omp(X, y, n_nonzero_coefs, eps=None):&lt;br /&gt;
min_float = np.finfo(X.dtype).eps&lt;br /&gt;
potrs, = get_lapack_funcs((&amp;#8216;potrs&amp;#8217;,), (X,))&lt;br /&gt;
alpha = np.dot(X.T, y)&lt;br /&gt;
residual = y&lt;br /&gt;
n_active = 0&lt;br /&gt;
idx =&amp;nbsp;[]&lt;/p&gt;
&lt;p&gt;max_features = X.shape&lt;a href="#footnote-1"&gt;1&lt;/a&gt; if eps is not None else n_nonzero_coefs&lt;br /&gt;
L = np.empty((max_features, max_features), dtype=X.dtype)&lt;br /&gt;
L[0, 0] =&amp;nbsp;1.&lt;/p&gt;
&lt;p&gt;while 1:&lt;br /&gt;
lam = np.abs(np.dot(X.T, residual)).argmax()&lt;br /&gt;
if lam &amp;lt; n_active or alpha[lam] ** 2 &amp;lt; min_float:&lt;br /&gt;
# atom already selected or inner product too small&lt;br /&gt;
warn(&amp;#8220;Stopping early&amp;#8221;)&lt;br /&gt;
break&lt;br /&gt;
if n_active &amp;gt; 0:&lt;br /&gt;
# Updates the Cholesky decomposition of X&amp;#8217; X&lt;br /&gt;
L[n_active, :n_active] = np.dot(X[:, idx].T, X[:, lam]&lt;br /&gt;
solve_triangular(L[:n_active, :n_active], L[n_active, :n_active])&lt;br /&gt;
d = np.dot(L[n_active, :n_active].T, L[n_active, :n_active])&lt;br /&gt;
if 1 - d &amp;lt;= min_float: # selected atoms are dependent&lt;br /&gt;
warn(&amp;#8220;Stopping early&amp;#8221;)&lt;br /&gt;
break&lt;br /&gt;
L[n_active, n_active] = np.sqrt(1 - d)&lt;br /&gt;
idx.append(lam)&lt;br /&gt;
# solve &lt;span class="caps"&gt;LL&lt;/span&gt;&amp;#8217;x = y in two steps:&lt;br /&gt;
gamma, _ = potrs(L[:n_active, :n_active], alpha[idx], lower=True,&lt;br /&gt;
overwrite_b=False)&lt;br /&gt;
residual = y - np.dot(X[:, idx], gamma)&lt;br /&gt;
if eps is not None and np.dot(residual.T, residual) &amp;lt;= eps:&lt;br /&gt;
break&lt;br /&gt;
elif n_active == max_features:&lt;br /&gt;
break&lt;br /&gt;
return gamma, idx&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Woohoo! But we still lag behind. Now that we delegated the trickiest
parts of the code to fast and reliable solvers, it&amp;#8217;s time to use a
profiler and see what the bottleneck is now. Python has excellent tools
for this purpose. What solved the problem in this case was
&lt;code&gt;line_profiler&lt;/code&gt; [&lt;a href="#footnote-2"&gt;2&lt;/a&gt;]. There is a great article by Olivier Grisel here
&lt;a href="#footnote-2"&gt;2&lt;/a&gt; regarding how to use these profilers. I&amp;#8217;m just going to say that
&lt;code&gt;line_profiler&lt;/code&gt;&lt;span class="quo"&gt;&amp;#8216;&lt;/span&gt;s output is very helpful, basically printing the time
taken by each line of code next to that&amp;nbsp;line.&lt;/p&gt;
&lt;p&gt;Running the profiler on this code, we found that 58% of the time is
spent on line 14, 20.5% on line 21, and 20.5% on line 32, with the rest
being insignificant (&lt;code&gt;potrs&lt;/code&gt; takes 0.1%!). The code is clearly dominated
by the matrix multiplications. By running some more timings with
IPython, I found that multiplying such column-wise views of the data as
&lt;code&gt;X[:, idx]&lt;/code&gt; is considerably slower then multiplying a contiguous array.
The least-angle regression code in &lt;code&gt;scikits.learn&lt;/code&gt; avoids this by
swapping columns towards the front of the array as they are chosen, so
we can replace &lt;code&gt;X[:, idx]&lt;/code&gt; with &lt;code&gt;X[:, :n_active]&lt;/code&gt;. The nice part is that
if the array is stored in Fortran-contiguous order (ie. column
contiguous order, as opposed to row contiguous order, as in C), swapping
two columns is a very fast operation!. Let&amp;#8217;s see some more&amp;nbsp;benchmarks!&lt;/p&gt;
&lt;p&gt;[sourcecode language=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [17]: X = np.random.randn(5000,&amp;nbsp;5000)&lt;/p&gt;
&lt;p&gt;In [18]: Y = X.copy(&amp;#8216;F&amp;#8217;) #&amp;nbsp;fortran-ordered&lt;/p&gt;
&lt;p&gt;In [19]: a, b = 1000,&amp;nbsp;2500&lt;/p&gt;
&lt;p&gt;In [20]: swap, = linalg.get_blas_funcs((&amp;#8216;swap&amp;#8217;,),&amp;nbsp;(X,))&lt;/p&gt;
&lt;p&gt;In [21]: timeit X[:, a], X[:, b] = swap(X[:, a], X[:, b])&lt;br /&gt;
100 loops, best of 3: 6.29 ms per&amp;nbsp;loop&lt;/p&gt;
&lt;p&gt;In [22]: timeit Y[:, a], Y[:, b] = swap(Y[:, a], Y[:, b])&lt;br /&gt;
10000 loops, best of 3: 111 us per loop&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;We can see that using Fortran-order takes us from the order of
miliseconds to the order of&amp;nbsp;microseconds!&lt;/p&gt;
&lt;p&gt;Side note: I almost fell into the trap of swapping columns the pythonic
way. That doesn&amp;#8217;t work:&lt;br /&gt;
[sourcecode language=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
In [23]: X[:, a], X[:, b] = X[:, b], X[:,&amp;nbsp;a]&lt;/p&gt;
&lt;p&gt;In [24]: np.testing.assert_array_equal(X[:, a], X[:,&amp;nbsp;b])&lt;/p&gt;
&lt;p&gt;In [25]:&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;However this trick works great for swapping elements of one-dimensional&amp;nbsp;arrays.&lt;/p&gt;
&lt;p&gt;Another small optimization that we can do: I found that on my system,
it&amp;#8217;s slightly faster to compute the norm using the &lt;span class="caps"&gt;BLAS&lt;/span&gt; function &lt;code&gt;nrm2&lt;/code&gt;.
So by putting all of these together, we end up with the final version of
our&amp;nbsp;code:&lt;/p&gt;
&lt;p&gt;[sourcecode language=&amp;#8221;python&amp;#8221;]&lt;br /&gt;
def cholesky_omp(X, y, n_nonzero_coefs, eps=None,
overwrite_X=False):&lt;br /&gt;
if not overwrite_X:&lt;br /&gt;
X = X.copy(&amp;#8216;F&amp;#8217;)&lt;br /&gt;
else: # even if we are allowed to overwrite, still copy it if bad
order&lt;br /&gt;
X =&amp;nbsp;np.asfortranarray(X)&lt;/p&gt;
&lt;p&gt;min_float = np.finfo(X.dtype).eps&lt;br /&gt;
nrm2, swap = linalg.get_blas_funcs((&amp;#8216;nrm2&amp;#8217;, &amp;#8216;swap&amp;#8217;), (X,))&lt;br /&gt;
potrs, = get_lapack_funcs((&amp;#8216;potrs&amp;#8217;,),&amp;nbsp;(X,))&lt;/p&gt;
&lt;p&gt;indices = range(len(Gram)) # keeping track of swapping&lt;br /&gt;
alpha = np.dot(X.T, y)&lt;br /&gt;
residual = y&lt;br /&gt;
n_active =&amp;nbsp;0&lt;/p&gt;
&lt;p&gt;max_features = X.shape&lt;a href="#footnote-1"&gt;1&lt;/a&gt; if eps is not None else n_nonzero_coefs&lt;br /&gt;
L = np.empty((max_features, max_features), dtype=X.dtype)&lt;br /&gt;
L[0, 0] =&amp;nbsp;1.&lt;/p&gt;
&lt;p&gt;while True:&lt;br /&gt;
lam = np.abs(np.dot(X.T, residual)).argmax()&lt;br /&gt;
if lam &amp;lt; n_active or alpha[lam] ** 2 &amp;lt; min_float:&lt;br /&gt;
# atom already selected or inner product too small&lt;br /&gt;
warn(&amp;#8220;Stopping early&amp;#8221;)&lt;br /&gt;
break&lt;br /&gt;
if n_active &amp;gt; 0:&lt;br /&gt;
# Updates the Cholesky decomposition of X&amp;#8217; X&lt;br /&gt;
L[n_active, :n_active] = np.dot(X[:, :n_active].T, X[:, lam])&lt;br /&gt;
solve_triangular(L[:n_active, :n_active], L[n_active, :n_active])&lt;br /&gt;
v = nrm2(L[n_active, :n_active]) ** 2&lt;br /&gt;
if 1 - v &amp;lt;= min_float: # selected atoms are dependent&lt;br /&gt;
warn(&amp;#8220;Stopping early&amp;#8221;)&lt;br /&gt;
break&lt;br /&gt;
L[n_active, n_active] = np.sqrt(1 - v)&lt;br /&gt;
X.T[n_active], X.T[lam] = swap(X.T[n_active], X.T[lam])&lt;br /&gt;
alpha[n_active], alpha[lam] = alpha[lam], alpha[n_active]&lt;br /&gt;
indices[n_active], indices[lam] = indices[lam], indices[n_active]&lt;br /&gt;
n_active += 1&lt;br /&gt;
# solves &lt;span class="caps"&gt;LL&lt;/span&gt;&amp;#8217;x = y as a composition of two triangular systems&lt;br /&gt;
gamma, _ = potrs(L[:n_active, :n_active], alpha[:n_active],
lower=True,&lt;br /&gt;&amp;nbsp;overwrite_b=False)&lt;/p&gt;
&lt;p&gt;residual = y - np.dot(X[:, :n_active], gamma)&lt;br /&gt;
if eps is not None and nrm2(residual) ** 2 &amp;lt;= eps:&lt;br /&gt;
break&lt;br /&gt;
elif n_active == max_features:&lt;br /&gt;&amp;nbsp;break&lt;/p&gt;
&lt;p&gt;return gamma, indices[:n_active]&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Now, the benchmark at [&lt;a href="#footnote-1"&gt;1&lt;/a&gt;] indicates victory over least-angle
regression! I hope you have enjoyed this short tour. See you next&amp;nbsp;time!&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/scikit-learn/scikit-learn/blob/master/benchmarks/bench_plot_omp_lars.py" title="Orthogonal matching pursuit versus least-angle regression"&gt;&lt;span id="footnote-1"&gt;1&lt;/span&gt;&lt;/a&gt;[]&lt;br /&gt;
&lt;a href="http://scikit-learn.sourceforge.net/dev/developers/performance.html#profiling-python-code" title="Profiling Python code"&gt;&lt;span id="footnote-2"&gt;2&lt;/span&gt;&lt;/a&gt;[]&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Thu, 11 Aug 2011 19:39:00 +0200</pubDate><guid>tag:vene.ro,2011-08-11:blog/optimizing-orthogonal-matching-pursuit-code-in-numpy-part-2.html</guid><category>blas</category><category>efficient</category><category>lapack</category><category>numpy</category><category>omp</category><category>orthogonal matching pursuit</category><category>potrs</category><category>scipy</category><category>dictionary learning</category><category>python</category><category>scikit-learn</category></item><item><title>Optimizing Orthogonal Matching Pursuit code in Numpy, part 1</title><link>http://vene.ro/blog/optimizing-orthogonal-matching-pursuit-code-in-numpy-part-1.html</link><description>&lt;p&gt;After intense code optimization work, my implementation of &lt;span class="caps"&gt;OMP&lt;/span&gt; finally
beat least-angle regression! This was the primary issue discussed during
the pull request, so once performance was taken care of, the code was
ready for merge. Orthogonal matching pursuit is now available in
scikits.learn as a sparse linear regression model. &lt;span class="caps"&gt;OMP&lt;/span&gt; is a key building
block of the dictionary learning code that we are working on&amp;nbsp;merging.&lt;/p&gt;
&lt;p&gt;I will go through the process of developing this particular piece of
code as an example of code refining and iterative improvements, as well
as for the useful notes it will provide on optimizing numerical Python
code. In the first part we will see how the code got from pseudocode
state to a reasonably efficient code with smart memory allocation. In
the next part we will see how to make it blazing fast by leveraging
[&lt;a href="#footnote-1"&gt;1&lt;/a&gt;] lower level &lt;span class="caps"&gt;BLAS&lt;/span&gt; and &lt;span class="caps"&gt;LAPACK&lt;/span&gt; routines, and how to use profiling
to find hot&amp;nbsp;spots.&lt;/p&gt;
&lt;p&gt;As stated before, orthogonal matching pursuit is a greedy algorithm for
finding a sparse solution [latex] \gamma[/latex] to a linear regression
problem [latex] X\gamma = y[/latex]. Mathematically, it approximates
the solution of the optimization&amp;nbsp;problem:&lt;/p&gt;
&lt;p&gt;\$\$ \text{argmin} {\big|\big|} \gamma {\big|\big|} _0 \text{
subject to }{\big |\big|}y-X\gamma{\big|\big|}_2\^2 \leq
\epsilon \$\$&lt;br /&gt;
or (under a different parametrization):&lt;br /&gt;
\$\$\text{argmin} {\big |\big|}y - X\gamma{\big |\big|}_2\^2
\text{ subject to } {\big|\big|}\gamma{\big|\big|}_0 \leq
n_{\text{nonzero&amp;nbsp;coefs}}\$\$&lt;/p&gt;
&lt;p&gt;In the code samples in this post I will omit the docstrings, but I will
follow the notation in the formulas&amp;nbsp;above.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important note:&lt;/strong&gt; The regressors/dictionary atoms (the columns of
[latex] X[/latex]) are assumed to be normalized throughout this post (as
well as usually any discussion of &lt;span class="caps"&gt;OMP&lt;/span&gt;). We also assume the following
imports:&lt;br /&gt;
[sourcecode language=&amp;#8221;Python&amp;#8221;]&lt;br /&gt;
import numpy as np&lt;br /&gt;
from scipy import linalg&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Orthogonal matching pursuit is a very simple algorithm in pseudocode,
and as I stated before, it almost writes itself in Numpy. For this
reason, instead of stating the pseudocode here, I will start with how
naively implemented &lt;span class="caps"&gt;OMP&lt;/span&gt; looks like in&amp;nbsp;Python:&lt;/p&gt;
&lt;p&gt;[sourcecode language=&amp;#8221;Python&amp;#8221;]&lt;br /&gt;
def orthogonal_mp(X, y, n_nonzero_coefs, eps=None):&lt;br /&gt;
residual = y&lt;br /&gt;
idx = []&lt;br /&gt;
if eps == None:&lt;br /&gt;
stopping_condition = lambda: len(idx) == n_nonzero_coefs&lt;br /&gt;
else:&lt;br /&gt;
stopping_condition = lambda: np.inner(residual, residual) &amp;lt;= eps&lt;br /&gt;
while not stopping_condition():&lt;br /&gt;
lam = np.abs(np.dot(residual, X)).argmax()&lt;br /&gt;
idx.append(lam)&lt;br /&gt;
gamma, _, _, _ = linalg.lstsq(X[:, idx], y)&lt;br /&gt;
residual = y - np.dot(X[:, idx], gamma)&lt;br /&gt;
return gamma, idx&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Using lambda expressions as stopping conditions never looked like a
brilliant idea, but it seems to me like the most elegant way to specify
such a variable stopping condition. However, the biggest slowdown in
this is the need for solving a least squares problem at each iteration,
while least-angle regression is known to produce the entire
regularization path for the cost of a single least squares problem. We
will also see that this implementation is more vulnerable to numerical
stability&amp;nbsp;issues.&lt;/p&gt;
&lt;p&gt;In [&lt;a href="#footnote-2"&gt;2&lt;/a&gt;], Rubinstein et al. described the Cholesky-&lt;span class="caps"&gt;OMP&lt;/span&gt; algorithm, an
implementation of &lt;span class="caps"&gt;OMP&lt;/span&gt; that avoids solving a new least squares problem at
each iteration by keeping a Cholesky decomposition [latex] &lt;span class="caps"&gt;LL&lt;/span&gt;&amp;#8217;[/latex]
of the Gram matrix [latex] G =
X_{\text{idx}}&amp;#8217;X_{\text{idx}}[/latex]. Because [latex]
X_{\text{idx}}[/latex] grows by exactly one column at each iteration,
[latex] L[/latex] can be updated according to the following rule: Given
[latex] A = \begin{pmatrix} \tilde{A} &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; \mathbf{v}&amp;#8217; &amp;#92; \mathbf{v}
&lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; c \end{pmatrix}[/latex], and knowing the decomposition of [latex]
\tilde{A} = \tilde{L}\tilde{L}&amp;#8217;[/latex], the Cholesky decomposition
[latex] A = &lt;span class="caps"&gt;LL&lt;/span&gt;&amp;#8217;[/latex] is given by \$\$ L = \begin{pmatrix}\tilde{L}
&lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; \mathbf{0} &amp;#92; \mathbf{w}&amp;#8217; &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; \sqrt{c - \mathbf{w}&amp;#8217;\mathbf{w}}
\end{pmatrix}, \text{ where } \tilde{L}\mathbf{w} =&amp;nbsp;\mathbf{v}\$\$&lt;/p&gt;
&lt;p&gt;Even if you are unfamiliar with the mathematical properties of the
Cholesky decomposition, you can see from the construction detailed above
that [latex] L[/latex] is always going to be a lower triangular matrix
(it will only have null elements above the main diagonal). Actually, the
letter L stands for lower. We have therefore replaced the step where we
needed to solve the least-squares problem [latex]
X_{\text{idx}}\gamma = y[/latex] with two much simpler computations:
solving [latex] \tilde{L}\mathbf{w} = \mathbf{v}[/latex] and solving
[latex] &lt;span class="caps"&gt;LL&lt;/span&gt;&amp;#8217;\gamma = X_{\text{idx}}&amp;#8217;y[/latex]. Due to the [latex]
L[/latex]&amp;#8217;s structure, these are much quicker operations than a least
squares projection.&lt;br /&gt;
Here is the initial way I implemented&amp;nbsp;this:&lt;/p&gt;
&lt;p&gt;[sourcecode&amp;nbsp;language=&amp;#8221;Python&amp;#8221;]&lt;/p&gt;
&lt;p&gt;def cholesky_omp(X, y, n_nonzero_coefs, eps=None):&lt;br /&gt;
if eps == None:&lt;br /&gt;
stopping_condition = lambda: it == n_nonzero_coefs&lt;br /&gt;
else:&lt;br /&gt;
stopping_condition = lambda: np.inner(residual, residual) \&amp;lt;=&amp;nbsp;eps&lt;/p&gt;
&lt;p&gt;alpha = np.dot(X.T, y)&lt;br /&gt;
residual = y&lt;br /&gt;
idx = []&lt;br /&gt;
L =&amp;nbsp;np.ones((1,1))&lt;/p&gt;
&lt;p&gt;while not stopping_condition():&lt;br /&gt;
lam = np.abs(np.dot(residual, X)).argmax()&lt;br /&gt;
if len(idx) &amp;gt; 0:&lt;br /&gt;
w = linalg.solve_triangular(L, np.dot(X[:, idx].T, X[:, lam]),&lt;br /&gt;
lower=True)&lt;br /&gt;
L = np.r_[np.c_[L, np.zeros(len(L))],&lt;br /&gt;
np.atleast_2d(np.append(w, np.sqrt(1 - np.dot(w.T, w))))]&lt;br /&gt;
idx.append(lam)&lt;br /&gt;
# solve &lt;span class="caps"&gt;LL&lt;/span&gt;&amp;#8217;x = y in two steps:&lt;br /&gt;
Ltx = linalg.solve_triangular(L, alpha[idx], lower=True)&lt;br /&gt;
gamma = linalg.solve_triangular(L, Ltx, trans=1, lower=True)&lt;br /&gt;
residual = y - np.dot(X[:, idx],&amp;nbsp;gamma)&lt;/p&gt;
&lt;p&gt;return gamma, idx&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;Note that a lot of the code remained unchanged, this is the same
algorithm as before, only the Cholesky trick is used to improve
performance. According to the plot in [&lt;a href="#footnote-3"&gt;3&lt;/a&gt;], we can see that the naive
implementation has oscillations of the reconstruction error due to
numerical instability, while this Cholesky implementation is&amp;nbsp;well-behaved.&lt;/p&gt;
&lt;p&gt;Along with this I also implemented the Gram-based version of this
algorithm, which only needs [latex] X&amp;#8217;X[/latex] and [latex] X&amp;#8217;y[/latex]
(and [latex] {\big|\big|}y{\big|\big|}_2\^2[/latex], in case the
epsilon-parametrization is desired). This is called &lt;strong&gt;Batch &lt;span class="caps"&gt;OMP&lt;/span&gt;&lt;/strong&gt; in
[&lt;a href="#footnote-2"&gt;2&lt;/a&gt;], because it offers speed gains when many signals need to be
sparse coded against the same dictionary [latex] X[/latex]. A lot of
speed is gained because two large matrix multiplications are avoided at
each iteration, but for many datasets, the cost of the precomputations
dominates the procedure. I will not insist on Gram &lt;span class="caps"&gt;OMP&lt;/span&gt; in this post, it
can be found in the &lt;code&gt;scikits.learn&lt;/code&gt; repository [&lt;a href="#footnote-4"&gt;4&lt;/a&gt;].&lt;/p&gt;
&lt;p&gt;Now, the problems with this are a bit more subtle. At this point, I
moved on to code other things, since &lt;span class="caps"&gt;OMP&lt;/span&gt; was passing tests and the
signal recovery example was working. The following issues popped up
during&amp;nbsp;review:&lt;/p&gt;
&lt;p&gt;​1. The lambda stopping condition does not pickle.&lt;br /&gt;
2. For well-constructed signals and data matrices, assuming normal
atoms, [latex] \mathbf{w}[/latex] on line 14 will never have norm
greater than or equal to zero, unless the chosen feature happens to be
dependent of the already chosen set. In theory, this cannot happen,
since we do an orthogonal projection at each step. However, if the
matrix [latex] X[/latex] is not well-behaved (for example, if it has two
identical columns, and [latex] y[/latex] is built using non-zero
coefficients for those columns), then we end up with the square root of
a negative value on line 17.&lt;br /&gt;
3. It was orders of magnitude slower than least-angle regression, given
the same number of nonzero&amp;nbsp;coefficients.&lt;/p&gt;
&lt;p&gt;1 was an easy fix. 2 was a bit tricky since it was a little hidden: the
first time I encountered such an error, I wrongfully assumed that given
that the diagonal of [latex] X_\text{idx}&amp;#8217;X_\text{idx}[/latex] was
unit, then [latex] L[/latex] should also have a unit diagonal, so I
passed the parameter &lt;code&gt;unit_diagonal=True&lt;/code&gt; to &lt;code&gt;linalg.solve_triangular&lt;/code&gt;,
and the plethora of NaN&amp;#8217;s along the diagonal were simply ignored. Let
this show what happens when you don&amp;#8217;t pay attention when&amp;nbsp;coding.&lt;/p&gt;
&lt;p&gt;When I realized my mistake, I first did something I saw in &lt;code&gt;lars_path&lt;/code&gt;
from the scikit: take the absolute value of the argument of &lt;code&gt;sqrt&lt;/code&gt;, and
also ensure it is practically larger than zero. However, tests started
failing randomly. Confusion ensued until the nature of the issue,
discussed above, was discovered. It&amp;#8217;s just not right to take the &lt;code&gt;abs&lt;/code&gt;:
if that argument ends up less than zero, &lt;span class="caps"&gt;OMP&lt;/span&gt; simply cannot proceed and
must stop due to malformed data. The reference implementation from the
website of the authors of [&lt;a href="#footnote-2"&gt;2&lt;/a&gt;] includes explicit &lt;em&gt;early stopping&lt;/em&gt;
conditions for this, along with some other&amp;nbsp;cases.&lt;/p&gt;
&lt;p&gt;At the same time, I started to try a couple of optimizations. The most
obvious thing was the way I was building the matrix [latex] L[/latex]
was clearly suboptimal, reallocating it at each&amp;nbsp;iteration.&lt;/p&gt;
&lt;p&gt;This leads to the following&amp;nbsp;code:&lt;/p&gt;
&lt;p&gt;[sourcecode&amp;nbsp;language=&amp;#8221;Python&amp;#8221;]&lt;/p&gt;
&lt;p&gt;def cholesky_omp(X, y, n_nonzero_coefs, eps=None):&lt;br /&gt;
min_float = np.finfo(X.dtype).eps&lt;br /&gt;
alpha = np.dot(X.T, y)&lt;br /&gt;
residual = y&lt;br /&gt;
n_active = 0&lt;br /&gt;
idx =&amp;nbsp;[]&lt;/p&gt;
&lt;p&gt;max_features = X.shape&lt;a href="#footnote-1"&gt;1&lt;/a&gt; if eps is not None else n_nonzero_coefs&lt;br /&gt;
L = np.empty((max_features, max_features), dtype=X.dtype)&lt;br /&gt;
L[0, 0] =&amp;nbsp;1.&lt;/p&gt;
&lt;p&gt;while 1:&lt;br /&gt;
lam = np.abs(np.dot(X.T, residual)).argmax()&lt;br /&gt;
if lam \&amp;lt; n_active or alpha[lam] ** 2 &gt; min_float:&lt;br /&gt;
# atom already selected or inner product too small&lt;br /&gt;
warn(&amp;#8220;Stopping early&amp;#8221;)&lt;br /&gt;
break&lt;br /&gt;
if n_active &amp;gt; 0:&lt;br /&gt;
# Updates the Cholesky decomposition of X&amp;#8217; X&lt;br /&gt;
w = linalg.solve_triangular(L[:n_active, :n_active],&lt;br /&gt;
np.dot(X[:, idx].T, X[:, lam]),&lt;br /&gt;
lower=True)&lt;br /&gt;
L[n_active, :n_active] = w&lt;br /&gt;
d = np.dot(w.T, w)&lt;br /&gt;
if 1 - d &amp;lt;= min_float: # selected atoms are dependent&lt;br /&gt;
warn(&amp;#8220;Stopping early&amp;#8221;)&lt;br /&gt;
break&lt;br /&gt;
L[n_active, n_active] = np.sqrt(1 - d)&lt;br /&gt;
idx.append(lam)&lt;br /&gt;
# solve &lt;span class="caps"&gt;LL&lt;/span&gt;&amp;#8217;x = y in two steps:&lt;br /&gt;
Ltx = linalg.solve_triangular(L[:n_active, :n_active], alpha[idx],
lower=True)&lt;br /&gt;
gamma = linalg.solve_triangular(L[:n_active, :n_active], Ltx,
trans=1, lower=True)&lt;br /&gt;
residual = y - np.dot(X[:, idx], gamma)&lt;br /&gt;
if eps is not None and np.dot(residual.T, residual) &amp;lt;= eps:&lt;br /&gt;
break&lt;br /&gt;
elif n_active == max_features:&lt;br /&gt;
break&lt;br /&gt;
return gamma, idx&lt;br /&gt;&amp;nbsp;[/sourcecode]&lt;/p&gt;
&lt;p&gt;What should be noted here, apart from the obvious fix for #1, are the
early stopping conditions. It is natural to stop if the same feature
gets picked twice: the residual is always orthogonalized with respect to
the chosen basis, so the only way this could happen is if there would be
no more unused independent regressors. This would either lead to this,
or to the stopping criterion on line 25, depending on which equally
insignificant vector gets picked. The other criterion for early stopping
is if the chosen atom is orthogonal to y, which would make it
uninformative and would again mean that there are no better ones left,
so we might as well quit&amp;nbsp;looking.&lt;/p&gt;
&lt;p&gt;Also, we now make sure that [latex] L[/latex] is preallocated. Note that
&lt;code&gt;np.empty&lt;/code&gt; is marginally faster than &lt;code&gt;np.zeros&lt;/code&gt; because it does not
initialize the array to zero after allocating, so the untouched parts of
the array will contain whatever happened to be in memory before. In our
case, this means only the values above the main diagonal: everything on
and beneath is initialized before access. Luckily, the
&lt;code&gt;linalg.solve_triangular&lt;/code&gt; function ignores what it doesn&amp;#8217;t&amp;nbsp;need.&lt;/p&gt;
&lt;p&gt;This is a robust implementation, but still a couple of times slower than
least-angle regression. In the next part of the article we will see how
we can make it beat &lt;span class="caps"&gt;LARS&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span id="footnote-1"&gt;&lt;a href="#footnote-1"&gt;1&lt;/a&gt;&lt;/span&gt; I always wanted to use this word in a
serious context :P&lt;br /&gt;
&lt;span id="footnote-2"&gt;&lt;a href="#footnote-2"&gt;2&lt;/a&gt;&lt;/span&gt; Rubinstein, R., Zibulevsky, M. and
Elad, M., [Efficient Implementation of the K-&lt;span class="caps"&gt;SVD&lt;/span&gt; Algorithm using Batch
Orthogonal Matching Pursuit][] Technical Report - &lt;span class="caps"&gt;CS&lt;/span&gt; Technion, April
2008.&lt;br /&gt;
&lt;span id="footnote-3"&gt;&lt;a href="#footnote-3"&gt;3&lt;/a&gt;&lt;/span&gt; &lt;a href="http://venefrombucharest.wordpress.com/2011/05/30/first-thoughts-on-orthogonal-matching-pursuit/" title="First thoughts on Orthogonal Matching Pursuit"&gt;First thoughts on Orthogonal
Matching Pursuit&lt;/a&gt; on this blog.&lt;br /&gt;
&lt;span id="footnote-4"&gt;&lt;a href="#footnote-4"&gt;4&lt;/a&gt;&lt;/span&gt; &lt;a href="https://github.com/scikit-learn/scikit-learn/blob/master/scikits/learn/linear_model/omp.py"&gt;omp.py&lt;/a&gt; on&amp;nbsp;github.&lt;/p&gt;
&lt;p&gt;[Efficient Implementation of the K-&lt;span class="caps"&gt;SVD&lt;/span&gt; Algorithm using Batch
  Orthogonal Matching Pursuit]: http://www.cs.technion.ac.il/~ronrubin/Publications/&lt;span class="caps"&gt;KSVD&lt;/span&gt;-&lt;span class="caps"&gt;OMP&lt;/span&gt;-v2.pdf&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Sun, 07 Aug 2011 20:50:00 +0200</pubDate><guid>tag:vene.ro,2011-08-07:blog/optimizing-orthogonal-matching-pursuit-code-in-numpy-part-1.html</guid><category>efficient</category><category>numpy</category><category>omp</category><category>orthogonal matching pursuit</category><category>scipy</category><category>dictionary learning</category><category>scikit-learn</category><category>python</category></item><item><title>Progress on Orthogonal Matching Pursuit</title><link>http://vene.ro/blog/progress-on-orthogonal-matching-pursuit.html</link><description>&lt;p&gt;Since orthogonal matching pursuit (&lt;span class="caps"&gt;OMP&lt;/span&gt;) is an important part of signal
processing and therefore crucial to the image processing aspect of
dictionary learning, I am currently focusing on optimizing the &lt;span class="caps"&gt;OMP&lt;/span&gt; code
and making sure it is stable. &lt;span class="caps"&gt;OMP&lt;/span&gt; is a forward method like least-angle
regression, so it is natural to bench them against one&amp;nbsp;another.&lt;/p&gt;
&lt;p&gt;This has helped find a couple of bottlenecks. Time has been gained by
preallocating the array to store the Cholesky decomposition. Also, using
the &lt;span class="caps"&gt;LAPACK&lt;/span&gt; &lt;code&gt;potrs&lt;/code&gt; function in order to solve a system of the shape
\$latex &lt;span class="caps"&gt;LL&lt;/span&gt;&amp;#8217;x=y\$ is faster than using &lt;code&gt;solve_triangular&lt;/code&gt; twice.&lt;/p&gt;
&lt;p&gt;I am still trying to optimize the code. We are working hard to make sure
that scikits.learn contributions are up to standards before&amp;nbsp;merging.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Tue, 02 Aug 2011 16:56:00 +0200</pubDate><guid>tag:vene.ro,2011-08-02:blog/progress-on-orthogonal-matching-pursuit.html</guid><category>omp</category><category>orthogonal matching pursuit</category><category>scikit-learn</category></item><item><title>SparsePCA in scikits.learn-git</title><link>http://vene.ro/blog/sparsepca-in-scikits-learn-git.html</link><description>&lt;p&gt;I am happy to announce that the Sparse &lt;span class="caps"&gt;PCA&lt;/span&gt; code has been reviewed and
merged into the main &lt;code&gt;scikits.learn&lt;/code&gt; repository.&lt;/p&gt;
&lt;p&gt;You can use it if you install the bleeding edge &lt;code&gt;scikits.learn&lt;/code&gt; git
version, by first downloading the source code as explained in the
&lt;a href="http://scikit-learn.sourceforge.net/stable/developers/index.html#git-repo" title="installation user's guide"&gt;user&amp;#8217;s guide&lt;/a&gt;, and then running &lt;code&gt;python setup.py install&lt;/code&gt;.&lt;br /&gt;
[caption id=&amp;#8221;&amp;#8221; align=&amp;#8221;aligncenter&amp;#8221; width=&amp;#8221;400&amp;#8221; caption=&amp;#8221;Sparse &lt;span class="caps"&gt;PCA&lt;/span&gt; on
images of the digit 3&amp;#8221;][&lt;img alt="" src="http://scikit-learn.sourceforge.net/dev/_images/plot_digits_decomposition_4.png" title="Sparse PCA on images of the digit 3" /&gt;][][/caption]&lt;br /&gt;
To see what code is needed to produce an image such as the one above,
using &lt;code&gt;scikits.learn&lt;/code&gt;. check out this cool &lt;a href="http://scikit-learn.sourceforge.net/dev/auto_examples/decomposition/plot_digits_decomposition.html" title="decomposition example"&gt;decomposition example&lt;/a&gt;
that compares the results of most matrix decomposition models
implemented at the&amp;nbsp;moment.&lt;/p&gt;
&lt;p&gt;There are other new cool things that have been recently merged by other
contributors, such as support for sparse matrices in &lt;a href="http://scikit-learn.sourceforge.net/dev/modules/clustering.html#mini-batch-k-means" title="minibatch K-means"&gt;minibatch
K-means&lt;/a&gt;, and the &lt;a href="http://scikit-learn.sourceforge.net/dev/modules/mixture.html#infinite-gaussian-mixtures-dpgmm-classifier" title="variational infinite gaussian mixture model"&gt;variational infinite gaussian mixture model&lt;/a&gt;, so
I invite you to take a&amp;nbsp;look!&lt;/p&gt;
&lt;p&gt;[&lt;img alt="" src="http://scikit-learn.sourceforge.net/dev/_images/plot_digits_decomposition_4.png" title="Sparse PCA on images of the digit 3" /&gt;]:&amp;nbsp;http://scikit-learn.sourceforge.net/dev/_images/plot_digits_decomposition_4.png&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Tue, 19 Jul 2011 12:01:00 +0200</pubDate><guid>tag:vene.ro,2011-07-19:blog/sparsepca-in-scikits-learn-git.html</guid><category>pca</category><category>principal components analysis</category><category>scikit-learn</category><category>sparse pca</category><category>SparsePCA</category><category>spca</category></item><item><title>K-Means for dictionary learning</title><link>http://vene.ro/blog/k-means-for-dictionary-learning.html</link><description>&lt;p&gt;[![Dictionary learned with K-Means on the &lt;span class="caps"&gt;LFW&lt;/span&gt; dataset with whitening
&lt;span class="caps"&gt;PCA&lt;/span&gt;][]][][![Dictionary learned with K-Means on the &lt;span class="caps"&gt;LFW&lt;/span&gt; dataset without
whitening &lt;span class="caps"&gt;PCA&lt;/span&gt;][]][]&lt;/p&gt;
&lt;p&gt;One of the simplest, and yet most heavily constrained form of matrix
factorization, is vector quantization (&lt;span class="caps"&gt;VQ&lt;/span&gt;). Heavily used in image/video
compression, the &lt;span class="caps"&gt;VQ&lt;/span&gt; problem is a factorization [latex] X=&lt;span class="caps"&gt;WH&lt;/span&gt;[/latex]
where [latex] H[/latex] (our dictionary) is called the codebook and is
designed to cover the cloud of data points effectively, and each line of
[latex] W[/latex] is a unit&amp;nbsp;vector.&lt;/p&gt;
&lt;p&gt;This means that each each data point [latex] x_i[/latex] is
approximated as [latex] x_i \approx h_{k} = \sum_{j=1}\^{r}
\delta_{kj}h_{j}[/latex]. In other words, the closest row vector
(codeword/dictionary atom) [latex] h_k[/latex] of [latex] H[/latex] is
chosen as an approximation, and this is encoded as a unit vector [latex]
(\delta_{k1}, &amp;#8230;, \delta_{kr})[/latex]. The data representation
[latex] W[/latex] is composed of such&amp;nbsp;vectors.&lt;/p&gt;
&lt;p&gt;There is a variation called gain-shape &lt;span class="caps"&gt;VQ&lt;/span&gt; where instead of approximating
each point as one of the codewords, we allow a scalar multiplication
invariance: [latex] x_i \approx \alpha_ih_k[/latex]. This model
requires considerably more storage (each data point needs a floating
point number and an unsigned index, as opposed to just the index), but
it leads to a much better approximation.&lt;br /&gt;
Gain-shape &lt;span class="caps"&gt;VQ&lt;/span&gt; can equivalently be accomplished by normalizing each data
vector prior to fitting the&amp;nbsp;codebook.&lt;/p&gt;
&lt;p&gt;In order to fit a codebook [latex] H[/latex] for efficient &lt;span class="caps"&gt;VQ&lt;/span&gt; use, the
K-Means Clustering [&lt;a href="#footnote-1"&gt;1&lt;/a&gt;] algorithm is a natural thought. K-means is an
iterative algorithm that incrementally improves the dispersion of k
cluster centers in the data space until convergence. The cluster centers
are initialized in a random or procedural fashion, then, at each
iteration, the data points are assigned to the closest cluster center,
which is subsequently moved to the center of the points assigned to&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;scikits.learn.decomposition.KMeansCoder&lt;/code&gt; object from our
work-in-progress dictionary learning toolkit can learn a dictionary from
image patches using the K-Means algorithm, with optional local contrast
normalization and a &lt;span class="caps"&gt;PCA&lt;/span&gt; whitening transform. Using a trained object to
transform data points with orthogonal matching pursuit, with the
parameter &lt;code&gt;n_atoms=1&lt;/code&gt; is equivalent to gain-shape &lt;span class="caps"&gt;VQ&lt;/span&gt;. Of course you are
free to use any method of sparse coding such as &lt;span class="caps"&gt;LARS&lt;/span&gt;. The code used to
produce the example images on top of this post can be found in [&lt;a href="#footnote-2"&gt;2&lt;/a&gt;].&lt;/p&gt;
&lt;p&gt;Using K-Means for learning the dictionary does not optimize over linear
combinations of dictionary atoms, like standard dictionary learning
methods do. However, it&amp;#8217;s considerably faster, and Adam Coates and
Andrew Ng suggest in [&lt;a href="#footnote-3"&gt;3&lt;/a&gt;] that as long as the dictionary is filled
with a large enough number of atoms and it covers well enough the cloud
of data (and of future test data) points, then K-Means, or even random
sampling of image patches, can perform remarkably well for some&amp;nbsp;tasks.&lt;/p&gt;
&lt;div id="footnote-1"&gt;
[1] [Wikipedia article on K-Means clustering][]

&lt;/div&gt;

&lt;div id="footnote-2"&gt;
[2] [K-Means Coder example][]

&lt;/div&gt;

&lt;div id="footnote-3"&gt;
[3] [**The importance of encoding versus training with sparse coding and
vector quantization**, Adam Coates and Andrew Y. Ng. In Proceedings of
the Twenty-Eighth International Conference on Machine Learning, 2011.][]

&lt;/div&gt;

&lt;p&gt;[Dictionary learned with K-Means on the &lt;span class="caps"&gt;LFW&lt;/span&gt; dataset with whitening
  &lt;span class="caps"&gt;PCA&lt;/span&gt;]: http://localhost:8001/wp-content/uploads/2011/07/kmeans_w.png?w=250
    &amp;#8220;K-Means dictionary with whitening &lt;span class="caps"&gt;PCA&lt;/span&gt;&amp;#8221;
  [![Dictionary learned with K-Means on the &lt;span class="caps"&gt;LFW&lt;/span&gt; dataset with whitening
  &lt;span class="caps"&gt;PCA&lt;/span&gt;][]]: http://localhost:8001/wp-content/uploads/2011/07/kmeans_w.png
  [Dictionary learned with K-Means on the &lt;span class="caps"&gt;LFW&lt;/span&gt; dataset without whitening
  &lt;span class="caps"&gt;PCA&lt;/span&gt;]: http://localhost:8001/wp-content/uploads/2011/07/kmeans_no_w.png?w=250
    &amp;#8220;K-Means dictionary without whitening &lt;span class="caps"&gt;PCA&lt;/span&gt;&amp;#8221;
  [![Dictionary learned with K-Means on the &lt;span class="caps"&gt;LFW&lt;/span&gt; dataset without
  whitening &lt;span class="caps"&gt;PCA&lt;/span&gt;][]]: http://localhost:8001/wp-content/uploads/2011/07/kmeans_no_w.png
  [&lt;strong&gt;The importance of encoding versus training with sparse coding and
  vector quantization&lt;/strong&gt;, Adam Coates and Andrew Y. Ng. In Proceedings of
  the Twenty-Eighth International Conference on Machine Learning,
  2011.]:&amp;nbsp;http://ai.stanford.edu/~ang/papers/icml11-EncodingVsTraining.pdf&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Sun, 10 Jul 2011 14:27:00 +0200</pubDate><guid>tag:vene.ro,2011-07-10:blog/k-means-for-dictionary-learning.html</guid><category>dictionary learning</category><category>k-means</category><category>scikit-learn</category><category>vq</category><category>Uncategorized</category></item><item><title>Image denoising with dictionary learning</title><link>http://vene.ro/blog/image-denoising-with-dictionary-learning.html</link><description>&lt;p&gt;I am presenting an image denoising example that fully runs under my
local scikits-learn fork. Coming soon near&amp;nbsp;you!&lt;/p&gt;
&lt;p&gt;The 400 square pixels area covering Lena&amp;#8217;s face was distorted by
additive gaussian noise with a standard deviation of 50 (pixel values
are ranged&amp;nbsp;0-256.)&lt;/p&gt;
&lt;p&gt;[&lt;img alt="Lena image denoising using dictionary learning" src="http://localhost:8001/wp-content/uploads/2011/07/denoise3.png" title="Lena denoising" /&gt;][]&lt;/p&gt;
&lt;p&gt;The dictionary contains 100 atoms of shape 4x4 and was trained using
10000 random patches extracted from the undistorted image. Then, each
one of the four 100 square pixel areas was reconstructed using the
dictionary learning model and a different transform&amp;nbsp;method.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="caps"&gt;OMP&lt;/span&gt;-1 reconstructs each patch as the closest dictionary atom,
    multiplied by a variable coefficient. This is similar to the idea of
    gain-shape vector&amp;nbsp;quantization.&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;OMP&lt;/span&gt;-2 is like &lt;span class="caps"&gt;OMP&lt;/span&gt;-1, but it considers 2 atoms instead of just one.
    This takes advantage of the fact that the natural dictionary atoms
    are of such nature to efficiently represent random image patches
    when&amp;nbsp;combined.&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;LARS&lt;/span&gt; finds a reconstruction of each image patch as a solution to a
    Lasso problem, solved using least angle&amp;nbsp;regression.&lt;/li&gt;
&lt;li&gt;Thresholding is a simple and quick non-linearity that (as it is
    currently implemented, based on [&lt;a href="#footnote-1"&gt;1&lt;/a&gt;], where it is not intended
    for reconstruction but for classification) breaks the local
    brightness of the image fragment. The bottom right fragment was
    forcefully renormalized to stretch fit into the 0-256 range, but
    brightness differences can be&amp;nbsp;seen.&lt;/li&gt;
&lt;/ul&gt;
&lt;div id="footnote-1"&gt;
[1] [**The importance of encoding versus training with sparse coding and
vector quantization**, Adam Coates and Andrew Y. Ng. In Proceedings of
the Twenty-Eighth International Conference on Machine Learning, 2011.][]

&lt;/div&gt;

&lt;p&gt;[&lt;img alt="Lena image denoising using dictionary learning" src="http://localhost:8001/wp-content/uploads/2011/07/denoise3.png" title="Lena denoising" /&gt;]: http://localhost:8001/wp-content/uploads/2011/07/denoise3.png
  [&lt;strong&gt;The importance of encoding versus training with sparse coding and
  vector quantization&lt;/strong&gt;, Adam Coates and Andrew Y. Ng. In Proceedings of
  the Twenty-Eighth International Conference on Machine Learning,
  2011.]:&amp;nbsp;http://ai.stanford.edu/~ang/papers/icml11-EncodingVsTraining.pdf&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Thu, 07 Jul 2011 20:00:00 +0200</pubDate><guid>tag:vene.ro,2011-07-07:blog/image-denoising-with-dictionary-learning.html</guid><category>denoising</category><category>dictionary learning</category><category>scikit-learn</category></item><item><title>Dictionary learning sneak peek</title><link>http://vene.ro/blog/dictionary-learning-sneak-peek.html</link><description>&lt;p&gt;Closing in on the goal of integrating J. Mairal&amp;#8217;s dictionary learning in
the scikit, I stitched together a couple of&amp;nbsp;examples.&lt;/p&gt;
&lt;p&gt;The code is not yet integrated according to our standards, but here is
the kind of results you can&amp;nbsp;expect.&lt;/p&gt;
&lt;p&gt;Here is how a dictionary obtained from 8x8 patches of Lena looks like.
Pretty much it looks as expected: gabor-like wavelets with different
rotations and shifts, which means things are&amp;nbsp;working!&lt;/p&gt;
&lt;p&gt;[&lt;img alt="Dictionary learned from lena patches" src="http://localhost:8001/wp-content/uploads/2011/06/image.png" title="Dictionary learned from lena patches" /&gt;][]&lt;/p&gt;
&lt;p&gt;And here is how it works for denoising Lena. On the left is the noisy
image and on the right is the reconstruction from a learned dictionary.
The sparse code code producing the result on the right is found using
orthogonal matching&amp;nbsp;pursuit.&lt;/p&gt;
&lt;p&gt;This is by no means a good denoising example, I have no idea at the
moment how to tweak the patch sizes and the model parameters to obtain a
better result. This is just a sneak peek and pretty soon you will see
better&amp;nbsp;stuff!&lt;/p&gt;
&lt;p&gt;[&lt;img alt="Denoising Lena with dictionary learning and OMP" src="http://localhost:8001/wp-content/uploads/2011/06/denoise.png" title="Denoising Lena" /&gt;][]&lt;/p&gt;
&lt;p&gt;[&lt;img alt="Dictionary learned from lena patches" src="http://localhost:8001/wp-content/uploads/2011/06/image.png" title="Dictionary learned from lena patches" /&gt;]: http://localhost:8001/wp-content/uploads/2011/06/image.png
  [&lt;img alt="Denoising Lena with dictionary learning and OMP" src="http://localhost:8001/wp-content/uploads/2011/06/denoise.png" title="Denoising Lena" /&gt;]:&amp;nbsp;http://localhost:8001/wp-content/uploads/2011/06/denoise.png&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Fri, 24 Jun 2011 12:06:00 +0200</pubDate><guid>tag:vene.ro,2011-06-24:blog/dictionary-learning-sneak-peek.html</guid><category>Uncategorized</category></item><item><title>Summer of Code roadmap, part 1</title><link>http://vene.ro/blog/summer-of-code-roadmap-part-1.html</link><description>&lt;p&gt;After a little busy while, I have graduated and entered the summer
vacation, which means time for serious GSoC&amp;nbsp;work.&lt;/p&gt;
&lt;p&gt;[&lt;img alt="Me on graduation day" src="http://localhost:8001/wp-content/uploads/2011/06/p1080283.jpg" title="Graduation day" /&gt;][]&lt;/p&gt;
&lt;p&gt;So we had a little conference in order to discuss what will be done and
when. We gathered quite a few code snippets since the official start of
the project, but it&amp;#8217;s now time to talk about integration and pull&amp;nbsp;requests.&lt;/p&gt;
&lt;p&gt;Here is the&amp;nbsp;plan:&lt;/p&gt;
&lt;h4&gt;SparsePCA&lt;/h4&gt;
&lt;p&gt;First pull request due: &lt;strong&gt;June 15&lt;/strong&gt;&lt;br /&gt;
This will be the use case I blogged about &lt;a href="http://venefrombucharest.wordpress.com/2011/05/23/sparse-pca/" title="Sparse PCA"&gt;before&lt;/a&gt;. Specifically, we
want to learn a dictionary of sparse atoms, but representations of the
data will be&amp;nbsp;dense.&lt;/p&gt;
&lt;h4&gt;SparseCoder&lt;/h4&gt;
&lt;p&gt;First pull request due: &lt;strong&gt;June 25&lt;/strong&gt;&lt;br /&gt;
This is the transpose of the SparsePCA problem. We are learning the
optimal, dense dictionary for sparse representations of the&amp;nbsp;data.&lt;/p&gt;
&lt;h4&gt;KMeansCoder&lt;/h4&gt;
&lt;p&gt;First pull request due: &lt;strong&gt;June 30&lt;/strong&gt;&lt;br /&gt;
This method builds the dictionary out of cluster centers found by&amp;nbsp;K-means.&lt;/p&gt;
&lt;h4&gt;OnlineSparseCoder&lt;/h4&gt;
&lt;p&gt;First pull request due: &lt;strong&gt;July 10&lt;/strong&gt;&lt;br /&gt;
This will involve the online learning tricks suggested in Julien
Mairal&amp;#8217;s work and will allow for faster computations of both sparse &lt;span class="caps"&gt;PCA&lt;/span&gt;
and sparse coding. In the case of sparse coding, it will make use of the
scikits.learn &lt;span class="caps"&gt;API&lt;/span&gt; for online&amp;nbsp;learning.&lt;/p&gt;
&lt;p&gt;While I will try to keep the deadlines for the initial pull requests as
strictly as I can, we did not establish deadlines for merging, since
this will depend on more factors. As long as the pull requests are up,
the code review system will push it forward towards the merge. The focus
is on teamwork and on feedback cycles as short as possible, as opposed
to falling into the trap of delaying work until the night before the&amp;nbsp;deadline.&lt;/p&gt;
&lt;p&gt;[&lt;img alt="Me on graduation day" src="http://localhost:8001/wp-content/uploads/2011/06/p1080283.jpg" title="Graduation day" /&gt;]:&amp;nbsp;http://localhost:8001/wp-content/uploads/2011/06/p1080283.jpg&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Sun, 12 Jun 2011 14:28:00 +0200</pubDate><guid>tag:vene.ro,2011-06-12:blog/summer-of-code-roadmap-part-1.html</guid><category>gsoc</category><category>Uncategorized</category></item><item><title>First thoughts on Orthogonal Matching Pursuit</title><link>http://vene.ro/blog/first-thoughts-on-orthogonal-matching-pursuit.html</link><description>&lt;p&gt;I am working on implementing the Orthogonal Matching Pursuit (&lt;span class="caps"&gt;OMP&lt;/span&gt;)
algorithm for the scikit. It is an elegant algorithm (that almost writes
itself in Numpy!) to compute a greedy approximation to the solution of a
sparse coding&amp;nbsp;problem:&lt;/p&gt;
&lt;p&gt;\$\$ \text{argmin} \big|\big|\gamma\big|\big|_0 \text{ subject
to }\big|\big|x-D\gamma\big|\big|_2\^2 \leq&amp;nbsp;\epsilon\$\$&lt;/p&gt;
&lt;p&gt;or (in a different&amp;nbsp;parametrization)&lt;/p&gt;
&lt;p&gt;\$\$ \text{argmin} \big|\big|x - D\gamma\big|\big|_2\^2\text{
subject to }\big|\big|\gamma\big|\big|_0 \leq&amp;nbsp;m\$\$&lt;/p&gt;
&lt;p&gt;The second formulation is interesting in that it gives one of the few
algorithms for sparse coding that can control the actual number of
non-zero entries in the solution. Some dictionary learning methods need
this (I&amp;#8217;m thinking of K-&lt;span class="caps"&gt;SVD&lt;/span&gt;).&lt;/p&gt;
&lt;p&gt;Both problems are solved by the same algorithm, with a different
stopping condition. The gist of it is to include at each iteration, the
atom with the highest correlation to the current residual. However, as
opposed to regular Matching Pursuit, here, after choosing the atom, the
input signal is orthogonally projected to the space spanned by the
chosen atoms. This involves the solution of a least squares problem at
each step. However, because the problem is almost the same at each
iteration, only with one more column added to the matrix, this can be
easily solved by maintaining a &lt;span class="caps"&gt;QR&lt;/span&gt; or Cholesky decomposition of the
dictionary matrix that is updated at each&amp;nbsp;step.&lt;/p&gt;
&lt;p&gt;Rubinstein et al. [1] came up with a clever method to optimize the
calculations, based on the fact that usually in practice we never have
to find a sparse coding for a single signal, but usually for a batch.
They called this method Batch &lt;span class="caps"&gt;OMP&lt;/span&gt;, and it is based on a straightforward
modification of the Cholesky update algorithm, taking advantage of
precomputing the Gram matrix [latex]&amp;nbsp;G=D&amp;#8217;D[/latex].&lt;/p&gt;
&lt;p&gt;Based on my experiments, their batch update is the fastest, even though
it lags behind if invoked with too small a batch. As soon as I make sure
the implementation is robust and ready for use, I will make some&amp;nbsp;benchmarks.&lt;/p&gt;
&lt;p&gt;Update: Here&amp;#8217;s a little proof that it works!&lt;br /&gt;
[&lt;img alt="Stem plot for sparse signals recovered by OMP" src="http://localhost:8001/wp-content/uploads/2011/06/omp.png" title="Orthogonal Matching Pursuit sparse signal recovery" /&gt;][]&lt;/p&gt;
&lt;p&gt;Update 2: Here&amp;#8217;s a little benchmark:&lt;br /&gt;
[&lt;img alt="Orthogonal Matching Pursuit benchmark" src="http://localhost:8001/wp-content/uploads/2011/06/omp_bench.png" title="OMP benchmark, time and error" /&gt;][]&lt;br /&gt;
[1]
http://www.cs.technion.ac.il/\~ronrubin/Publications/&lt;span class="caps"&gt;KSVD&lt;/span&gt;-&lt;span class="caps"&gt;OMP&lt;/span&gt;-v2.pdf&lt;/p&gt;
&lt;p&gt;[&lt;img alt="Stem plot for sparse signals recovered by OMP" src="http://localhost:8001/wp-content/uploads/2011/06/omp.png" title="Orthogonal Matching Pursuit sparse signal recovery" /&gt;]: http://localhost:8001/wp-content/uploads/2011/06/omp.png
  [&lt;img alt="Orthogonal Matching Pursuit benchmark" src="http://localhost:8001/wp-content/uploads/2011/06/omp_bench.png" title="OMP benchmark, time and error" /&gt;]:&amp;nbsp;http://localhost:8001/wp-content/uploads/2011/06/omp_bench.png&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Mon, 30 May 2011 13:02:00 +0200</pubDate><guid>tag:vene.ro,2011-05-30:blog/first-thoughts-on-orthogonal-matching-pursuit.html</guid><category>Uncategorized</category><category>dictionary learning</category><category>omp</category><category>orthogonal matching pursuit</category></item><item><title>Sparse PCA</title><link>http://vene.ro/blog/sparse-pca.html</link><description>&lt;p&gt;I have been working on the integration into the scikits.learn codebase
of a sparse principal components analysis (SparsePCA) algorithm coded by
Gaël and Alexandre and based on [[1]][]. Because the name &amp;#8220;sparse &lt;span class="caps"&gt;PCA&lt;/span&gt;&amp;#8221;
has some inherent ambiguity, I will describe in greater depth what
problem we are actually solving, and what it can be used&amp;nbsp;for.&lt;/p&gt;
&lt;h1&gt;The&amp;nbsp;problem&lt;/h1&gt;
&lt;p&gt;Mathematically, this implementation of Sparse &lt;span class="caps"&gt;PCA&lt;/span&gt;&amp;nbsp;solves:&lt;/p&gt;
&lt;p&gt;\$latex (U\^*,
V\^*)=\underset{U,V}{\mathrm{argmin\,}}\frac{1}{2}||X-&lt;span class="caps"&gt;UV&lt;/span&gt;||_2\^2+\alpha||V||_1\$&lt;/p&gt;
&lt;p&gt;with \$latex || U_k ||_2 = 1\$ for all \$latex 0 \leq k \&amp;lt;&amp;nbsp;n_{atoms}\$&lt;/p&gt;
&lt;p&gt;This looks really abstract so let&amp;#8217;s try to interpret it. We are looking
for a matrix factorization \$latex &lt;span class="caps"&gt;UV&lt;/span&gt;\$ of \$latex X \in
\mathbf{R}\^{n_{samples}\times n_{features}}\$, just like in
ordinary &lt;span class="caps"&gt;PCA&lt;/span&gt;. The interpretation is that the \$latex n_{atoms}\$ lines
of \$latex V\$ are the extracted components, while the lines of \$latex
U\$ are the coordinates of the samples in this&amp;nbsp;projection.&lt;/p&gt;
&lt;p&gt;The most important difference between this and &lt;span class="caps"&gt;PCA&lt;/span&gt; is that we enforce
sparsity on the &lt;em&gt;components&lt;/em&gt;. In other words, we look for a
representation of the data as a linear combination of sparse&amp;nbsp;signals.&lt;/p&gt;
&lt;p&gt;Another difference is that, unlike in &lt;span class="caps"&gt;PCA&lt;/span&gt;, here we don&amp;#8217;t constrain U to
be orthogonal, just to consist of normalized column vectors. There are
different approaches where this constraint appears too, and they are on
the list for this summer, but I&amp;nbsp;digress.&lt;/p&gt;
&lt;h1&gt;The&amp;nbsp;approach&lt;/h1&gt;
&lt;p&gt;As usual, such optimization problems are solved by alternatively
minimizing one of the variables while keeping the other fixed, until
convergence is&amp;nbsp;reached.&lt;/p&gt;
&lt;p&gt;The update of \$latex V\$ (the dictionary) is computed as the solution
of a Lasso least squares problem.  We allow the user to choose between
the least angle regression method (&lt;span class="caps"&gt;LARS&lt;/span&gt;) or stochastic gradient descent
as algorithms to solve the Lasso&amp;nbsp;problem.&lt;/p&gt;
&lt;p&gt;The update of \$latex U\$ is block coordinate descent with warm restart.
This is a batch adaptation of an online algorithm proposed by Mairal et
al. in&amp;nbsp;[[1]][].&lt;/p&gt;
&lt;h1&gt;Sparse &lt;span class="caps"&gt;PCA&lt;/span&gt; as a&amp;nbsp;transformer&lt;/h1&gt;
&lt;p&gt;Of course, in order to be of practical use, the code needs to be
refactored into a scikits.learn transformer object, just like
&lt;code&gt;scikits.learn.decomposition.pca&lt;/code&gt;. This means that the optimization
problem described above corresponds to the fitting stage. The post-fit
state of the transformer is given by the learned components (the matrix
\$latex V\$&amp;nbsp;above).&lt;/p&gt;
&lt;p&gt;In order to transform new data according to the learned sparse &lt;span class="caps"&gt;PCA&lt;/span&gt; model
(for example, prior to classification of the test data), we simply need
to do a least squares projection of the new data on the sparse&amp;nbsp;components.&lt;/p&gt;
&lt;h1&gt;What is it good&amp;nbsp;for?&lt;/h1&gt;
&lt;p&gt;For applications such as text and image processing, its great advantage
is interpretability. When running a regular &lt;span class="caps"&gt;PCA&lt;/span&gt; on a set of documents in
bag of words format, we can find an interesting visualisation on a
couple of components, and it can show discrimination or clusters. The
biggest problem is that the maximum variance components found by &lt;span class="caps"&gt;PCA&lt;/span&gt;
have very dense expressions as linear combinations of the initial
features. In practice, sometimes interpretation is made by simply
marking the \$latex k\$ variables with the highest coefficients in this
representation, and basically interpreting as if the rest are truncated
to 0 (this has been taught to me in a class on &lt;span class="caps"&gt;PCA&lt;/span&gt;&amp;nbsp;interpretation).&lt;/p&gt;
&lt;p&gt;Such an approximation can be highly misleading, and now we offer you the
sparse &lt;span class="caps"&gt;PCA&lt;/span&gt; code that can extract components with only few non-zero
coefficients, and therefore easy to&amp;nbsp;interpret.&lt;/p&gt;
&lt;p&gt;For image data, sparse &lt;span class="caps"&gt;PCA&lt;/span&gt; should extract local components such as,
famously, parts of the face in the case of face&amp;nbsp;recognition.&lt;/p&gt;
&lt;p&gt;Personally I can&amp;#8217;t wait to have it ready for the scikit so that I can
play with it in some of my projects. I have two tasks where I can&amp;#8217;t wait
to see the results: one is related to &lt;a href="http://venefrombucharest.wordpress.com/2011/04/14/a-look-at-romanian-verbs-with-scikits-learn/" title="A look at Romanian verbs with scikits-learn"&gt;Romanian infinitives&lt;/a&gt;, where
&lt;span class="caps"&gt;PCA&lt;/span&gt; revealed structure, and I would love to see how it looks with sparse
n-gram components. The other task is to plug it in as feature extractor
for handwritten digit classification, for my undergraduate&amp;nbsp;thesis.&lt;/p&gt;
&lt;p&gt;&lt;span id="footnote_1"&gt;[1] &lt;a href="http://www.di.ens.fr/sierra/pdfs/icml09.pdf"&gt;http://www.di.ens.fr/sierra/pdfs/icml09.pdf&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[[1]]:&amp;nbsp;#footnote_1&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Mon, 23 May 2011 15:19:00 +0200</pubDate><guid>tag:vene.ro,2011-05-23:blog/sparse-pca.html</guid><category>dictionary learning</category><category>pca</category><category>sparse pca</category><category>SparsePCA</category><category>spca</category><category>scikit-learn</category></item><item><title>Customizing scikits.learn for a specific text analysis task</title><link>http://vene.ro/blog/customizing-scikits-learn-for-a-specific-text-analysis-task.html</link><description>&lt;p&gt;Scikits.learn is a great general library, but machine learning has so
many different application, that it is often very helpful to be able to
extend its &lt;span class="caps"&gt;API&lt;/span&gt; to better integrate with your code. With scikits.learn,
this is extremely easy to do using inheritance and using the pipeline&amp;nbsp;module.&lt;/p&gt;
&lt;h2&gt;The&amp;nbsp;problem&lt;/h2&gt;
&lt;p&gt;While continuing the &lt;a href="http://venefrombucharest.wordpress.com/2011/04/14/a-look-at-romanian-verbs-with-scikits-learn/" title="A look at Romanian verbs with scikits-learn"&gt;morphophonetic analysis of Romanian verbal
forms&lt;/a&gt;, I found the need to streamline my workflow to allow for more
complex models. There were a lot of free model parameters and it would
have been painful to interactively tweak everything in order to find a
good&amp;nbsp;combination&lt;/p&gt;
&lt;p&gt;In my case, I needed to read a file containing infinitives and labels
corresponding to conjugation groups, and run a linear support vector
classifier on this data. The &lt;span class="caps"&gt;SVC&lt;/span&gt; has its C parameter that needs to be
tweaked, but I also had some ideas that arose from the images in my old
post. There, I compared the way the data looked when represented as
differently sized n-gram features. Furthermore, I compared the count
features (ie. features indicating the number of times an n-gram occurs
in a string) with binary features (ie. indicating only whether the
n-gram occurs in the string or not). It looked to me like, for such a
low-level text analysis task, using counts only adds&amp;nbsp;noise.&lt;/p&gt;
&lt;p&gt;For this reason, the &lt;code&gt;feature_extraction.text.CountVectorizer&lt;/code&gt; was not
enough for me. It only returns count features. There was also another
thing that needed to be adjusted: by default, its analyzer uses a
preprocessor that strips accented characters, and I had strong reasons
to believe that Romanian diacritics are very relevant for the learning
task. So, I needed to extend the&amp;nbsp;vectorizer.&lt;/p&gt;
&lt;h2&gt;The&amp;nbsp;solution&lt;/h2&gt;
&lt;p&gt;The code I came up with is &lt;a href="https://github.com/vene/misc-nlp/blob/master/conjugation/grid_search_example/preprocess.py"&gt;here&lt;/a&gt;. I tried to build a class that would
be as specific to my needs as possible. It is important to retain the
full &lt;span class="caps"&gt;API&lt;/span&gt;, however. Note the &lt;code&gt;y=None&lt;/code&gt; parameter in the fit functions. Its
necessity will become clear in a&amp;nbsp;moment.&lt;/p&gt;
&lt;p&gt;Another tricky part was exposing the &lt;code&gt;max_n&lt;/code&gt; parameter from the inner
analyzer. This was not really natural, but it simplified the
constructions later&amp;nbsp;on.&lt;/p&gt;
&lt;p&gt;My &lt;code&gt;InfinitivesExtractor&lt;/code&gt; class builds a data matrix from a list of
strings. After using it, the data needs to be passed to the classifier,
an instance of &lt;code&gt;svm.LinearSVC&lt;/code&gt;. The &lt;code&gt;pipeline&lt;/code&gt;module in scikits.learn
allows us to plug components into eachother in order to build a more
complex object. In this case, we would like a classifier that receives a
string as input, and directly outputs its label. We wouldn&amp;#8217;t want the
user to have to manually use the feature extractor prior to&amp;nbsp;classification.&lt;/p&gt;
&lt;p&gt;The pipeline is very easy to&amp;nbsp;build:  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;pipeline = Pipeline([('extr', InfinitivesExtractor()), ('svc', LinearSVC(multi_class=True))])&lt;/code&gt;&lt;br /&gt;
The pipeline object now works exactly as expected: we can call fit and
predict on it. It also exposes the parameters of its constituents, by
prefixing them with the name of that component. For example, the support
vector machine&amp;#8217;s C parameter can be accessed as&amp;nbsp;pipeline.svc__C.&lt;/p&gt;
&lt;p&gt;All that is left now is to see whether this is a good model, and what
combination of parameters makes it work the best. Scikits.learn provides
a great tool for choosing the parameters: the &lt;code&gt;grid_search&lt;/code&gt; module. When
working with models like support vector machines, model parameters (such
as the radial basis kernel width) usually need to be chosen by cross
validation, because intuition doesn&amp;#8217;t help much when dealing with high
dimensional&amp;nbsp;data.&lt;/p&gt;
&lt;p&gt;Grid search allows the definition of a discrete range of values for
multiple parameters. Then, for each combination of parameters, it fits
and evaluates a model using cross-validation, and the model with the
best score is the winner. Because we combined the components into a
pipeline, it is very easy to run grid search on the combined model, and
to simultaneously tweak the settings both for the extractor and for the&amp;nbsp;classifier.&lt;/p&gt;
&lt;p&gt;After running the grid search using the code &lt;a href="https://github.com/vene/misc-nlp/blob/master/conjugation/grid_search_example/gridsearch.py"&gt;here&lt;/a&gt;, I found that
indeed, using binary features instead of occurence counts improves
performance. I also found that the optimal n-gram length is 5, but the
gain is not that big when compared to a length of 3, which generates a
lot less&amp;nbsp;features.&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;I hope that I managed to show the strength of a well-designed &lt;span class="caps"&gt;API&lt;/span&gt;.
Because of it, it would be very easy to add, for example, an extra layer
for dimensionality reduction before classification. It would only
require an extra item in the pipeline constructor. A call from a
web-based frontend, for example, would be very short and simple. Because
of the consistency in the scikits.learn classes, we can write cleaner
and better code, and therefore work with greater&amp;nbsp;efficiency.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Fri, 29 Apr 2011 14:33:00 +0200</pubDate><guid>tag:vene.ro,2011-04-29:blog/customizing-scikits-learn-for-a-specific-text-analysis-task.html</guid><category>nlp</category><category>scikit-learn</category></item><item><title>An overview of dictionary learning: Terminology</title><link>http://vene.ro/blog/an-overview-of-dictionary-learning-terminology.html</link><description>&lt;p&gt;My GSoC proposal is titled &amp;#8220;Dictionary learning in scikits.learn&amp;#8221; and in
the project, I plan to implement methods used in state of the art
research and industry applications in signal and image processing. In
this post, I want to clarify the terminology&amp;nbsp;used.&lt;/p&gt;
&lt;p&gt;Usually the terms &lt;em&gt;dictionary learning&lt;/em&gt; and &lt;em&gt;sparse coding&lt;/em&gt; are used
interchangably. Also my proposal contains methods such as Sparse &lt;span class="caps"&gt;PCA&lt;/span&gt;
which are technically not &lt;em&gt;sparse coding&lt;/em&gt; but closely related&amp;nbsp;problems.&lt;/p&gt;
&lt;p&gt;The basic idea is the approximation of a signal vector [latex] x \in
\mathbb{R}\^d[/latex] by a linear combination of components, as good as
possible, under certain constraints. This can be formulated as a basic
(unconstrained) loss function measuring the quality of the
approximation: [latex] \mathcal{L}(x, D, \alpha) = \big|\big|x -
D\alpha\big|\big|\^2_2, D \in \mathbb{R}\^{d \times r}, \alpha
\in \mathbb{R}\^r[/latex], where [latex] r[/latex] is the dimension of
the dictionary (the number of &lt;em&gt;components)&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;When working with a dataset of more signal vectors, the overall basic
loss for such an approximation is [latex] \mathcal{L}(X, D, A) =
\sum_{i = 1}\^N \mathcal{L}(x_i, D, \alpha_i) = \big|\big|X -
&lt;span class="caps"&gt;DA&lt;/span&gt;\big|\big|\^2_F[/latex]. Minimizing such a loss function amounts to
finding the closest (in the Frobenius sense) matrix factorization
[latex] &lt;span class="caps"&gt;DA&lt;/span&gt;[/latex] that approximates the data matrix [latex]&amp;nbsp;X[/latex]&lt;/p&gt;
&lt;p&gt;This generic problem is called a &lt;strong&gt;matrix factorization problem&lt;/strong&gt;. Many
classical problems are matrix factorization problems with additional
constraints. For example, &lt;span class="caps"&gt;PCA&lt;/span&gt; is a matrix factorization that constrains
[latex] D[/latex] to be orthogonal. &lt;span class="caps"&gt;NMF&lt;/span&gt; constrains both [latex]
D[/latex] and [latex] A[/latex] to have no negative elements. Sparse
variants of these two decompositions are useful for getting local
components, such as parts of faces. These are obtained by adding an
aditional constraint on the dictionary&amp;nbsp;columns.&lt;/p&gt;
&lt;p&gt;It can  be sometimes useful to consider the dictionary fixed. The signal
processing community has introduced over the years many such
dictionaries, for examples wavelets. These are used, for example, in the
&lt;span class="caps"&gt;JPEG2000&lt;/span&gt; compression&amp;nbsp;standard.&lt;/p&gt;
&lt;p&gt;A very useful represenation is when the dictionary is &lt;em&gt;overcomplete&lt;/em&gt;
([latex] r &gt; d[/latex]). The wavelets are an example of this. Given
such a dictionary, we are interested in an efficient encoding of a
vector [latex] x[/latex], in the sense of sparseness: we want to use as
few dictionary components as possible in our representation. Such a
solution is the vector [latex]\alpha[/latex] minimizing [latex]
\mathcal{L}(x, D, \alpha) +
\lambda\big|\big|\alpha\big|\big|_1[/latex] but other
sparsity-inducing constraints can be used. Such a vector is a &lt;strong&gt;sparse
coding&lt;/strong&gt; of [latex] x[/latex] and it can be solved using algorithms such
as least-angle regression and orthogonal matching&amp;nbsp;pursuit.&lt;/p&gt;
&lt;p&gt;However, we are not limited to using precomputed dictionaries. The term
&lt;strong&gt;dictionary learning&lt;/strong&gt; refers to methods of inferring, given [latex]
X[/latex], a (usually overcomplete) dictionary that will perform good at
sparsely encoding the data in [latex] X[/latex]. Such methods are more
expensive than using precomputed dictionaries, but they perform better,
since the dictionary is optimized for the current&amp;nbsp;dataset.&lt;/p&gt;
&lt;p&gt;Because usually such loss functions are non-convex in [latex] D[/latex]
and [latex] A[/latex] simultaneously, dictionary learning algorithms
alternate between minimizing each while keeping the other fixed. The
step that minimizes [latex] D[/latex] is sometimes called the
&lt;strong&gt;dictionary update&lt;/strong&gt; step, and the one minimizing [latex] A[/latex] is
(similarily to the case where the dictionary is always fixed) the
&lt;strong&gt;sparse coding&lt;/strong&gt; step. Dictionary learning algorithms differ in the
method used for each of this&amp;nbsp;step.&lt;/p&gt;
&lt;p&gt;To resume, many problems can be posed as matrix factorization problems.
Depending on the constraints imposed, the problem becomes interesting
for different applications. Dictionary learning is very good for image
reconstruction. Matrix decompositions with sparse undercomplete
dictionaries such as Sparse &lt;span class="caps"&gt;PCA&lt;/span&gt; can be used to find local features that
constitute the dataset, for example parts of faces, for a dataset of
facial images. &lt;span class="caps"&gt;NMF&lt;/span&gt; can be used in both under and overcomplete settings
and it offers a good model for additive data such as text or images. We
are interested in these variants and they are planned for implementation
in my GSoC&amp;nbsp;proposal.&lt;/p&gt;
&lt;p&gt;Julien Mairal&amp;#8217;s presentation of his work in this domain, available
&lt;a href="http://videolectures.net/icml09_mairal_odlsc/" title="Mairal dictionary learning"&gt;here&lt;/a&gt;, shows the theoretical background of such methods, along with
examples showing state of the art results in image&amp;nbsp;processing.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Fri, 15 Apr 2011 14:10:00 +0200</pubDate><guid>tag:vene.ro,2011-04-15:blog/an-overview-of-dictionary-learning-terminology.html</guid><category>dictionary learning</category><category>scikit-learn</category><category>Uncategorized</category></item><item><title>Newton interpolation and numerical differentiation</title><link>http://vene.ro/blog/newton-interpolation-and-numerical-differentiation.html</link><description>&lt;p&gt;I am sharing some Python code code that I wrote as a school assignment.
This computes the Newton form of the interpolation polynomial of a given
set of points, and allows for the evaluation of both the polynomial and
its derivative, at a given point. This is an accurate way of estimating
the derivative of a complicated&amp;nbsp;function.&lt;/p&gt;
&lt;p&gt;Initially it plots the function, the interpolating polynomial and its
derivative. When clicking on the plot, the tangent to the interpolating
polynomial at the horizontal position of the mouse cursor is&amp;nbsp;plotted.&lt;/p&gt;
&lt;p&gt;It can be found here: &lt;a href="https://gist.github.com/921554"&gt;https://gist.github.com/921554&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Fri, 15 Apr 2011 13:34:00 +0200</pubDate><guid>tag:vene.ro,2011-04-15:blog/newton-interpolation-and-numerical-differentiation.html</guid><category>differentiation</category><category>interpolation</category><category>matplotlib</category><category>newton</category><category>numerical</category><category>numpy</category><category>python</category></item><item><title>A look at Romanian verbs with scikits-learn</title><link>http://vene.ro/blog/a-look-at-romanian-verbs-with-scikits-learn.html</link><description>&lt;p&gt;One of the problems we tackled here at my university is one as old as
the modern Romanian language. It is a problem for linguists, as well as
for foreigners trying to learn the language. We call it the root
alternations&amp;nbsp;problem.&lt;/p&gt;
&lt;p&gt;Similar to French and other languages, Romanian verbs are split into
four groups with different conjugation patterns. Except for the
irregular verbs, this categorization is performed based on the suffix of
the infinitive. However, the conjugation is not straightforward even
within these classes, because many verbs exhibit alternations in their
root. For example, the verb &lt;em&gt;a purta&lt;/em&gt; (to wear) becomes &lt;em&gt;eu port&lt;/em&gt; (I
wear) but &lt;em&gt;el poartă&lt;/em&gt; (he wears). It can be seen that the letter &lt;em&gt;o&lt;/em&gt; in
the root changes to &lt;em&gt;oa&lt;/em&gt; during conjugation. This makes learning the
language quite difficult, because we have no rules to describe when
these changes&amp;nbsp;occur.&lt;/p&gt;
&lt;p&gt;Attempts to formalize such rules from a computer scientific point of
view date back to &lt;span class="caps"&gt;G. C.&lt;/span&gt; Moisil in 1960. Such (incomplete) rules can be
formulated as context-sensitive grammars, since the alternations are
determined by the context in which certain characters&amp;nbsp;appear.&lt;/p&gt;
&lt;p&gt;This leads to the idea of analyzing the verbs from a machine learning
point of view: what can we find out by looking at n-gram representation
of the&amp;nbsp;infinitives?&lt;/p&gt;
&lt;p&gt;This is easy to do within scikits.learn. The &lt;code&gt;feature_extraction.text&lt;/code&gt;
package contains all the necessary tools: the &lt;code&gt;CharNGramExtractor&lt;/code&gt;,
which builds all the n-grams of a string, for n in an interval. Then, a
&lt;code&gt;CountVectorizer&lt;/code&gt; is built on top of the extractor. Its purpose is to
extract the features out of a list of documents and transform them into
a matrix representation of token counts. By postprocessing this matrix
we can obtain a binary representation, indicating only whether a token
occurs in a document or not, instead of the&amp;nbsp;count.&lt;/p&gt;
&lt;p&gt;In this case, documents are Romanian infinitives. This means we are
limited to using short n-grams, because the documents are themselves
short. There is also the question whether anything relevant can be found
out of such a representation which does not encode a lot of&amp;nbsp;information.&lt;/p&gt;
&lt;p&gt;After building the data matrix from the list of verbs, I plotted a 2D
&lt;span class="caps"&gt;PCA&lt;/span&gt; projection and here are the results. I am only posting a teaser for
now, but the results are&amp;nbsp;encouraging:&lt;/p&gt;
&lt;p&gt;[&lt;img alt="Romanian infinitives as 2D projection" src="http://localhost:8001/wp-content/uploads/2011/04/infinitives_pca.png" title="infinitives_pca" /&gt;][]&lt;/p&gt;
&lt;p&gt;From the image it is clear that n-gram representations of the
infinitives induce clusters. Further results suggest that for certain
subclasses of the dataset, such a representation (or even a simpler one)
is enough to clearly answer whether a verb does not exhibit
alternations. This encourages further exploration of this path,
especially supervised and semi-supervised&amp;nbsp;approaches.&lt;/p&gt;
&lt;p&gt;[&lt;img alt="Romanian infinitives as 2D projection" src="http://localhost:8001/wp-content/uploads/2011/04/infinitives_pca.png" title="infinitives_pca" /&gt;]:&amp;nbsp;http://localhost:8001/wp-content/uploads/2011/04/infinitives_pca.png&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Thu, 14 Apr 2011 01:40:00 +0200</pubDate><guid>tag:vene.ro,2011-04-14:blog/a-look-at-romanian-verbs-with-scikits-learn.html</guid><category>alternations</category><category>computational linguistics</category><category>infinitives</category><category>pca</category><category>principal components analysis</category><category>nlp</category><category>scikit-learn</category></item><item><title>Tweaking matplotlib subplots for pretty results</title><link>http://vene.ro/blog/tweaking-matplotlib-subplots-for-pretty-results.html</link><description>&lt;p&gt;When plotting multiple subplots using matplotlib, the axes rarely look
pretty with the default configuration. Since matplotlib figures are
abstract objects, designed for consistency in print as well as on
screen, tweaking their layout can get&amp;nbsp;tricky.&lt;/p&gt;
&lt;h3&gt;An&amp;nbsp;example&lt;/h3&gt;
&lt;p&gt;The following code is taken from the &lt;a href="http://scikit-learn.sourceforge.net/auto_examples/applications/plot_face_recognition.html" title="face recognition example"&gt;face recognition example&lt;/a&gt; in
scikits.learn:&lt;br /&gt;
&lt;code&gt;pl.figure(figsize=(1.8 * n_col, 2.4 * n_row))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This is very confusing at first, for somebody used to work on screen:
the quantities in there are actually inches! These are converted
implicitly to pixels through the dpi parameter, which is left as default
(80 dpi) in this&amp;nbsp;example.&lt;/p&gt;
&lt;p&gt;Then, it gets even worse: In order to tweak the positioning of the
subplots, this is what is&amp;nbsp;done:  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;pl.subplots_adjust(bottom=0, left=.01, right=.99, top=.90, hspace=.35)&lt;/code&gt;&lt;br /&gt;
Now, all of these are percents of the image height/width. The margins
are sort of like &lt;span class="caps"&gt;CSS&lt;/span&gt;-style margins, only relative to the bottom left
corner. In other words, &lt;code&gt;right=.99&lt;/code&gt; means that the right margin is 1%
away from the right&amp;nbsp;edge.&lt;/p&gt;
&lt;p&gt;The parameters &lt;code&gt;hspace&lt;/code&gt; and &lt;code&gt;wspace&lt;/code&gt; control the spacing between the
subplots. However these are kind of hard to get right, because,
obviously, there are more settings than there are degrees of&amp;nbsp;freedom.&lt;/p&gt;
&lt;h3&gt;My&amp;nbsp;tip&lt;/h3&gt;
&lt;p&gt;On my system, the default matplotlib backend is TkAgg. The matplotlib
backend controls the graphical environment that builds the plot windows,
as well as the rendering engine used. TkAgg has a &amp;#8220;configure subplots&amp;#8221;
button that opens a popup window with sliders to visually adjust the
parameters above. The problem is that the sliders are unlabeled, so I
needed to do an heuristic by first setting the parameters by hand and
then exploring the direction in which they need to be&amp;nbsp;changed.&lt;/p&gt;
&lt;p&gt;When I tried different backends, I found that WXAgg has labeled sliders.
This means you can adjust your subplots visually and you will have the
parameter values to use in the call to &lt;code&gt;subplots_adjust&lt;/code&gt; in one&amp;nbsp;go!&lt;/p&gt;
&lt;p&gt;You can set your backend to WXAgg by adding the line &lt;code&gt;backend: WXAgg&lt;/code&gt; in
your &lt;a href="http://matplotlib.sourceforge.net/users/customizing.html#the-matplotlibrc-file" title="Customizing matplotlib"&gt;matplotlibrc file&lt;/a&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Mon, 04 Apr 2011 20:53:00 +0200</pubDate><guid>tag:vene.ro,2011-04-04:blog/tweaking-matplotlib-subplots-for-pretty-results.html</guid><category>matplotlib</category><category>python</category></item><item><title>On setuptools subpackages</title><link>http://vene.ro/blog/on-setuptools-subpackages.html</link><description>&lt;p&gt;Today, I spent more than two hours trying to figure out why, despite
things working out fine in my development scikits.learn folder,
&lt;code&gt;python setup.py install&lt;/code&gt; would completely ignore the module I
refactored into a&amp;nbsp;subpackage.&lt;/p&gt;
&lt;p&gt;I imagined that simply adding it to the parent &lt;code&gt;__init__.py __all__&lt;/code&gt;
attribute would do, I kind of thought that setuptools automatically
finds the&amp;nbsp;subpackages.&lt;/p&gt;
&lt;p&gt;At first I thought of looking in &lt;code&gt;setup.py&lt;/code&gt;, but I only examined the one
in the topmost directory, which, in the case of scikits.learn, is two
degrees of separation away from the actual setup.py that takes care of
subpackages (ie. I was looking at &lt;code&gt;/setup.py&lt;/code&gt; instead of
&lt;code&gt;/scikits/learn/setup.py&lt;/code&gt;).  This had me fooled for a&amp;nbsp;while.&lt;/p&gt;
&lt;p&gt;The steps to add a working and installable module to a python
setuptools-based project are as&amp;nbsp;follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Add a &lt;code&gt;__init__.py&lt;/code&gt; file in the folder (ie.
    &lt;code&gt;/scikits/learn/decomposition/__init__.py&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;If the module requires compiling or any special attention, add an
    appropriate  &lt;code&gt;__setup__.py&lt;/code&gt; file in the&amp;nbsp;folder.&lt;/li&gt;
&lt;li&gt;Update the &lt;code&gt;__init__.py __all__&lt;/code&gt; attribute in the parent folder (ie.
    &lt;code&gt;/scikits/learn/__init__.py&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Update the &lt;code&gt;setup.py&lt;/code&gt; in the parent folder (ie.
    &lt;code&gt;/scikits/learn/setup.py&lt;/code&gt;) by adding something like:&lt;br /&gt;
&lt;code&gt;config.add_subpackage('decomposition')&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Don&amp;#8217;t forget to do the same for the tests&amp;nbsp;subfolder!&lt;/p&gt;
&lt;h2&gt;Conclusions&lt;/h2&gt;
&lt;p&gt;While wasting so much time due to a simple beginner&amp;#8217;s mistake is not
very pleasant, I am not frustrated with setuptools. On the contrary, now
that I understand it better I can appreciate its flexibility and
clarity, when compared to, for example, MSBuild and Visual Studio
project files. Just one more reason to love&amp;nbsp;Python!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Mon, 04 Apr 2011 15:01:00 +0200</pubDate><guid>tag:vene.ro,2011-04-04:blog/on-setuptools-subpackages.html</guid><category>python</category><category>setuptools</category></item><item><title>My first scikits.learn coding sprint</title><link>http://vene.ro/blog/my-first-scikits-learn-coding-sprint.html</link><description>&lt;p&gt;The fifth &lt;a href="http://scikit-learn.sourceforge.net/" title="scikits.learn"&gt;scikits.learn&lt;/a&gt; coding sprint took place Friday, April 1st
2011. For anyone who is not familiar with it, scikits.learn is a fast
and easy to use machine learning toolkit for the pylab environment
(Python, NumPy, SciPy,&amp;nbsp;Matplotlib.)&lt;/p&gt;
&lt;p&gt;This was a good opportunity for me to get code reviews by the developers
in order to bring my &lt;span class="caps"&gt;NMF&lt;/span&gt; code up to standards, so that it can be merged.
Though I live far from every nucleus of scikits-learn developers, I
efficiently participated via &lt;span class="caps"&gt;IRC&lt;/span&gt;. This way, I also got the chance to
help out a bit on Mathieu Blondel&amp;#8217;s Kernel &lt;span class="caps"&gt;PCA&lt;/span&gt; code, which will also be
merged into&amp;nbsp;main soon.&lt;/p&gt;
&lt;h2&gt;How it felt&amp;nbsp;like&lt;/h2&gt;
&lt;p&gt;Short answer:&amp;nbsp;awesome!&lt;/p&gt;
&lt;p&gt;Slightly longer answer: Everybody was very encouraging  and helpful.
They gave me a lot of feedback from which I learned a lot, and they
manifested the intention to merge soon. It is a pleasure to work on
projects that you like and use, especially when the projects leaders and
collaborators are so good to work&amp;nbsp;with.&lt;/p&gt;
&lt;p&gt;But the main reason why it makes me feel so good is that I&amp;#8217;m proud to
able to contribute on a project that I consider very significant and the
best in the field from many points of&amp;nbsp;view.&lt;/p&gt;
&lt;h2&gt;What I got&amp;nbsp;done&lt;/h2&gt;
&lt;p&gt;Most of my work was on the non-negative matrix factorization module that
I began some while back, but only intermitently worked on. It is now a
solid module with high test coverage, documentation, and a cool simple
example showing a sparse set of features for the digits dataset in
scikits.learn.  Apart from all the minor fixes in overall code quality
and cleanliness, probably what is the most relevant is the improvement
and the study of the initialization methods. I will look into this
further and document it on this blog, the point is that the choice of
initialization method greatly influences the speed of convergence, and
in the case of a high-tolerance setting, also the error obtained. Some
initializations are more fit for sparsity settings, while others are
more fit for dense&amp;nbsp;settings.&lt;/p&gt;
&lt;p&gt;I have a theory that I plan to test out, regarding the use of different
initialization methods for components and for data in a sparse&amp;nbsp;setting.&lt;/p&gt;
&lt;h2&gt;What I&amp;nbsp;learned&lt;/h2&gt;
&lt;p&gt;I think my greatest improvement was in terms of workflow and efficiency.
While my code was under review, I was receiving frequent comments on my
git pull request, and eventually I ended up responding to some comments
even before they were posted :). I sent small fixes as pull requests to
help other developers as much as I could. Before scikits.learn I had
never worked on a project with so many developers, and I think I handled
it well, even though I asked once or twice on the &lt;span class="caps"&gt;IRC&lt;/span&gt; channel for pieces
of&amp;nbsp;git-fu.&lt;/p&gt;
&lt;p&gt;I learned that it&amp;#8217;s difficult to tweak matplotlib subplots! I&amp;#8217;m still
staring at Alexandre Gramfort&amp;#8217;s tweak in my example and I have no idea
what he did to make it look so good. But I&amp;#8217;ll figure it out soon, I&amp;#8217;m&amp;nbsp;sure.&lt;/p&gt;
&lt;p&gt;I also learned a lot more about the intricacies of the scikits.learn
APIs, the philosophy of ease of use, and the project tree in&amp;nbsp;general.&lt;/p&gt;
&lt;p&gt;In short, the coding sprint has been a great and rewarding experience,
for which I thank all of you guys&amp;nbsp;there!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Sat, 02 Apr 2011 20:12:00 +0200</pubDate><guid>tag:vene.ro,2011-04-02:blog/my-first-scikits-learn-coding-sprint.html</guid><category>coding sprint</category><category>scikit-learn</category></item><item><title>About</title><link>http://vene.ro/blog/about.html</link><description>&lt;p&gt;My name is Vlad, I am a master&amp;#8217;s student at the University of Bucharest,
I work there at the Centre for Computational Linguistics, and I am a
contributor to the Python machine learning library &lt;a href="http://scikit-learn.org" title="scikit-learn"&gt;scikit-learn&lt;/a&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Wed, 30 Mar 2011 08:59:00 +0200</pubDate><guid>tag:vene.ro,2011-03-30:blog/about.html</guid></item><item><title>Hello world!</title><link>http://vene.ro/blog/hello-world-2.html</link><description>&lt;p&gt;This is the blog where I will post updates regarding my work
on&lt;a href="http://scikit-learn.sourceforge.net/" title="scikits-learn"&gt;scikits-learn.&lt;/a&gt; I am applying as a GSoC 2011 student with the &lt;span class="caps"&gt;PSF&lt;/span&gt;
for work on this machine learning&amp;nbsp;library.&lt;/p&gt;
&lt;p&gt;I will also post related work that I do in the machine learning&amp;nbsp;field.&lt;/p&gt;
&lt;p&gt;I hope to prove an enjoyable read for everybody who stumbles on to this
site, or for those who will be forced to review it&amp;nbsp;:)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">vene</dc:creator><pubDate>Wed, 30 Mar 2011 08:59:00 +0200</pubDate><guid>tag:vene.ro,2011-03-30:blog/hello-world-2.html</guid><category>Uncategorized</category></item></channel></rss>