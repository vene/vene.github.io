<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Optimizing with constraints: reparametrization and geometry.</title>
  <meta name="author" content="Vlad" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
  integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
  crossorigin="anonymous"></script>
  <link rel="stylesheet" type="text/css" 
        href="//vene.ro/theme/css/main.css" />
  <link rel="stylesheet" type="text/css" 
        href="//vene.ro/theme/css/pygment.css" />
  <link rel="stylesheet" type="text/css" 
        href="//vene.ro/theme/css/typogrify.css" />
  <link rel="shortcut icon" href="//vene.ro/favicon.ico" />
  <link href="//vene.ro/" type="application/atom+xml"
        rel="alternate" title="Vlad Niculae ALL Atom Feed" />
  <link href="//fonts.googleapis.com/css?family=PT+Mono|PT+Serif" rel="stylesheet"> 

  <!-- OpenGraph Info -->

  <script src="//vene.ro/theme/js/main.js"></script>

</head>

<body>
<div id="container">
<header>
  <nav class="navmenu" id="navmenu">
    <li id="homelink"><a href="/">Vlad Niculae</a>
    </li><li class="menu"><a href="//vene.ro/papers.html">Papers</a>
    </li><li class="menu"><a href="//vene.ro/blog/">Blog</a>
    </li><li class="menu"><a href="//vene.ro/teaching.html">Teaching</a>
   </li>
   </nav>
 </header>
 <div id="main">
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="//vene.ro/drafts/mirror-descent.html" rel="bookmark"
           title="Permalink to Optimizing with constraints: reparametrization and geometry.">Optimizing with constraints: <br>reparametrization and&nbsp;geometry.</a></h1>
<p class="subtitle"><time datetime="2020-09-11T00:00:00+02:00">Fri, 11 Sep 2020</time><label for="mirror-descent" class="margin-toggle"> ⊕</label><input type="checkbox" id="mirror-descent" class="margin-toggle" /><span class="marginnote">Category: <a href="//vene.ro/category/optimization.html">optimization</a><br />
</span></p>    </header>

    <div class="entry-content">
      <p>When training machine learning models, and deep networks in particular,
we typically use gradient-based methods. But if we require the weights to
satisfy some constraints, things quickly get more&nbsp;complicated.</p>
<p>Some of the most popular strategies for handling constraints, while seemingly
very different at first sight, are deeply connected. In this post, we will
explore these connections and demonstrate them in PyTorch on a friendly&nbsp;example. </p>
<p><strong>Outline.</strong> </p>
<div class="toc">
<ul>
<li><a href="#why-are-constraints-challenging">Why are constraints&nbsp;challenging?</a></li>
<li><a href="#ways-to-deal-with-constraints">Ways to deal with constraints.</a><ul>
<li><a href="#reparametrization">Reparametrization.</a></li>
<li><a href="#projected-gradient">Projected&nbsp;gradient.</a></li>
</ul>
</li>
<li><a href="#generalizing-the-projected-gradient-method-with-divergences">Generalizing the projected gradient method with&nbsp;divergences.</a></li>
<li><a href="#duality-between-mirror-descent-and-naturalgradient">Duality between mirror descent and&nbsp;natural&nbsp;gradient.</a></li>
<li><a href="#conclusions">Conclusions.</a></li>
<li><a href="#acknowledgements">Acknowledgements.</a></li>
</ul>
</div>
<script src="https://unpkg.com/d3@3/d3.min.js"></script>

<style type="text/css">

#plotdiv {text-align: center;}

.rules line, .rules path {
  shape-rendering: crispEdges;
  stroke: #00000;
}

.series path {
  fill: none;
  stroke: #348;
}

.labels {
    font-family: sans-serif;
    font-size: .7em;
}

.thick {
  stroke-width: 4px;
}

.dashed {
    stroke-width: 1px;
}

.unconstr{ fill: gray };
.constr{ fill: black };
</style>

<div class="arithmatex">\[
\newcommand\pfrac[2]{\frac{\partial #1}{\partial #2}}
\newcommand\DP[2]{\left\langle #1, #2 \right\rangle}
\]</div>
<h1 id="why-are-constraints-challenging">Why are constraints challenging?<a class="headerlink" href="#why-are-constraints-challenging" title="Permanent link">&para;</a></h1>
<p>In machine learning, we fit models to data by minimizing an&nbsp;objective,</p>
<div class="arithmatex">\[\min_{x \in \mathcal{X}} f(x). \tag{OPT}\]</div>
<p>Here, <span class="arithmatex">\(x\)</span> denotes the parameters to be learned, for instance, the neural network weights.
They typically take values in <span class="arithmatex">\(\mathcal{X}=\reals\)</span>, and we train networks by
some variant of the <em>gradient</em> method: we choose an initial configuration <span class="arithmatex">\(x^{(0)}\)</span>
and successively applying updates of the&nbsp;form:</p>
<div class="arithmatex">\[
x^{(t+1)} \leftarrow x^{(t)} - \alpha^{(t)} \nabla f(x).
\]</div>
<p>In deep learning, we typically use stochastic flavors that
nonetheless perform well and are efficient.  Here, we will focus on a relatively
nice example: a convex quadratic function <span class="arithmatex">\(f\)</span>.
We will see that, even in this case, constraints quickly complicate&nbsp;things.</p>
<p><strong>Why constrain?</strong>
For modeling reasons, we might want to impose restrictions on some of the weights
<span class="arithmatex">\(x\)</span>.  Perhaps one of the parameter corresponds to the variance of a
distribution, so it cannot be negative. Or perhaps a parameter denotes
some sort of &#8220;gate&#8221;, or mixture between two alternatives <span class="arithmatex">\(xa_1 + (1-x)a_2\)</span>. 
In this case, we would need to constrain <span class="arithmatex">\(x \in [0, 1]\)</span>. This is often called a
<em>box constraint</em> and it is one of the most friendly types of inequality
constraint we might deal&nbsp;with.</p>
<p>For one-dimensional convex problems, <em>i.e.,</em> <span class="arithmatex">\(\mathcal{X} = [a, b] \subset
\reals\)</span>, box constraints do not complicate the problem: we can solve the
unconstrained problem <span class="arithmatex">\(x_{\text{unc}}^* = \arg\min_{x\in\reals} f(x)\)</span>.  If the
answer satisfies the constraint, then it must be the solution of the constrained
problem as well. If not, the answer can be found by <em>clipping</em> to the&nbsp;interval:</p>
<div class="arithmatex">\[ x^\star = \operatorname{clip}_{[a,b]}(x_\text{unc}^\star)
\coloneqq \min(a, \max(b, x_\text{unc}^\star)).
\]</div>
<details class="note"><summary>Proof</summary><p>We add non-negative dual variables <span class="arithmatex">\(\mu_a\)</span> and <span class="arithmatex">\(\mu_b\)</span> to handle the inequality
constraints <span class="arithmatex">\(x \geq a\)</span> and <span class="arithmatex">\(x \leq b\)</span>, and write the&nbsp;lagrangian,</p>
<div class="arithmatex">\[\mathcal{L}(x) = f(x) + \mu_a (a-x) + \mu_b(x-b).\]</div>
<p>An optimal <span class="arithmatex">\(x^\star\)</span> must satisfiy the original constraints <span class="arithmatex">\((a \leq x^\star \leq b)\)</span>
and be a stationary point of the&nbsp;lagrangian:</p>
<div class="arithmatex">\[ 
D_x \mathcal{L}(x^\star) = 0 \iff f'(x^\star) = \mu_a - \mu_b.
\tag{F}
\]</div>
<p>The dual variables must be non-negative and satisfy
complementary&nbsp;slackness:</p>
<div class="arithmatex">\[
\mu_a (a - x^\star) = 0, \quad\text{and}\quad \mu_b (x^\star - b) = 0.
\]</div>
<p>Let <span class="arithmatex">\(x^\star_\text{unc}\)</span> be the solution of the unconstrained problem,
satisfying  <span class="arithmatex">\(f'(x^\star_\text{unc})=0\)</span>. If 
<span class="arithmatex">\(a \leq x^\star_\text{unc} \leq b\)</span>, then <span class="arithmatex">\(x^\star=x^\star_\text{unc}\)</span>, and
choosing <span class="arithmatex">\(\mu_a=\mu_b=0\)</span> satisfies all&nbsp;conditions.</p>
<p>Otherwise, <span class="arithmatex">\(x^\star_\text{unc}\)</span> is either too small or too large.
Assume <span class="arithmatex">\(x^\star_\text{unc} &gt; a\)</span> and take <span class="arithmatex">\(x^\star = a\)</span>. Then we have <span class="arithmatex">\(\mu_b=0\)</span>,
and from (F) we must have <span class="arithmatex">\(\mu_a = f'(a)\)</span>. Is this a valid value for the
dual variable? We must check that <span class="arithmatex">\(f'(a) \geq 0\)</span>. Convex <span class="arithmatex">\(f\)</span> satisfies
<span class="arithmatex">\( f(a) - f(x) \leq f'(a)(a-x) \)</span>
for any <span class="arithmatex">\(x\)</span>, including the minimizer <span class="arithmatex">\(x=x^\star_\text{unc}\)</span>.
By assumption, <span class="arithmatex">\(a-x^\star_\text{unc} &gt; 0\)</span>, so we may divide by it&nbsp;yielding</p>
<div class="arithmatex">\[ \mu_a = f'(a) \geq \frac{f(a)-f(x^\star_\text{unc})}{a-x^\star_\text{unc}} \geq 0. \]</div>
<p>The case <span class="arithmatex">\( x^\star_\text{unc} &gt; b \)</span> follows&nbsp;similarly.</p>
</details>
<p>The following interactive demo might convince you that this is true. We show the
1-d function <span class="arithmatex">\(f(x) = (x - x_0)^2 / 2\)</span> and its minimizer constrained to <span class="arithmatex">\([0, 1]\)</span>.
Drag the slider to change the location of the unconstrained minimizer <span class="arithmatex">\(x_0\)</span>.</p>
<p><div id="plotdiv">
  <svg id="onedimplot" preserveAspectRatio="xMinYMin meet" viewBox="0 0 550 150"></svg> <br />
    <input type="range" min="-1" max="2" step=".001" oninput="plot(this.value)" onchange="plot(this.value)">
  </div></p>
<script>
var w = 500;
var h = 100;

var x = d3.scale.linear().domain([-2, 3]).range([0, w]);
var xint = d3.scale.linear().domain([0, 1]);
var y = d3.scale.linear().domain([ 0, 1]).range([h, 0]);

//  var svg = d3.select("body").append("svg")
//  .attr("width", w + 50)
//  .attr("height", h + 50);
var svg = d3.select("#onedimplot");
    var vis = svg.append("svg:g").attr("transform", "translate(25,25)")
    make_rules();

    plot(0.5);


    function plot(x0) {
        var quadratic = make_quadratic(x0);
        chart_line(quadratic, x0);
    }

    function make_quadratic(x0) {
            return (function(t) {
                    return 0.5 * (t - x0) * (t - x0) + 0.2;
            });
    }

function chart_line(func, x0) {
            vis.selectAll('.dots').remove();
            vis.selectAll('.series').remove();
    var g = vis.append("svg:g").classed("series", true)

    g.append("svg:path")
        .classed("dashed", true)
        .attr("d", function(d) { return d3.svg.line()(
          x.ticks(100).map(function(t) {
            return [ x(t), y(func(t)) ]
          })
         )})

    g.append("svg:path")
        .classed("thick", true)
        .attr("d", function(d) { return d3.svg.line()(
          xint.ticks(100).map(function(t) {
            return [ x(t), y(func(t)) ]
          })
                    )})


            vis.append('circle')
                .classed("dots", true)
                .classed("unconstr", true)
                .attr("r", 5)
                .attr("cx", function(d) { return x(x0); })
                .attr("cy", function(d) { return y(func(x0)); })

          var xstar = Math.min(Math.max(x0, 0), 1);

            vis.append('circle')
                .classed("dots", true)
                .classed("constr", true)
                .attr("r", 5)
                .attr("cx", function(d) { return x(xstar); })
                .attr("cy", function(d) { return y(func(xstar)); })
}

function make_rules() {
    var rules = vis.append("svg:g").classed("rules", true)

    function make_x_axis() {
        return d3.svg.axis()
                .scale(x)
                .orient("bottom")
                .ticks(10)
    }


    rules.append("svg:g").classed("grid x_grid", true)
            .attr("transform", "translate(0,"+h+")")
            .call(make_x_axis()
                .tickSize(0,0,0)
                .tickFormat("")
            )

    rules.append("svg:g").classed("labels x_labels", true)
            .attr("transform", "translate(0,"+h+")")
            .call(make_x_axis()
                .tickSize(1)
            )
}
</script>

<p>However, in dimension two or more, clipping no longer works, because of
interactions between the variables. We demonstate this on a quadratic problem
which will become the main focus of the rest of this&nbsp;post,</p>
<div class="arithmatex">\[ \min_{x \in \mathcal{X}} 
f(x) \coloneqq \frac{1}{2}~(x - x_0)^\top Q (x - x_0).\tag{QP} \]</div>
<p>Let us visualize this problem for the specific case of
the unit square <span class="arithmatex">\(\mathcal{X} = [0,1] \times [0,1] \subset \reals^2\)</span>,
with <span class="arithmatex">\(x_0 = (1.5, .1)\)</span>, and 
<span class="arithmatex">\(Q = \left(\begin{smallmatrix}3 &amp; 2 \\\\ 2 &amp; 3 \end{smallmatrix}\right)\)</span>.
If not for the constraints, since <span class="arithmatex">\(Q\)</span> is positive definite, the minimum
would be <span class="arithmatex">\(x^\star_\text{unc} = x_0\)</span>.<label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">Because <span class="arithmatex">\(f(x_0)=0,\)</span> and positive
definiteness guarantess <span class="arithmatex">\(f(x) &gt; 0\)</span> for any <span class="arithmatex">\(x \neq x_0\)</span>.</span>
But a contour plot shows that the constrained minimum <span class="arithmatex">\(x^\star\)</span> is not the same as the
result of clipping the unconstrained minimum to the&nbsp;box.</p>
<p><img alt="quadratic landscape" src="/images/mirror_quad_landscape.png"></img></p>
<p>This means that, in general, we cannot simply ignore the constraints and apply
them at the end, but we need to bake them into our optimization strategy.<label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">
There is an important special case where (<span class="caps">QP</span>) can be solved exactly: the
case <span class="arithmatex">\(Q = I\)</span>. In this case, the problem becomes
<span class="arithmatex">\(\arg\min_{x \in \mathcal{X}} \| x - x_0 \|^2_2,\)</span>
which is known as the <em>Euclidean projection</em> of <span class="arithmatex">\(x_0\)</span> onto <span class="arithmatex">\(\mathcal{X}\)</span>.
If <span class="arithmatex">\(\mathcal{X}\)</span> are box constraints, the projection decomposes into a series of
independent 1-d projections, which we&#8217;ve seen can be solved by&nbsp;clipping.</span></p>
<p>As a warm up, let us implement our quadratic function
<span class="arithmatex">\(f(x) = \frac{1}{2} (x - x_0)^\top Q (x - x_0)\)</span> in PyTorch, 
as well as a minimal gradient descent from&nbsp;scratch.</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">torch</span>

<span class="n">torch</span><span class="o">.</span><span class="n">set_default_dtype</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

<span class="n">x0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">])</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
                  <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]])</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x0</span>
    <span class="n">Qz</span> <span class="o">=</span> <span class="n">z</span> <span class="o">@</span> <span class="n">Q</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="n">Qz</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">optim_grad</span><span class="p">(</span><span class="n">x_init</span><span class="p">,</span> <span class="n">lr</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x_init</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">x</span><span class="o">.</span><span class="n">data</span> <span class="o">-=</span> <span class="n">lr</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">grad</span>
        <span class="n">x</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">x</span>
</code></pre></div>


<p>This procedure quickly converges to <span class="arithmatex">\(x^\star_\text{unc} = (1.5, .1)\)</span>.</p>
<h1 id="ways-to-deal-with-constraints">Ways to deal with constraints.<a class="headerlink" href="#ways-to-deal-with-constraints" title="Permanent link">&para;</a></h1>
<p>When faced with a box-constrained optimization problem, these are the ideas that
most practitioners would turn to.<label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">This turns out to be a handy personality
quiz to see if somebody resonates more with neural networks or with convex&nbsp;optimization.</span></p>
<ol>
<li>
<p><em>Reparamtrization (<span class="caps">REP</span>).</em> Circumvent the constraints on <span class="arithmatex">\(x\)</span>, 
    by expressing the function in terms of unconstrained variables <span class="arithmatex">\(u\)</span>
    such that <span class="arithmatex">\(x_i = \sigma(u_i)\)</span>, where <span class="arithmatex">\(\sigma : \reals \to \mathcal{X}\)</span> is a
    &#8220;squishing&#8221; nonlinearity.
    We can then perform unconstrained minimiziation on <span class="arithmatex">\(f \circ \sigma\)</span>.
    For <span class="arithmatex">\(\mathcal{X}=[0,1]^d\)</span>, we may use the logistic
    function<label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span class="sidenote">General intervals <span class="arithmatex">\([a,b]\)</span> are obtained by affinely
    transforming <span class="arithmatex">\([0,1]\)</span>.</span></p>
<div class="arithmatex">\[ \sigma(u) = \frac{1}{1 + \exp(-u)}.\]</div>
</li>
<li>
<p><em>Projected gradient (<span class="caps">PG</span>).</em> Perform unconstrained gradient updates, then
    project back onto the domain after each&nbsp;update:</p>
<div class="arithmatex">\[
\begin{aligned}
x^{(t+0.5)} &amp;\leftarrow x^{(t)} - \alpha^{(t)} \nabla f(x^{(t)}) \\
x^{(t+1)} &amp;\leftarrow \operatorname{Proj}_\mathcal{X}\big(x^{(t+0.5)}\big)
\\
\end{aligned}
\]</div>
</li>
</ol>
<p><span class="caps">REP</span> is convenient when working with neural network libraries like PyTorch,
because it can be implemented just by changing our model, without requiring
modifications to the optimization code. However, the resulting problem (after
reparametrization) is no longer convex in <span class="arithmatex">\(u\)</span>, even if the original problem was
convex in <span class="arithmatex">\(x\)</span>. <span class="caps">PG</span> directly solves the convex optimization problem (<span class="caps">QP</span>), but
the intermediate iterates <span class="arithmatex">\(x^{(t+0.5)}\)</span> can leave <span class="arithmatex">\(\mathcal{X}\)</span>,
leading to a possibly less stable or too aggressive&nbsp;trajectory.</p>
<p>In this post, we will explore the connection between the two by studying <em>mirror
descent</em> and its information-geometric interpretation as natural gradient
in a dual space. But first, let&#8217;s explore our two initial&nbsp;ideas.</p>
<h3 id="reparametrization">Reparametrization.<a class="headerlink" href="#reparametrization" title="Permanent link">&para;</a></h3>
<p>Instead of optimizing w.r.t. the constrained variables <span class="arithmatex">\(x\)</span>, we introduce an
underlying variable <span class="arithmatex">\(u\)</span>, such that <span class="arithmatex">\(x_i = \sigma(u_i)\)</span>.<label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle"/><span class="sidenote">This seems to be the
more common method among neural network practitioners; one
place where it shows up often is <em>neural variational inference</em>, where we would
constrain the variance of a learned distribution using a <em>softplus</em>
function.</span>
In our case, we use a logistic sigmoid reparametrization to get the
unconstrained non-convex&nbsp;problem</p>
<div class="arithmatex">\[ \min_{u \in \reals^2} f(\sigma(u)), \]</div>
<p>where <span class="arithmatex">\(\sigma\)</span> is applied element-wise.<br />
When reparametrizing, <span class="arithmatex">\(x\)</span> is no longer a learned parameter, but a function of
the learned parameter <span class="arithmatex">\(u\)</span>. The gradient with respect to <span class="arithmatex">\(u\)</span> can be handled
automatically by PyTorch&nbsp;autodiff:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">optim_reparam</span><span class="p">(</span><span class="n">u_init</span><span class="p">,</span> <span class="n">lr</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u_init</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="n">f</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>  <span class="c1"># compute grad wrt u</span>
        <span class="n">u</span><span class="o">.</span><span class="n">data</span> <span class="o">-=</span> <span class="n">lr</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">grad</span>  <span class="c1"># take gradient step</span>
        <span class="n">u</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">u</span>
</code></pre></div>


<p>With a very small learning rate, we get a glimpse into the dynamics of this
method.<label for="sn-6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-6" class="margin-toggle"/><span class="sidenote">Technically, as the learning rate goes to zero, we are simulating a
continuous <em>gradient flow</em>, of which gradient descent is a discretized
approximation. For more about gradient flows, check out <a href="https://francisbach.com/gradient-flows/">Francis Bach&#8217;s post</a>.</span>
For comparison, we include the unconstrained&nbsp;trajectory.</p>
<p><img alt="quadratic landscape" src="/images/mirror_primal_lr0.010_reparam.png"></img></p>
<p>In practice, we would use a much larger learning rate to accelerate&nbsp;optimization:</p>
<p><img alt="quadratic landscape" src="/images/mirror_primal_lr0.200_reparam.png"></img></p>
<p>We can see that even with a large learning rate, the reparametrization method
takes much smaller steps, especially as it gets closer to the boundary of the
domain. The steps are so small, that we only show the first 20 markers, to avoid
clutter. Why does this happen? At any point <span class="arithmatex">\(u\)</span>, the reparametrized gradient can be written using the
chain&nbsp;rule:</p>
<div class="arithmatex">\[ \pfrac{}{u} f(\sigma(u)) = 
\pfrac{\sigma(u)}{u} 
\pfrac{f(x)}{x}\biggr\rvert_{x=\sigma(u)} \]</div>
<p>This is the unconstrained gradient at <span class="arithmatex">\(x=\sigma(u)\)</span>, rescaled by the Jacobian of <span class="arithmatex">\(\sigma\)</span>.
Since <span class="arithmatex">\(\sigma\)</span> acts elementwise, its Jacobian is a diagonal matrix, with
<span class="arithmatex">\(\pfrac{\sigma(u)_i}{u_i}  = \sigma(u_i)(1 - \sigma(u_i)) = x_i (1 - x_i).\)</span> We can thus see
that as <span class="arithmatex">\(x_i\)</span> approaches <span class="arithmatex">\(0\)</span> or <span class="arithmatex">\(1\)</span>, the reparametrization rescales the
gradient <strong>severely</strong>, bringing the effective step size toward 0. Remember, this
happens <em>automatically</em> via the chain rule! But, although slowly, and along a
slightly winding trajectory, our method finds the right&nbsp;answer.</p>
<h3 id="projected-gradient">Projected gradient.<a class="headerlink" href="#projected-gradient" title="Permanent link">&para;</a></h3>
<p>The projected gradient method is particularly well suited to handling &#8220;simple&#8221; constraints
like the box case, but, unlike reparametrization, requires a different kind of
expertise to get running in the case of complicated constraints.<label for="sn-7" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-7" class="margin-toggle"/><span class="sidenote"><span class="caps">PG</span>
is very popular in convex optimization, useful both for theory and for
practice. However, it does not seem to be so widely used in the pure neural
network world, perhaps mostly because it is not directly supported by the
built-in optimizers in major frameworks.</span>
For box constraints, the projection can be computed efficiently, since
<span class="arithmatex">\(\big[\!\operatorname{Proj}_{[0,1]^d}(x)\big]_i = \operatorname{clip}_{[0,1]}(x_i).\)</span>
The implementation&nbsp;follows:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">optim_pg</span><span class="p">(</span><span class="n">x_init</span><span class="p">,</span> <span class="n">lr</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x_init</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span> 
        <span class="n">x</span><span class="o">.</span><span class="n">data</span> <span class="o">-=</span> <span class="n">lr</span> <span class="o">*</span> <span class="n">grad</span>  <span class="c1"># take gradient step</span>
        <span class="n">x</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># project</span>
        <span class="n">x</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">x</span>
</code></pre></div>


<p>Let&#8217;s visualize the trajectory. From now on, we will zoom in a bit on the region
of&nbsp;interest.</p>
<p><img alt="quadratic landscape" src="/images/mirror_primal_lr0.010_pg.png"></img></p>
<p>It looks like the projected gradient method tends to follow the unconstrained
trajectory while sticking to the boundary of the domain. Of course, with larger
steps, the differences become more&nbsp;pronounced.</p>
<p><img alt="quadratic landscape" src="/images/mirror_primal_lr0.200_pg.png"></img></p>
<p>In this instance, <span class="caps">PG</span> is the clear winner: look how fast it makes progress. With
less well-behaved and non-convex functions this need not be the case. So we are
motivated to delve deeper and explore how <span class="caps">PG</span> and <span class="caps">REP</span> relate, despite seeming so&nbsp;different. </p>
<h1 id="generalizing-the-projected-gradient-method-with-divergences">Generalizing the projected gradient method with divergences.<a class="headerlink" href="#generalizing-the-projected-gradient-method-with-divergences" title="Permanent link">&para;</a></h1>
<p>In the projected gradient method, we take unconstrained steps, which might take
us outside of <span class="arithmatex">\(\mathcal{X}\)</span>, and then move the solution back to <span class="arithmatex">\(\mathcal{X}\)</span> by&nbsp;projection:</p>
<div class="arithmatex">\[ x^{(t+1)} \leftarrow \operatorname{Proj}_\mathcal{X}\big(x^{(t+0.5)}\big). \]</div>
<p>Projection finds the point <span class="arithmatex">\(x \in \mathcal{X}\)</span> closest to <span class="arithmatex">\(x^{(t+0.5)}\)</span>,&nbsp;i.e.,</p>
<div class="arithmatex">\[ \operatorname{Proj}_\mathcal{X}\big(x^{(t+0.5)}\big) \coloneqq \argmin_{x \in \mathcal{X}} \| x - x^{(t+0.5)} \|^2. \]</div>
<p>The projected gradient update can be interpreted as minimizing a regularized linearization of
<span class="arithmatex">\(f\)</span> around the current&nbsp;iterate,</p>
<div class="arithmatex">\[ x^{(t+1)} \leftarrow \arg\min_{x \in \mathcal{X}}  \DP{\nabla f(x^{(t)})}{x} + 
{\frac{1}{2\alpha_t}\|x - x^{(t)}\|^2}.
\]</div>
<details class="note"><summary>Explanation</summary><p>Why does this update make sense, and where does it come from? We are trying to
minimize a function <span class="arithmatex">\(f(x)\)</span>, but we don&#8217;t know what it looks like globally: we only
have access to its value <span class="arithmatex">\(f(x)\)</span> and its gradient <span class="arithmatex">\(\nabla f(x)\)</span> at points <span class="arithmatex">\(x\)</span>
that we may query one at a time. At any point <span class="arithmatex">\(x_0\)</span>,
the first-order Taylor expansion&nbsp;is:</p>
<div class="arithmatex">\[ f(x_0 + \delta) = f(x_0) + \DP{\nabla f(x_0)}{\delta} + o(\|\delta\|). \]</div>
<p>To get a linear approximation of <span class="arithmatex">\(f\)</span> we can plug in <span class="arithmatex">\(\delta = x - x_0\)</span>:</p>
<div class="arithmatex">\[ f(x) =  f(x_0) + \DP{\nabla f(x_0)}{x - x_0} + o(\|x - x_0\|). \]</div>
<p>So as long as <span class="arithmatex">\(x\)</span> is not too far from <span class="arithmatex">\(x_0\)</span>, we&nbsp;have </p>
<div class="arithmatex">\[f(x) \approx \tilde{f}_{x_0}(x) \coloneqq f(x_0) + \DP{\nabla f(x_0)}{x - x_0}.\]</div>
<p>This affine approximation is much easier to
minimize, but it is only accurate locally, therefore, we use it iteratively,
taking a small step, then updating the&nbsp;approximation:</p>
<div class="arithmatex">\[ 
x^{(t+1)} \leftarrow \arg\min_{x \in \mathcal{X}} \tilde f_{x^{(t)}}(x) + \frac{1}{2\alpha_t}\|x - x^{(t)}\|^2. 
\]</div>
<p>where the term on the right keeps us close to <span class="arithmatex">\(x^{(t)}\)</span> to ensure the
approximation is not too bad. Clearing up the constant terms from inside the
<span class="arithmatex">\(\arg\min\)</span> yields the desired&nbsp;expression.</p>
</details>
<p>Rearranging the terms reveals exactly the projected gradient&nbsp;update,</p>
<div class="arithmatex">\[ x^{(t+1)} \leftarrow \operatorname{Proj}_{\mathcal{X}}\big(
x^{(t)} - \alpha_t \nabla f(x^{(t)})\big).\]</div>
<details class="note"><summary>Derivation</summary><div class="arithmatex">\[
\begin{aligned}
 &amp; \arg\min_{x \in \mathcal{X}} \DP{x}{\nabla f(x^{(t)})} + \frac{1}{2\alpha_t} \|x-x^{(t)}\|^2 \\
=&amp; \arg\min_{x \in \mathcal{X}} \DP{x}{\nabla f(x^{(t)})} + \frac{1}{2\alpha_t} \|x\|^2 - \frac{1}{\alpha_t} \DP{x}{x^{(t)}} \\
=&amp; \arg\min_{x \in \mathcal{X}} \alpha_t \DP{x}{\nabla f(x^{(t)})} + \frac{1}{2} \|x\|^2 - \DP{x}{x^{(t)}} \\
=&amp; \arg\min_{x \in \mathcal{X}} \DP{x}{\underbrace{\alpha_t \nabla f(x^{(t)}) - x^{(t)}}_{-x^{(t+0.5)}}} + \frac{1}{2} \|x\|^2 \\
=&amp; \arg\min_{x \in \mathcal{X}} \frac{1}{2} \| x - x^{(t+0.5)} \|^2 \textcolor{gray}{ - \frac{1}{2} \|x^{(t+0.5)}\|} \\
=&amp; \operatorname{Proj}_{\mathcal{X}} (x^{(t+0.5)}).
\end{aligned}
\]</div>
</details>
<p>Now, let&#8217;s pay special attention to 
the function <span class="arithmatex">\(D(x, y) = \| x - y \|^2 = \sum_i (x_i - y_i)^2\)</span>, the <em>squared Euclidean distance</em>.
We employ this function to ensure that each update stays close to <span class="arithmatex">\(x^{(t)}\)</span>,
because the linear approximation is not good if we go to far. But this is not
the only good measure of closeness:
here, geometry enters the stage!  Euclidean geometry is
convenient and comfortable for thinking about spaces like <span class="arithmatex">\(\reals^d,\)</span> but
it is not always the best&nbsp;model.</p>
<p><strong>Bregman divergences</strong>
provide a convenient generalization of the squared
Euclidean distance:<label for="sn-8" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-8" class="margin-toggle"/><span class="sidenote">
Divergences measures of dissimilarity between objects, with weaker requirements
than distance functions: simply that <span class="arithmatex">\(D(x,y) \geq 0\)</span> and <span class="arithmatex">\(D(x,y)=0\)</span> iff. <span class="arithmatex">\(x =
y\)</span>. <a href="https://en.wikipedia.org/wiki/Bregman_divergence">Bregman divergences</a> 
are an important class of divergences. They are convex in the first argument, but not the second.
</span>
given strictly convex, twice-differentiable <span class="arithmatex">\(\Psi\)</span>,</p>
<div class="arithmatex">\[ D_\Psi(x, y) \coloneqq \Psi(x) - \Psi(y) - \DP{\nabla \Psi(y)}{x - y}. \]</div>
<p>For <span class="arithmatex">\(\Psi = \frac{1}{2} \| \cdot \|^2\)</span>, this recovers the squared Euclidean
distance. Replacing <span class="arithmatex">\(\frac{1}{2}\|\cdot\|^2\)</span> by <span class="arithmatex">\(D_\Psi\)</span> in the projected
gradient algorithm leads to a generalization known as <strong>mirror descent</strong>,</p>
<div class="arithmatex">\[
x^{(t+1)} \leftarrow \arg\min_{x \in \mathcal{X}}  \DP{\nabla f(x^{(t)})}{x} + 
{\frac{1}{\alpha_t}D_\psi(x, x^{(t)})}.
\]</div>
<p>Since <span class="arithmatex">\(\Psi\)</span> is twice differentiable and strongly convex, it has a gradient
<span class="arithmatex">\(\psi = \nabla\Psi\)</span> which is invertible. Solving for the mirror descent update
yields a so-called Bregman projection,<label for="sn-9" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-9" class="margin-toggle"/><span class="sidenote">Not technically a projection, 
since iterating it twice need not give the same
result, but the term emphasizes the parallel to the Euclidean&nbsp;case.</span></p>
<div class="arithmatex">\[
\begin{aligned}
u^{(t+0.5)} &amp;\leftarrow \psi(x^{(t)}) - \alpha_t \nabla f(x^{(t)}) \\ 
x^{(t+1)} &amp;\leftarrow 
\argmin_{x \in \mathcal{X}} D_\Psi\big(x,  \psi^{-1}(u^{(t+0.5)})\big). \\
\end{aligned}
\]</div>
<p>If <span class="arithmatex">\(\Psi\)</span> is carefully chosen such that <span class="arithmatex">\(\psi^{-1}(u) \in \mathcal{X}\)</span> for all
<span class="arithmatex">\(u \in \mathcal{U}\)</span>, then the Bregman projection step is trivial,&nbsp;yielding</p>
<div class="arithmatex">\[ x^{(t+1)} \leftarrow \psi^{-1}\big(
\psi(x^{(t)}) - \alpha_t \nabla f(x^{(t)})
\big). \]</div>
<p>Let&#8217;s make this more&nbsp;concrete.</p>
<p>The choice of <span class="arithmatex">\(\Psi\)</span> will define the <em>geometry</em> of our space.
Values in <span class="arithmatex">\([0,1]\)</span> may be interpreted as <em>coin flip</em> probabilities:
the higher, the more likely an event is to happen. An important property of a
binary random variable is its entropy. If <span class="arithmatex">\(x_i \in [0, 1]\)</span> denotes the
probability associated with coin <span class="arithmatex">\(i\)</span>, the entropy&nbsp;is</p>
<div class="arithmatex">\[H(x_i) = -x_i \log x_i - (1 - x_i) \log (1 - x_i).\]</div>
<p>We may extend this additively to vectors as <span class="arithmatex">\(H(x) = \sum_i H(x_i)\)</span>.
On <span class="arithmatex">\(\mathcal{X}=[0, 1]\)</span>, entropy is continuously differentiable and strictly
<strong>concave</strong>, maximized at <span class="arithmatex">\(x=0.5\)</span> and minimized at <span class="arithmatex">\(x=0\)</span> and <span class="arithmatex">\(x=1\)</span>.<label for="sn-10" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-10" class="margin-toggle"/><span class="sidenote"><span class="arithmatex">\(H(0.5) =
\log 2,\)</span><br><span class="arithmatex">\(H(0)=H(1)=0\)</span>.</span> </p>
<p>Let us thus take <span class="arithmatex">\(\Psi = -H\)</span>. Its gradient is <span class="arithmatex">\(\psi : \mathcal{X} \rightarrow \mathcal{U}\)</span>,</p>
<div class="arithmatex">\[ \psi(x) \coloneqq -\nabla H(x) = \log(x) - \log(1-x), \]</div>
<p>with inverse <span class="arithmatex">\(\phi : \mathcal{U} \rightarrow \mathcal{X}\)</span>,</p>
<div class="arithmatex">\[ \phi(u) \coloneqq \psi^{-1}(u) = \frac{1}{1 + \exp(-u)} = \sigma(u). \]</div>
<!--
The entropy induces a Bregman divergence $D_{-H}$, which after some manipulation
can be written as

$$D_{-H}(x, y) = x \log \frac{x}{y} - (1-x) \log \frac{1-x}{1-y}. $$
-->

<p>So, written in terms of the familiar sigmoid, the mirror descent update induced by the negative entropy takes the (remarkable!)&nbsp;form</p>
<div class="arithmatex">\[ x^{(t+1)} = \sigma(\sigma^{-1}(x^{(t)}) - \alpha_t \nabla f(x^{(t)})). \]</div>
<p>Things are beginning to clear up! We can think of the pair of inverse functions
<span class="arithmatex">\((\psi, \phi)\)</span> as maps between <span class="arithmatex">\(\mathcal{X}\)</span> and <span class="arithmatex">\(\mathcal{U}\)</span>.  We will call these
the <strong>primal</strong> and <strong>dual</strong> spaces, respectively. Mirror descent thus
first moves into dual (unconstrained) space, performs an update there, and then moves
back. Reparametrization rewrites the problem in dual coordinates and performs
gradient descent: this is not the same, and the trajectories are quite&nbsp;different!</p>
<p><img alt="quadratic landscape" src="/images/mirror_primal_lr0.010_md.png"></img></p>
<p>With a larger step size, we see that mirror descent takes much larger steps than
reparametrization&nbsp;does.</p>
<p><img alt="quadratic landscape" src="/images/mirror_primal_lr0.200_md.png"></img></p>
<p>Now that we figured out that we may think about the problem in primal or dual
coordinates, we may also visualize the optimization trajectory in dual&nbsp;coordinates.</p>
<p><img alt="quadratic landscape" src="/images/mirror_dual_lr0.010_md.png"></img></p>
<p>Yet, the way that mirror descent leans on moving from <span class="arithmatex">\(\mathcal{X}\)</span> to
<span class="arithmatex">\(\mathcal{U}\)</span> is very familiar to the reparametrization strategy. Is there a
deeper connection between the two? We illuminate it&nbsp;next.</p>
<h1 id="duality-between-mirror-descent-and-naturalgradient">Duality between mirror descent and natural&nbsp;gradient.<a class="headerlink" href="#duality-between-mirror-descent-and-naturalgradient" title="Permanent link">&para;</a></h1>
<p>We have seen that different choices of <span class="arithmatex">\(\Psi\)</span> induce different geometries
even on top of the same space. (Case in point: entropy vs. <span class="arithmatex">\(\frac{1}{2}\|\cdot\|^2\)</span>).
To handle this ambiguity, we need a structure that attaches the geometry along
with the underlying space. This, (with some handwaving), is a <em>Riemannian
manifold</em>: a pair <span class="arithmatex">\((\mathcal{U}, G)\)</span> where <span class="arithmatex">\(\mathcal{X} \subseteq \reals^d\)</span>
is an underlying space<label for="sn-11" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-11" class="margin-toggle"/><span class="sidenote">Riemannian manifolds are more general than this, but
in this post, for simplicity, we only look at the case where <span class="arithmatex">\(\mathcal{X}\subseteq \reals^d\)</span>.
To be fully general, the notation ramps up quickly.
See <a href="https://wiseodd.github.io/techblog/2019/02/22/riemannian-geometry/">Agustinus Kristiadi&#8217;s
post</a> 
and <a href="https://arxiv.org/abs/1808.08271">Frank Nielsen&#8217;s tutorial</a>
for an introduction.
</span>
and the <em>metric tensor</em> <span class="arithmatex">\(G: \mathcal{U} \rightarrow \reals^{d \times d}\)</span>
is a function such that <span class="arithmatex">\(G(u_0)\)</span> is a p.s.d. matrix that induces a 
squared distance around <span class="arithmatex">\(u_0\)</span>:</p>
<div class="arithmatex">\[ d^2_{u_0}(u, v) = \frac{1}{2} (u-v)^\top G(u_0) (u - v). \]</div>
<p>What we observed earlier is in fact a duality between the Riemannian manifolds
<span class="arithmatex">\((\mathcal{X}, \nabla^2 \Psi)\)</span> and <span class="arithmatex">\((\mathcal{U}, \nabla^2 \Phi),\)</span> 
where <span class="arithmatex">\(\Phi\)</span> is the antiderivative of <span class="arithmatex">\(\phi\)</span>, i.e., <span class="arithmatex">\(\nabla\Phi=\phi\)</span>.
This is an important duality studied in the field of information geometry.<label for="sn-12" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-12" class="margin-toggle"/><span class="sidenote">
S. Amari, A. Cichocki. 2010. 
<a href="http://fluid.ippt.gov.pl/bulletin/(58-1)183.pdf">Information geometry of divergence
functions.</a>
Bulletin of the Polish Academy of Sciences, 58(1).&nbsp;</span></p>
<p>We may now revisit the reparametrization strategy, in light of what we learned
so far. To reparametrize the constraint away, we work in <strong>dual coordinates</strong>
<span class="arithmatex">\(u \in \mathcal{U}\)</span>, and&nbsp;update:</p>
<div class="arithmatex">\[ u^{(t+1)} \leftarrow u^{(t)} - \nabla_u f(\phi(u)). \]</div>
<p>In our case <span class="arithmatex">\(\mathcal{U}=\reals^2\)</span> and <span class="arithmatex">\(\phi = \sigma\)</span>, but let&#8217;s use the more
general notation. The update above ignores the geometry of <span class="arithmatex">\(\mathcal{U}\)</span>, in
other words, operates on the trivial manifold <span class="arithmatex">\((\mathcal{U}, I_d)\)</span> &#8212; the
metric tensor is the identity matrix everywhere.  When optimizing some function <span class="arithmatex">\(\tilde{f}(u)\)</span>
over a manifold <span class="arithmatex">\((\mathcal{U}, G)\)</span>, a convenient algorithm is natural gradient, which takes the&nbsp;form</p>
<div class="arithmatex">\[ u^{(t+1)} \leftarrow u^{(t)} - \alpha_t [G(u)]^{-1} \nabla \tilde{f}(u^{(t)}). \]</div>
<details class="note"><summary>Derivation</summary><p>We follow the same steps as for gradient descent, but we use the induced distance
<span class="arithmatex">\(d_{u^{(t)}}\)</span> to find an update direction. We must solve the&nbsp;problem</p>
<div class="arithmatex">\[ \argmin_{u\in\mathcal{U}} \DP{u}{\nabla \tilde{f}(u^{(t)})} + \frac{1}{2\alpha_t} 
{(u - u^{(t)})^\top G(u^{(t)}) (u - u^{(t)}).} \]</div>
<p>Rearranging gives the equivalent&nbsp;problem</p>
<div class="arithmatex">\[ \argmin_{u\in\mathcal{U}} d^2_{u^{(t)}}
(u, u^{(t)} - \alpha_t[G(u^{(t)})]^{-1} \nabla \tilde{f}(u^{(t)})).\]</div>
<p>Assuming no constraints (i.e., <span class="arithmatex">\(\mathcal{U}=\reals^d\)</span>), this yields the
desired&nbsp;update.</p>
</details>
<p>It turns out that for a pair of Bregman dual manifolds
<span class="arithmatex">\((\mathcal{X}, \nabla^2 \Psi)\)</span> and <span class="arithmatex">\((\mathcal{U}, \nabla^2 \Phi),\)</span> 
<strong>mirror descent in the primal space is equivalent to natural gradient in the
dual space!</strong> This result, due to Raskutti and Mukherjee (2015),<label for="sn-13" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-13" class="margin-toggle"/><span class="sidenote">
G. Raskutti and S. Mukherjee. 2015. <em>The information geometry of mirror descent.</em>
In: <span class="caps">IEEE</span> Transactions on Information Theory, vol. 61, issue 3.
<a href="https://arxiv.org/abs/1310.7780">arXiv:1310.7780</a>.</span>
means we can get a geometry-aware flavor of the
<span class="caps">REP</span>&nbsp;algorithm,</p>
<div class="arithmatex">\[ u^{(t+1)} \leftarrow u^{(t)} - \alpha_t [\nabla^2 \Phi(u)]^{-1} \nabla_u {f}(\phi(u^{(t)})). \]</div>
<p>This algorithm takes the exact same steps as mirror descent, is arguably easier
to implement, and &#8212; since it maintains iterates in dual space &#8212; is more
numerically&nbsp;stable.</p>
<p>A first attempt at implementing this would&nbsp;be:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">optim_rep_natural</span><span class="p">(</span><span class="n">u_init</span><span class="p">,</span> <span class="n">lr</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">u_init</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">dsigmoid</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>  <span class="c1"># diagonal of ∇²Φ(u)</span>
        <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">u</span><span class="o">.</span><span class="n">data</span> <span class="o">-=</span> <span class="n">lr</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">grad</span> <span class="o">/</span> <span class="n">dsigmoid</span>
        <span class="n">u</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">u</span>
</code></pre></div>


<p>and we can visually check that we get exactly the same trajectory as mirror&nbsp;descent.</p>
<p><img alt="quadratic landscape" src="/images/mirror_primal_lr0.010_nat.png"></img></p>
<p>But let&#8217;s look a bit closer! Since <span class="arithmatex">\(\phi = \nabla\Phi\)</span>, our metric tensor is
none other&nbsp;than</p>
<div class="arithmatex">\[ \nabla^2\Phi(u) = \pfrac{\phi(u)}{u}, \]</div>
<p>and, putting the whole update together, we see&nbsp;that</p>
<div class="arithmatex">\[ [\nabla^2\Phi(u)]^{-1} \nabla_u f(\phi(u)) = 
{\left(\pfrac{\phi(u)}{u}\right)^{-1}}
{\pfrac{\phi(u)}{u}}
{\pfrac{f(x)}{x}\biggr\rvert_{x=\phi(u)}}  \]</div>
<p>so natural gradient cancels out the Jacobian of <span class="arithmatex">\(\phi\)</span> in the chain rule!
In our case, this is as if we used a sigmoid nonlinearity that acts as the
identity in the backward pass! This suggests an alternative implementation,
reminiscent of <em>straight through</em>&nbsp;tricks:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">SigmoidStraightThrough</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dx</span>


<span class="k">def</span> <span class="nf">sigmoid_straight_through</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">SigmoidStraightThrough</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">optim_rep_natural_st</span><span class="p">(</span><span class="n">u_init</span><span class="p">,</span> <span class="n">lr</span><span class="o">=.</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">u_init</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="n">f</span><span class="p">(</span><span class="n">sigmoid_straight_through</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">u</span><span class="o">.</span><span class="n">data</span> <span class="o">-=</span> <span class="n">lr</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">grad</span>
        <span class="n">u</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">u</span>
</code></pre></div>


<p>With this <code>sigmoid_straight_through</code> nonlinearity, we can now use mirror descent
/ natural gradient to learn constrained parameters without any changes to the
optimizer, and with improved numerical stability.  This strategy is aware of the
geometry of the dual space <span class="arithmatex">\((\mathcal{U}, \nabla^2\Phi)\)</span> and thus avoids taking
extra small steps while still ensuring that all the iterates remain&nbsp;feasible.</p>
<h1 id="conclusions">Conclusions.<a class="headerlink" href="#conclusions" title="Permanent link">&para;</a></h1>
<p>We have explored the two most popular strategies for dealing with simple
constraints: reparametrization and projected gradient optimization. We have
looked into an information geometric generalization of projected gradient, which
turns out to lead to an equivalent <em>dual</em> algorithm that resembles
reparametrization, but with a gradient correction that improves its performance.
(And, if <span class="arithmatex">\(f\)</span> is convex, results in a convex optimization procedure, unlike the
reparametrized&nbsp;case.)</p>
<p>Of course, we only looked at a simple quadratic test case, and we did not check
what happens when using accelerated methods or adaptive learning rates (e.g,.
Adam).  It would be interesting to see if the drop-in straight-through sigmoid
can improve performance compared to direct reparametrization in
real tasks. But this was not the main&nbsp;point&#8212;</p>
<p>With this post, I have hopefully stirred your interest into constrained
optimization and its connections to geometry. 
Geometric insights have been key to advances in learning over constrained spaces of
matrices, such as symmetric, low-rank, orthonormal, s.p.d. matrices, etc.
<label for="sn-14" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-14" class="margin-toggle"/><span class="sidenote">
P.-A. Absil, R. Mahoney, and Rodolphe Sepulchre. 2008.
<a href="https://press.princeton.edu/absil">Optimization Algorithms on Matrix
Manifolds</a>.
Princeton University Press. <span class="caps">ISBN</span> 978-0-691-13298-3
</span> 
Recently, the duality between mirror descent and natural gradient has been used
to derive powerful algorithms for minimax problems.<label for="sn-15" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-15" class="margin-toggle"/><span class="sidenote">
F. Schäfer, A. Anandkumar, H. Owhadi. 2020.
Competitive Mirror Descent.
<a href="https://arxiv.org/abs/2006.10179">arxiv:2006.10179</a>.&nbsp;</span></p>
<h1 id="acknowledgements">Acknowledgements.<a class="headerlink" href="#acknowledgements" title="Permanent link">&para;</a></h1>
<p>This post was inspired by <a href="https://video.ias.edu/machinelearning/2020/0709-AnimaAnandkumar">Anima Anandkumar&#8217;s
talk</a> at the 
<span class="caps">IAS</span> Seminar on Theoretical Machine Learning. Before this talk, I had no idea
about anything in the second part of this post.
Thanks to Caio Corro for feedback on the blog post.
Blogging is work, so I acknowledge my funding from the European Research Council
StG DeepSPIN 758969 and Fundação para a Ciência e Tecnologia contract <span class="caps">UIDB</span>/50008/2020. </p>
    </div><!-- /.entry-content -->

  </article>
</section>
 </div>
<footer>
  <p>Powered by <a href="http://pelican.readthedocs.org">Pelican</a>.
  <a href="/privacy.html">Privacy policy</a>.</p>
</footer>
</div>
</body>
</html>